{:pom {:description "A simple ClojureScript interface to React", :dependencies ({:group-id "org.clojure", :artifact-id "clojure", :scope "test", :optional nil, :version "1.10.3"} {:group-id "org.clojure", :artifact-id "clojurescript", :scope "test", :optional nil, :version "1.10.866"} {:group-id "figwheel", :artifact-id "figwheel", :scope "test", :optional nil, :version "0.5.20"} {:group-id "figwheel-sidecar", :artifact-id "figwheel-sidecar", :scope "test", :optional nil, :version "0.5.20"} {:group-id "doo", :artifact-id "doo", :scope "test", :optional nil, :version "0.1.11"} {:group-id "cljsjs", :artifact-id "prop-types", :scope "test", :optional nil, :version "15.7.2-0"} {:group-id "cljsjs", :artifact-id "react", :scope "test", :optional nil, :version "17.0.2-0"} {:group-id "cljsjs", :artifact-id "react-dom", :scope "test", :optional nil, :version "17.0.2-0"} {:group-id "cljsjs", :artifact-id "react-dom-server", :scope "test", :optional nil, :version "17.0.2-0"})}, :cache-bundle {:namespaces #{{:name "reagent.dom.server", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.component", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.dom", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.protocols", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.interop", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.template", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.ratom", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.debug", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.util", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.batching", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.core", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.input", :platform "cljs", :version-entity {:id 3, :version "1.1.0", :group-id "reagent", :artifact-id "reagent"}}}, :latest "1.1.0", :version-entity {:group-id "reagent", :artifact-id "reagent", :version "1.1.0"}, :defs #{{:name "Compiler", :file "reagent/impl/protocols.cljs", :line 3, :type :protocol, :members ({:name as-element, :arglists ([this x]), :type :var} {:name get-id, :arglists ([this]), :type :var} {:name make-element, :arglists ([this argv component jsprops first-child]), :type :var} {:name parse-tag, :arglists ([this tag-name tag-value]), :type :var}), :namespace "reagent.impl.protocols", :platform "cljs"} {:name "reaction", :file "reagent/ratom.clj", :line 8, :arglists ([& body]), :type :macro, :namespace "reagent.ratom", :platform "cljs"} {:name "force-update-all", :file "reagent/dom.cljs", :line 60, :arglists ([]), :doc "Force re-rendering of all mounted Reagent components. This is\nprobably only useful in a development environment, when you want to\nupdate components in response to some dynamic changes to code.\n\nNote that force-update-all may not update root components. This\nhappens if a component 'foo' is mounted with `(render [foo])` (since\nfunctions are passed by value, and not by reference, in\nClojureScript). To get around this you'll have to introduce a layer\nof indirection, for example by using `(render [#'foo])` instead.", :type :var, :namespace "reagent.dom", :platform "cljs"} {:name "dispose!", :file "reagent/core.cljs", :line 242, :arglists ([x]), :doc "Stop the result of track! from updating.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "custom-prop-name-cache", :file "reagent/impl/template.cljs", :line 75, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "atom", :file "reagent/ratom.cljs", :line 172, :arglists ([x] [x & {:keys [meta validator]}]), :doc "Like clojure.core/atom, except that it keeps track of derefs.\n", :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "is-client", :file "reagent/impl/util.cljs", :line 7, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "cached-custom-prop-name", :file "reagent/impl/template.cljs", :line 77, :arglists ([k]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "set-state", :file "reagent/core.cljs", :line 141, :arglists ([this new-state]), :doc "Merge component state with new-state.\nEquivalent to `(swap! (state-atom this) merge new-state)`", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "cached-react-class", :file "reagent/impl/component.cljs", :line 342, :arglists ([compiler c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "create-compiler", :file "reagent/core.cljs", :line 353, :arglists ([opts]), :doc "Creates Compiler object with given `opts`,\nthis can be passed to `render`, `as-element` and other functions to control\nhow they turn the Reagent-style Hiccup into React components and elements.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "IDisposable", :file "reagent/ratom.cljs", :line 337, :type :protocol, :members ({:name add-on-dispose!, :arglists ([this f]), :type :var} {:name dispose!, :arglists ([this]), :type :var}), :namespace "reagent.ratom", :platform "cljs"} {:name "*always-update*", :file "reagent/impl/util.cljs", :line 185, :dynamic true, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "valid-tag?", :file "reagent/impl/template.cljs", :line 30, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "*ratom-context*", :file "reagent/ratom.cljs", :line 12, :dynamic true, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "extract-props", :file "reagent/impl/component.cljs", :line 15, :arglists ([v]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "default-compiler*", :file "reagent/impl/template.cljs", :line 319, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "force-update", :file "reagent/impl/util.cljs", :line 187, :arglists ([comp deep]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "functional-render", :file "reagent/impl/component.cljs", :line 395, :arglists ([compiler jsprops]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "reactive?", :file "reagent/ratom.cljs", :line 17, :arglists ([]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "flush", :file "reagent/impl/batching.cljs", :line 103, :arglists ([]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "IRunnable", :file "reagent/ratom.cljs", :line 341, :type :protocol, :members ({:name run, :arglists ([this]), :type :var}), :namespace "reagent.ratom", :platform "cljs"} {:name "dash-to-method-name", :file "reagent/impl/component.cljs", :line 223, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "assert-js-object", :file "reagent/debug.clj", :line 84, :arglists ([value]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "reactify-component", :file "reagent/core.cljs", :line 59, :arglists ([c] [c compiler]), :doc "Returns an adapter for a Reagent component, that may be used from\nReact, for example in JSX. A single argument, props, is passed to\nthe component, converted to a map.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "fn-to-class", :file "reagent/impl/component.cljs", :line 349, :arglists ([compiler f]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "cache-get", :file "reagent/impl/template.cljs", :line 44, :arglists ([o k]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "schedule", :file "reagent/impl/batching.cljs", :line 123, :arglists ([]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "create-element", :file "reagent/core.cljs", :line 17, :arglists ([type] [type props] [type props child] [type props child & children]), :doc "Create a native React element, by calling React.createElement directly.\n\nThat means the second argument must be a javascript object (or nil), and\nthat any Reagent hiccup forms must be processed with as-element. For example\nlike this:\n\n```cljs\n(r/create-element \"div\" #js{:className \"foo\"}\n  \"Hi \" (r/as-element [:strong \"world!\"])\n```\n\nwhich is equivalent to\n\n```cljs\n[:div.foo \"Hi\" [:strong \"world!\"]]\n```", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "track-console", :file "reagent/debug.cljs", :line 10, :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "functional-do-render", :file "reagent/impl/component.cljs", :line 391, :arglists ([compiler c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "state", :file "reagent/core.cljs", :line 126, :arglists ([this]), :doc "Returns the state of a component, as set with replace-state or set-state.\nEquivalent to `(deref (r/state-atom this))`", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "try-get-react-key", :file "reagent/impl/util.cljs", :line 209, :arglists ([x]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "input-unmount", :file "reagent/impl/input.cljs", :line 125, :arglists ([this]), :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "track!", :file "reagent/core.cljs", :line 234, :arglists ([f & args]), :doc "An eager version of track. The function passed is called\nimmediately, and continues to be called when needed, until stopped\nwith dispose!.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "input-component-set-value", :file "reagent/impl/input.cljs", :line 67, :arglists ([this]), :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "built-in-static-method-names", :file "reagent/impl/component.cljs", :line 280, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "expand-seq-check", :file "reagent/impl/template.cljs", :line 246, :arglists ([x compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "track-warnings", :file "reagent/debug.cljs", :line 20, :arglists ([f]), :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "input-component?", :file "reagent/impl/input.cljs", :line 128, :arglists ([x]), :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "has-selection-api?", :file "reagent/impl/input.cljs", :line 12, :arglists ([input-type]), :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "NativeWrapper", :file "reagent/impl/template.cljs", :line 18, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "reactify-component", :file "reagent/impl/component.cljs", :line 370, :arglists ([comp compiler]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "state-atom", :file "reagent/impl/component.cljs", :line 60, :arglists ([this]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "render", :file "reagent/dom.cljs", :line 29, :arglists ([comp container] [comp container callback-or-compiler]), :doc "Render a Reagent component into the DOM. The first argument may be\neither a vector (using Reagent's Hiccup syntax), or a React element.\nThe second argument should be a DOM node.\n\nOptionally takes a callback that is called when the component is in place.\n\nReturns the mounted component instance.", :type :var, :namespace "reagent.dom", :platform "cljs"} {:name "mark-rendered", :file "reagent/impl/batching.cljs", :line 114, :arglists ([c]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "cached-parse", :file "reagent/impl/template.cljs", :line 195, :arglists ([this x _]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "custom-wrapper", :file "reagent/impl/component.cljs", :line 124, :arglists ([key f]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "current-component", :file "reagent/core.cljs", :line 114, :arglists ([]), :doc "Returns the current React component (a.k.a `this`) in a component\nfunction.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "do-before-flush", :file "reagent/impl/batching.cljs", :line 117, :arglists ([f]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "component-name", :file "reagent/impl/component.cljs", :line 102, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "merge-props", :file "reagent/core.cljs", :line 191, :arglists ([] [defaults] [defaults props] [defaults props & others]), :doc "Utility function that merges some maps, handling `:class` and `:style`.\n\nThe :class value is always normalized (using `class-names`) even if no\nmerging is done.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "get-children", :file "reagent/impl/component.cljs", :line 39, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "fragment-element", :file "reagent/impl/template.cljs", :line 183, :arglists ([argv compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "get-argv", :file "reagent/impl/component.cljs", :line 30, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "reagent-class?", :file "reagent/impl/component.cljs", :line 47, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "log", :file "reagent/debug.clj", :line 5, :arglists ([& forms]), :doc "Print with console.log, if it exists.\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "dont-camel-case", :file "reagent/impl/util.cljs", :line 26, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "run-in-reaction", :file "reagent/ratom.cljs", :line 529, :arglists ([f obj key run opts]), :doc "Evaluates `f` and returns the result.  If `f` calls `deref` on any ratoms,\ncreates a new Reaction that watches those atoms and calls `run` whenever\nany of those watched ratoms change.  Also, the new reaction is added to\nlist of 'watches' of each of the ratoms. The `run` parameter is a function\nthat should expect one argument.  It is passed `obj` when run.  The `opts`\nare any options accepted by a Reaction and will be set on the newly created\nReaction. Sets the newly created Reaction to the `key` on `obj`.", :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "Reaction", :file "reagent/ratom.cljs", :line 356, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "Track", :file "reagent/ratom.cljs", :line 206, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "dash-to-prop-name", :file "reagent/impl/util.cljs", :line 33, :arglists ([dashed]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "PartialFn", :file "reagent/impl/util.cljs", :line 64, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "tag-name-cache", :file "reagent/impl/template.cljs", :line 193, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "reagent-component?", :file "reagent/impl/component.cljs", :line 55, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "force-update", :file "reagent/core.cljs", :line 149, :arglists ([this] [this deep]), :doc "Force a component to re-render immediately.\n\nIf the second argument is true, child components will also be\nre-rendered, even is their arguments have not changed.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "cljsify", :file "reagent/impl/component.cljs", :line 270, :arglists ([body compiler]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "prop-name-cache", :file "reagent/impl/template.cljs", :line 40, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "next-mount-count", :file "reagent/impl/batching.cljs", :line 10, :arglists ([]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "create-class", :file "reagent/core.cljs", :line 68, :arglists ([spec] [spec compiler]), :doc "Creates JS class based on provided Clojure map, for example:\n\n```cljs\n{;; Constructor\n :constructor (fn [this props])\n :get-initial-state (fn [this])\n ;; Static methods\n :get-derived-state-from-props (fn [props state] partial-state)\n :get-derived-state-from-error (fn [error] partial-state)\n ;; Methods\n :get-snapshot-before-update (fn [this old-argv new-argv] snapshot)\n :should-component-update (fn [this old-argv new-argv])\n :component-did-mount (fn [this])\n :component-did-update (fn [this old-argv old-state snapshot])\n :component-will-unmount (fn [this])\n :component-did-catch (fn [this error info])\n :reagent-render (fn [args....])\n ;; Or alternatively:\n :render (fn [this])\n ;; Deprecated methods:\n :UNSAFE_component-will-receive-props (fn [this new-argv])\n :UNSAFE_component-will-update (fn [this new-argv new-state])\n :UNSAFE_component-will-mount (fn [this])}\n```\n\nEverything is optional, except either :reagent-render or :render.\n\nMap keys should use `React.Component` method names (https://reactjs.org/docs/react-component.html),\nand can be provided in snake-case or camelCase.\n\nState can be initialized using constructor, which matches React.Component class,\nor using getInitialState which matches old React createClass function and is\nnow implemented by Reagent for compatibility.\n\nState can usually be anything, e.g. Cljs object. But if using getDerivedState\nmethods, the state has to be plain JS object as React implementation uses\nObject.assign to merge partial state into the current state.\n\nReact built-in static methods or properties are automatically defined as statics.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "hiccup-tag?", :file "reagent/impl/template.cljs", :line 26, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "make-element", :file "reagent/impl/template.cljs", :line 129, :arglists ([this argv component jsprops first-child]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "raw-element", :file "reagent/impl/template.cljs", :line 228, :arglists ([comp argv compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "get-props", :file "reagent/impl/component.cljs", :line 33, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "merge-props", :file "reagent/impl/util.cljs", :line 165, :arglists ([] [p] [p1 p2] [p1 p2 & ps]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "make-track", :file "reagent/ratom.cljs", :line 228, :arglists ([f args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "comp-name", :file "reagent/impl/component.cljs", :line 106, :arglists ([]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "reaction", :file "reagent/core.clj", :line 12, :arglists ([& body]), :doc "Creates Reaction from the body, returns a derefable\ncontaining the result of the body. If the body derefs\nreactive values (Reagent atons, track, etc), the body\nwill run again and the value of the Reaction is updated.\n\nNew Reaction is created everytime reaction is called,\nso caller needs to take care that new reaction isn't created\ne.g. every component render, by using with-let, form-2 or form-3\ncomponents or other solutions. Consider using reagent.core/track,\nfor function that caches the derafable value, and can thus be safely\nused in e.g. render function safely.", :type :macro, :namespace "reagent.core", :platform "cljs"} {:name "adapt-react-class", :file "reagent/impl/template.cljs", :line 20, :arglists ([c]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "functional-render-memo-fn", :file "reagent/impl/component.cljs", :line 454, :arglists ([prev-props next-props]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "render-to-string", :file "reagent/dom/server.cljs", :line 8, :arglists ([component] [component compiler]), :doc "Turns a component into an HTML string.\n", :type :var, :namespace "reagent.dom.server", :platform "cljs"} {:name "reag-element", :file "reagent/impl/template.cljs", :line 158, :arglists ([tag v compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "assert-component", :file "reagent/debug.clj", :line 79, :arglists ([value]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "queue-render", :file "reagent/impl/batching.cljs", :line 109, :arglists ([c]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "error", :file "reagent/debug.clj", :line 26, :arglists ([& forms]), :doc "Print with console.error.\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "unchecked-aget", :file "reagent/interop.clj", :line 5, :arglists ([array idx] [array idx & idxs]), :type :macro, :namespace "reagent.interop", :platform "cljs"} {:name "make-wrapper", :file "reagent/ratom.cljs", :line 603, :arglists ([value callback-fn args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "create-class", :file "reagent/impl/component.cljs", :line 284, :arglists ([body compiler]), :doc "Creates JS class based on provided Clojure map.\n\nMap keys should use `React.Component` method names (https://reactjs.org/docs/react-component.html),\nand can be provided in snake-case or camelCase.\nConstructor function is defined using key `:getInitialState`.\n\nReact built-in static methods or properties are automatically defined as statics.", :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "with-let", :file "reagent/core.clj", :line 4, :arglists ([bindings & body]), :doc "Bind variables as with let, except that when used in a component\nthe bindings are only evaluated once. Also takes an optional finally\nclause at the end, that is executed when the component is\ndestroyed.", :type :macro, :namespace "reagent.core", :platform "cljs"} {:name "assert-new-state", :file "reagent/debug.clj", :line 89, :arglists ([value]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "rat-opts", :file "reagent/impl/component.cljs", :line 122, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "mount-count", :file "reagent/impl/batching.cljs", :line 8, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "get-wrapper", :file "reagent/impl/component.cljs", :line 212, :arglists ([key f]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "as-element", :file "reagent/core.cljs", :line 46, :arglists ([form] [form compiler]), :doc "Turns a vector of Hiccup syntax into a React element. Returns form\nunchanged if it is not a vector.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "make-reaction", :file "reagent/ratom.cljs", :line 517, :arglists ([f & {:keys [auto-run on-set on-dispose]}]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "set-default-compiler!", :file "reagent/core.cljs", :line 360, :arglists ([compiler]), :doc "Globally sets the Compiler object used by `render`, `as-element` and other\ncalls by default, when no `compiler` parameter is provided.\n\nUse `nil` value to restore the original default compiler.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "println", :file "reagent/debug.clj", :line 35, :arglists ([& forms]), :doc "Print string with console.log\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "re-tag", :file "reagent/impl/template.cljs", :line 14, :doc "Regular expression that parses a CSS-style id and class\nfrom a tag name.", :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "props", :file "reagent/core.cljs", :line 161, :arglists ([this]), :doc "Returns the props passed to a component.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "track", :file "reagent/ratom.cljs", :line 238, :arglists ([f & args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "convert-prop-value", :file "reagent/impl/template.cljs", :line 63, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "convert-props", :file "reagent/impl/template.cljs", :line 118, :arglists ([props id-class]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "cache-react-class", :file "reagent/impl/component.cljs", :line 345, :arglists ([compiler c constructor]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "fake-raf", :file "reagent/impl/batching.cljs", :line 13, :arglists ([f]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "functional-render-fn", :file "reagent/impl/component.cljs", :line 465, :arglists ([compiler tag]), :doc "Create copy of functional-render with displayName set to name of the\noriginal Reagent component.", :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "map-to-js", :file "reagent/impl/component.cljs", :line 264, :arglists ([m]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "vec-to-elem", :file "reagent/impl/template.cljs", :line 272, :arglists ([v compiler fn-to-element]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "has-console", :file "reagent/debug.cljs", :line 4, :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "time", :file "reagent/debug.clj", :line 66, :arglists ([& forms]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "state-atom", :file "reagent/core.cljs", :line 120, :arglists ([this]), :doc "Returns an atom containing a components state.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "dev?", :file "reagent/debug.clj", :line 61, :arglists ([]), :doc "True if assertions are enabled.\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "set-id-class", :file "reagent/impl/template.cljs", :line 99, :arglists ([props id-class]), :doc "Takes the id and class from tag keyword, and adds them to the\nother props. Parsed tag is JS object with :id and :class properties.", :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "do-render", :file "reagent/impl/component.cljs", :line 115, :arglists ([c compiler]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "adapt-react-class", :file "reagent/core.cljs", :line 52, :arglists ([c]), :doc "Returns an adapter for a native React class, that may be used\njust like a Reagent component function or class in Hiccup forms.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "children", :file "reagent/core.cljs", :line 167, :arglists ([this]), :doc "Returns the children passed to a component.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "add-obligatory", :file "reagent/impl/component.cljs", :line 230, :arglists ([fun-map]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "flush-after-render", :file "reagent/impl/batching.cljs", :line 106, :arglists ([]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "class-names", :file "reagent/core.cljs", :line 179, :arglists ([] [class] [class1 class2] [class1 class2 & others]), :doc "Function which normalizes and combines class values to a string\n\nReagent allows classes to be defined as:\n- Strings\n- Named objects (Symbols or Keywords)\n- Collections of previous types", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "*non-reactive*", :file "reagent/impl/util.cljs", :line 10, :dynamic true, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "functional-wrap-render", :file "reagent/impl/component.cljs", :line 375, :arglists ([compiler c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "render", :file "reagent/core.cljs", :line 370, :arglists ([& _]), :deprecated "0.10.0", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "flush", :file "reagent/core.cljs", :line 201, :arglists ([]), :doc "Render dirty components immediately.\n\nNote that this may not work in event handlers, since React.js does\nbatching of updates there.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "make-track!", :file "reagent/ratom.cljs", :line 231, :arglists ([f args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "flush!", :file "reagent/ratom.cljs", :line 505, :arglists ([]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "wrap-render", :file "reagent/impl/component.cljs", :line 68, :arglists ([c compiler]), :doc "Calls the render function of the component `c`.  If result `res` evaluates to a:\n1) Vector (form-1 component) - Treats the vector as hiccup and returns\n   a react element with a render function based on that hiccup\n2) Function (form-2 component) - updates the render function to `res` i.e. the internal function\n   and calls wrap-render again (`recur`), until the render result doesn't evaluate to a function.\n3) Anything else - Returns the result of evaluating `c`", :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "compare-mount-order", :file "reagent/impl/batching.cljs", :line 27, :arglists ([c1 c2]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "expand-seq-dev", :file "reagent/impl/template.cljs", :line 238, :arglists ([s o compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "*current-component*", :file "reagent/impl/component.cljs", :line 10, :dynamic true, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "camelify-map-keys", :file "reagent/impl/component.cljs", :line 225, :arglists ([fun-map]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "assert-callable", :file "reagent/debug.clj", :line 94, :arglists ([value]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "atom", :file "reagent/core.cljs", :line 211, :arglists ([x] [x & rest]), :doc "Like clojure.core/atom, except that it keeps track of derefs.\nReagent components that derefs one of these are automatically\nre-rendered.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "parse-tag", :file "reagent/impl/template.cljs", :line 146, :arglists ([hiccup-tag]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "running", :file "reagent/ratom.cljs", :line 23, :arglists ([]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "with-let-values", :file "reagent/ratom.cljs", :line 329, :arglists ([key]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "dash-to-method-name", :file "reagent/impl/util.cljs", :line 42, :arglists ([dashed]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "partial", :file "reagent/core.cljs", :line 348, :arglists ([f & args]), :doc "Works just like clojure.core/partial, but the result can be compared with =\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "memoize-1", :file "reagent/impl/util.cljs", :line 16, :arglists ([f]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "hiccup-element", :file "reagent/impl/template.cljs", :line 256, :arglists ([v compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "prn", :file "reagent/debug.clj", :line 40, :arglists ([& forms]), :doc "Like standard prn, but prints using console.log (so that we get\nnice clickable links to source in modern browsers).", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "next-tick", :file "reagent/core.cljs", :line 333, :arglists ([f]), :doc "Run f using requestAnimationFrame or equivalent.\n\nf will be called just before components are rendered.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "render-to-static-markup", :file "reagent/dom/server.cljs", :line 17, :arglists ([component] [component compiler]), :doc "Turns a component into an HTML string, without data-react-id attributes, etc.\n", :type :var, :namespace "reagent.dom.server", :platform "cljs"} {:name "tracking", :file "reagent/debug.cljs", :line 6, :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "expand-seq", :file "reagent/impl/template.cljs", :line 235, :arglists ([s compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "react-class?", :file "reagent/impl/component.cljs", :line 51, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "after-render", :file "reagent/core.cljs", :line 340, :arglists ([f]), :doc "Run f using requestAnimationFrame or equivalent.\n\nf will be called just after any queued renders in the next animation\nframe (and even if no renders actually occur).", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "input-render-setup", :file "reagent/impl/input.cljs", :line 86, :arglists ([this jsprops]), :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "custom-kv-conv", :file "reagent/impl/template.cljs", :line 86, :arglists ([o k v]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "warn", :file "reagent/debug.clj", :line 11, :arglists ([& forms]), :doc "Print with console.warn.\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "shallow-obj-to-map", :file "reagent/impl/util.cljs", :line 193, :arglists ([o]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "default-compiler", :file "reagent/impl/template.cljs", :line 320, :dynamic true, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "make-partial-fn", :file "reagent/impl/util.cljs", :line 119, :arglists ([f args]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "ratom-flush", :file "reagent/impl/batching.cljs", :line 43, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "with-let", :file "reagent/ratom.clj", :line 20, :arglists ([bindings & body]), :type :macro, :namespace "reagent.ratom", :platform "cljs"} {:name "debug", :file "reagent/ratom.cljs", :line 13, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "argv", :file "reagent/core.cljs", :line 173, :arglists ([this]), :doc "Returns the entire Hiccup form passed to the component.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "input-handle-change", :file "reagent/impl/input.cljs", :line 77, :arglists ([this on-change e]), :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "RenderQueue", :file "reagent/impl/batching.cljs", :line 54, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "do-after-render", :file "reagent/impl/batching.cljs", :line 120, :arglists ([f]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "HiccupTag", :file "reagent/impl/template.cljs", :line 144, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "wrap-funs", :file "reagent/impl/component.cljs", :line 233, :arglists ([fmap compiler]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "named?", :file "reagent/impl/util.cljs", :line 122, :arglists ([x]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "warnings", :file "reagent/debug.cljs", :line 8, :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "warn-unless", :file "reagent/debug.clj", :line 20, :arglists ([cond & forms]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "maybe-function-element", :file "reagent/impl/template.cljs", :line 175, :arglists ([tag v compiler]), :doc "If given tag is a Class, use it as a class,\nelse wrap in Reagent function wrapper.", :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "is-client", :file "reagent/core.cljs", :line 15, :type :var, :namespace "reagent.core", :platform "cljs"} {:name "create-compiler", :file "reagent/impl/template.cljs", :line 302, :arglists ([opts]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "get-react-key", :file "reagent/impl/util.cljs", :line 215, :arglists ([x]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "capitalize", :file "reagent/impl/util.cljs", :line 28, :arglists ([s]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "hiccup-err", :file "reagent/impl/util.cljs", :line 245, :arglists ([v comp-name & msg]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "class-names", :file "reagent/impl/util.cljs", :line 126, :arglists ([] [class] [a b] [a b & rst]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "rswap!", :file "reagent/core.cljs", :line 311, :arglists ([a f & args]), :doc "Swaps the value of a to be `(apply f current-value-of-atom args)`.\n\nrswap! works like swap!, except that recursive calls to rswap! on\nthe same atom are allowed – and it always returns nil.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "with-let-destroy", :file "reagent/ratom.cljs", :line 325, :arglists ([v]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "enqueue", :file "reagent/impl/batching.cljs", :line 49, :arglists ([queue fs f]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "cursor", :file "reagent/core.cljs", :line 272, :arglists ([src path]), :doc "Provide a cursor into a Reagent atom.\n\nBehaves like a Reagent atom but focuses updates and derefs to\nthe specified path within the wrapped Reagent atom. e.g.,\n\n```cljs\n(let [c (cursor ra [:nested :content])]\n  ... @c ;; equivalent to (get-in @ra [:nested :content])\n  ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)\n  ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)\n  )\n```\n\nThe first parameter can also be a function, that should look\nsomething like this:\n\n```cljs\n(defn set-get\n  ([k] (get-in @state k))\n  ([k v] (swap! state assoc-in k v)))\n```\n\nThe function will be called with one argument – the path passed to\ncursor – when the cursor is deref'ed, and two arguments (path and\nnew value) when the cursor is modified.\n\nGiven that set-get function, (and that state is a Reagent atom, or\nanother cursor) these cursors are equivalent:\n`(cursor state [:foo])` and `(cursor set-get [:foo])`.\n\nNote that a cursor is lazy: its value will not change until it is\nused. This may be noticed with add-watch.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "input-node-set-value", :file "reagent/impl/input.cljs", :line 18, :arglists ([node rendered-value dom-value component {:keys [on-write]}]), :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "RCursor", :file "reagent/ratom.cljs", :line 248, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "these-inputs-have-selection-api", :file "reagent/impl/input.cljs", :line 9, :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "assert-some", :file "reagent/debug.clj", :line 76, :arglists ([value tag]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "run-queue", :file "reagent/impl/batching.cljs", :line 32, :arglists ([a]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "fun-name", :file "reagent/impl/util.cljs", :line 50, :arglists ([f]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "next-tick", :file "reagent/impl/batching.cljs", :line 16, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "function-element", :file "reagent/impl/template.cljs", :line 166, :arglists ([tag v first-arg compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "react-key-from-vec", :file "reagent/impl/util.cljs", :line 219, :arglists ([v]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "track!", :file "reagent/ratom.cljs", :line 242, :arglists ([f & args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "unchecked-aset", :file "reagent/interop.clj", :line 14, :arglists ([array idx val] [array idx idx2 & idxv]), :type :macro, :namespace "reagent.interop", :platform "cljs"} {:name "set-default-compiler!", :file "reagent/impl/template.cljs", :line 322, :arglists ([compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "check-derefs", :file "reagent/ratom.cljs", :line 548, :arglists ([f]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "as-class", :file "reagent/impl/component.cljs", :line 365, :arglists ([tag compiler]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "extract-children", :file "reagent/impl/component.cljs", :line 19, :arglists ([v]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "as-element", :file "reagent/impl/template.cljs", :line 292, :arglists ([this x fn-to-element]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "Wrapper", :file "reagent/ratom.cljs", :line 556, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "wrap", :file "reagent/core.cljs", :line 247, :arglists ([value reset-fn & args]), :doc "Provide a combination of value and callback, that looks like an atom.\n\nThe first argument can be any value, that will be returned when the\nresult is deref'ed.\n\nThe second argument should be a function, that is called with the\noptional extra arguments provided to wrap, and the new value of the\nresulting 'atom'.\n\nUse for example like this:\n\n```cljs\n(wrap (:foo @state)\n      swap! state assoc :foo)\n```\n\nProbably useful only for passing to child components.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "dom-node", :file "reagent/dom.cljs", :line 55, :arglists ([this]), :doc "Returns the root DOM node of a mounted component.\n", :type :var, :namespace "reagent.dom", :platform "cljs"} {:name "run-funs", :file "reagent/impl/batching.cljs", :line 45, :arglists ([fs]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "unmount-component-at-node", :file "reagent/dom.cljs", :line 50, :arglists ([container]), :doc "Remove a component from the given DOM node.\n", :type :var, :namespace "reagent.dom", :platform "cljs"} {:name "obligatory", :file "reagent/impl/component.cljs", :line 220, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "dbg", :file "reagent/debug.clj", :line 46, :arglists ([x]), :doc "Useful debugging macro that prints the source and value of x,\nas well as package name and line number. Returns x.", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "convert-custom-prop-value", :file "reagent/impl/template.cljs", :line 90, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "native-element", :file "reagent/impl/template.cljs", :line 202, :arglists ([parsed argv first compiler]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "RAtom", :file "reagent/ratom.cljs", :line 127, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "run!", :file "reagent/ratom.clj", :line 12, :arglists ([& body]), :doc "Runs body immediately, and runs again whenever atoms deferenced in the body change. Body should side effect.\n", :type :macro, :namespace "reagent.ratom", :platform "cljs"} {:name "render-queue", :file "reagent/impl/batching.cljs", :line 101, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "cached-prop-name", :file "reagent/impl/template.cljs", :line 48, :arglists ([k]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "track", :file "reagent/core.cljs", :line 218, :arglists ([f & args]), :doc "Takes a function and optional arguments, and returns a derefable\ncontaining the output of that function. If the function derefs\nReagent atoms (or track, etc), the value will be updated whenever\nthe atom changes.\n\nIn other words, `@(track foo bar)` will produce the same result\nas `(foo bar)`, but foo will only be called again when the atoms it\ndepends on changes, and will only trigger updates of components when\nits result changes.\n\ntrack is lazy, i.e the function is only evaluated on deref.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "input-spec", :file "reagent/impl/input.cljs", :line 133, :type :var, :namespace "reagent.impl.input", :platform "cljs"} {:name "kv-conv", :file "reagent/impl/template.cljs", :line 59, :arglists ([o k v]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "replace-state", :file "reagent/core.cljs", :line 133, :arglists ([this new-state]), :doc "Set state of a component.\nEquivalent to `(reset! (state-atom this) new-state)`", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "IReactiveAtom", :file "reagent/ratom.cljs", :line 125, :type :protocol, :namespace "reagent.ratom", :platform "cljs"} {:name "props-argv", :file "reagent/impl/component.cljs", :line 25, :arglists ([c p]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "js-val?", :file "reagent/impl/util.cljs", :line 204, :arglists ([x]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "cursor", :file "reagent/ratom.cljs", :line 311, :arglists ([src path]), :type :var, :namespace "reagent.ratom", :platform "cljs"}}, :version {:jar {}, :config {:cljdoc.api/platforms #{"cljs"}, :cljdoc.doc/tree [["Documentation index" {:file "doc/README.md"}] ["Tutorials" {} ["Using Hiccup to Describe HTML" {:file "doc/UsingHiccupToDescribeHTML.md"}] ["Creating Reagent Components" {:file "doc/CreatingReagentComponents.md"}] ["Using [square brackets] instead of (parentheses)" {:file "doc/UsingSquareBracketsInsteadOfParens.md"}] ["When do components update?" {:file "doc/WhenDoComponentsUpdate.md"}] ["[WIP] Managing State: atoms, cursors, Reactions, and tracking" {:file "doc/ManagingState.md"}] ["Batching and Timing: How Reagent Renders Changes to Application State" {:file "doc/BatchingAndTiming.md"}] ["Interop with React" {:file "doc/InteropWithReact.md"}] ["React Features" {:file "doc/ReactFeatures.md"}] ["Reagent Compiler" {:file "doc/ReagentCompiler.md"}] ["Controlled Inputs" {:file "doc/ControlledInputs.md"}]] ["Frequently Asked Questions" {} ["Why isn't my Component re-rendering?" {:file "doc/FAQ/ComponentNotRerendering.md"}] ["How do I use React's \"refs\"" {:file "doc/FAQ/UsingRefs.md"}] ["How can I use an entity like \"nbsp\"?" {:file "doc/FAQ/UsingAnEntity.md"}] ["Why is my attribute (like autoFocus) missing?" {:file "doc/FAQ/MyAttributesAreMissing.md"}] ["How can I use React's dangerouslySetInnerHTML?" {:file "doc/FAQ/dangerouslySetInnerHTML.md"}] ["Reagent doesn't work after updating dependencies" {:file "doc/FAQ/CljsjsReactProblems.md"}] ["How do I force Component re-creation?" {:file "doc/FAQ/ForcingComponentRecreation.md"}] ["Using HTML entities" {:file "doc/FAQ/HtmlEntities.md"}]] ["Examples" {} ["Material-UI v1" {:file "doc/examples/material-ui.md"}]] ["Other" {} ["0.8 Upgrade guide" {:file "doc/0.8-upgrade.md"}] ["Development guide" {:file "doc/development.md"}]]]}, :scm {:rev "d2ed1a7de43913955ec6cc29fae7e4a65eaca8db", :files {"test/reagent/impl/util_test.cljs" "03da94ef77faf8a4d09ceba8f740ffb6315f5a9e186b282748714182791f4bb4", "CONTRIBUTING.md" "d02c4dca781eb2bbf61de0f30680c44600cfb1151d987c20c3917f6d414316e6", "examples/functional-components-and-hooks/project.clj" "b0d1e36272cdefa5aec82858c73c3850762c10a96f690c00294986a5171e77d6", "test/reagent/impl/template_test.cljs" "7f5dbf6188cbd3edb1d8394ddef647400a929940a6716b9eb33b8c34906d0507", "doc/FAQ/ForcingComponentRecreation.md" "dfd15b45769a83362820934a2aba24c0134506a12e87c7e14e601a162d168d46", "examples/geometry/resources/public/example.css" "4aaea212ca279d3bfdfa22f109ca0b802cccd4b1b38d5280ea1a1747ce929142", "demo/reagentdemo/news/binaryclock.cljs" "b81b254be620c688c0a60d7d736206d7c0ed7084e2dcb11bf0c5a13846304db9", "examples/material-ui/src/example/core.cljs" "67d03f42a0c9fd277afb435076fb1f4a4c39338ed924ad02482441127b9843cb", "src/reagent/impl/protocols.cljs" "4ee93b74f39ef7fe363d18ef0e8764c4184647fcf2dedc6af9a55af9ee6c0a41", "codecov.yml" "3c895f1b8ed37edf09752818e003104612aae58fad9fe0a7a2b746a5fbc69ca3", "examples/geometry/src/geometry/geometry.cljs" "bfd23894083859613463253404db72b178f82ed9e9355f92303628b96d69eef5", "site/public/index.html" "86a587ca917f9afcbf3de5e9f125455cbe064f67e9befa5cfe93f69cbc52b0aa", "examples/material-ui/shadow-cljs.edn" "a28d3dc19d9f739ce402e2274e1e2652a6596e4c567506bbea1f20c8c4cad854", "examples/todomvc/project.clj" "60e28fa6eff72e8b4c8697c3a7ed65c2b186750721af1e5ec7ce06f7fc80cbb6", "examples/react-mde/package.json" "090ea289e963531ac3d4cc76b4f0e9af2ee1d9f94cca37f13d7453865d8c4e96", "doc/development.md" "3cd9b71c1fff458cbe5ed315094dd10cbbf25927f99980ac4a9985ec3daa8b19", "test/runners/karma.conf.js" "3ea13eded21fdbd6453ab3e4588a8467d15a8d7e43f88126fd3943595db2a6a0", "prerender/sitetools/prerender.cljs" "db3fb3985a49d40653353c8f9eb92452bca40b4a1ed8454da27699150cff6bc9", "test-environments/bundle/build.edn" "50b24b61de9f886e62ece7efbf539ed7e226086afb202d3add952f559abe0b0c", "doc/WhenDoComponentsUpdate.md" "a21050088761f793184c79811804790353be31f4de2915b95ca1f33981e06dd6", "examples/functional-components-and-hooks/README.md" "f6d7e11baadfdfcee8f9df24466974390def6e3fe273fa55dfa9ae54876b82d8", "doc/FAQ/dangerouslySetInnerHTML.md" "b62052d1174d3cd17b2fbf371691acc6e852d46169a2ad77fdca97a18eaa0bad", "src/reagent/dom/server.cljs" "6462b124581d3412c882a32dd9276369e3dfe8f01bf76e436f75b6e73ee31578", "examples/react-mde/resources/public/index.html" "e5d30ac5361f62ec39a739f01d12a5914244e6776dd74af629f501043ad8f41b", "README.md" "91494bed07949e0f2fe808553304397a53d9ee3c7b445343a7c595d918209c72", "doc/FAQ/ComponentNotRerendering.md" "9c4db3eb44ba3df102a260cfe0deca7b2698939628b61d9bbc51e455ce1985d7", "src/reagent/interop.cljs" "71b2aa1157bc3955a9e93623601443886e8f489fb4752b73f8d575546481f6d2", "test-environments/shadow-cljs-prod/karma.conf.js" "ed002cce56bdbfa3c43ea236a4bf6e95422190e12e00994263a4b0ab93951449", "doc/FAQ/HtmlEntities.md" "2253e91981658bf637f9c2eee0ff708cd74242c98691075217b414bc67ea155c", "test-environments/browser-cljsjs-prod/test.sh" "078b5ba5916597f558255224bbcb8d77b9b1677d7d9556b0560778ba6fbd1f00", "doc/benchmark.png" "5d2533c4f86a915e43c1fa59ea49312c9587a845b59bad549f7326e68c94cc59", ".github/workflows/clojure.yml" "34e62e8af7b1db645d0ffdd5931dbcae4b9e21bfb19daab9f0bb704cc41f44f4", "examples/functional-components-and-hooks/resources/public/index.html" "e62eef61a16f2ef1c3927f485e9755713d8f686b5c7bfe89fb2800fd56f4e956", "test-environments/bundle-adv/README.md" "3dc7ea77567a541a1315f276dc251964248eaaf8551573bace8abf5c00557eba", "src/reagent/dom.cljs" "3964d9cb4947bb9c70d0d7a715a8b0e3f9b662eeeb5342e9a1e826d468103a3e", ".clj-kondo/config.edn" "ed05861570914d4c4562b4b9952cf71255c027563f8f326d541ce2a953856700", "demo/reagentdemo/news/undodemo.cljs" "4ca28d41094d2f362d876b839d61c019c2ccf16b2d8e5b067e371d415292349b", "demo/reagentdemo/syntax.cljs" "b783c314944e6a464c9716f35ae22e25ada98e1323d2ca8590c3a1d092a493b2", "examples/react-context/resources/public/index.html" "3ee2a32bccae6856df5c6343bcb230408f44f783f83403308662586138189a03", "outsite/public/README.md" "4122db21cb1e8fae8a0d0ef7045ef747934ef7765cdd5e40d4ea66165ff05b5f", "run-tests.sh" "b278d46898e6266e91495365e968ccdaf35bef216525eb43191e8ca48779e659", "test-environments/node-npm/test.sh" "fed7dca98137f68a1b48c48acddd8a65eb00793bcc6b24ebebbeb87346060b21", "demo/reagentdemo/news/news060.cljs" "14f2172f9f00b2f402e9408774b53863097ece162fb8b1b481dcf29bf206966a", "site/public/css/examples.css" "95eb3964399be67143bb4965e9aab1eb6bb83302cf98b41f0dbc2d5cdd4de0a7", "src/reagent/impl/input.cljs" "5fc8fe3afcae0c4cccb6712a80636e008a6feb9fede2e7a21f405eeac4f2c8f3", "examples/react-mde/package-lock.json" "e0316b7a0138a06b8b14b49a6ec1e64f827e5b0ac8391a51f2a0239d646812f2", "src/reagent/interop.clj" "ecc0a30083fff1abdc1589675d7a459e3144d942e2acc5b082213825c915a624", "test-environments/bundle/karma.conf.js" "5c3173a4aa4d6cf0135fd01acd44c2888e35e7fc5e1ed06cf077c369f350be85", "test/reagenttest/testratom.cljs" "79b6bcada8c1a36ad45439feb90ce1776797b2cfcb07160e194231589a513804", "demo/reagentdemo/news/news050.cljs" "b6dc5a54d91c1a424df9e7b2607d9347940d54af16372df2b221f4c591d06c3d", "test-environments/browser-npm/test.sh" "f089bde58d22d811c2b02afcf8c4ea0edad7d9a04cbd2e18641a23a0d10f48b5", "doc/ReagentCompiler.md" "ad9f1c4b0faefda6fa48d95225c7e2b832f44512ba44861533ca5a2fe91a4e18", "examples/geometry/README.md" "f6d7e11baadfdfcee8f9df24466974390def6e3fe273fa55dfa9ae54876b82d8", "test/reagenttest/testcursor.cljs" "7cff4abe2cdac51ff2395b5a9197b6d8434549a155f68628bf73476a8743c6f0", "examples/react-mde/resources/public/react-mds-all.css" "a2f901f42dad0dadf61bb35ae7f826c15569f3b8f557efbb84ae1112b18b7eca", "LICENSE" "20b9887a7a6b93a6c336b5f18e51b47a610cd5c335ce7a97604d2ea20ec93692", "doc/UsingHiccupToDescribeHTML.md" "bd371a3691d78059f72a003008fe0b0d22c01945a235c893de23a8fb2e332c7b", "logo/logo.svg" "8d661d0e8bb9753cff4350038bc581fad6463443b3a6588b79cfe983fdcca730", "src/reagent/impl/batching.cljs" "ba37f7baf424914ca7b8aaacc1deadf05814046d3caca1cf873cceb119688aba", "test-environments/browser-cljsjs/test.sh" "eb148f33718f95bde6b2d0daf61a543b8baabc6a27acf8336c24fd91014d6d5b", "examples/todomvc/resources/public/index.html" "06f3ee2fa9959c1595eb84434933032f29fc9a3e65b204a59c8533f7dad7ddbd", "examples/functional-components-and-hooks/resources/public/example.css" "5d677e179d5a6a714159d775627e8bf95afea0c3cf90b97b19abef7ae3e53546", "demo/reagentdemo/news/news060rc.cljs" "fe882a58aac3fc951c39c8b111394cc1ed4c6fb4d8bf58a4e0925e76208cddd1", "logo/logo.png" "3558cfa77431c0ec79945b702aabbba332c651502a56a08183b4916a58fab42a", "test-environments/node-cljsjs/test_disabled.sh" "c4427e3d28e9696de138944cb7760ebbf39a3e3858a6c1364e524c620ce794b2", "examples/simple/resources/public/index.html" "1c637b2bc2d172e62456e697d94fe6d96fb3acf6fe660dceeeac84b4b6529995", "examples/geometry/src/geometry/core.cljs" "c811c5fcd586d4eaed23ecfca9e848bf193591fc0963a0771f21b2014f9af7a5", "test-environments/bundle-adv/karma.edn" "a47d16eaecf09eb4c037ce4d40f6afaeee57c14f3b5ec6d027c304dfd0d1dac4", "build-example-site.sh" "29feef3f642641a8f95426fc6a6b1be8f2da2d1668fef593633900389d4d2a09", "test-environments/bundle/workaround.js" "dea9762a221edb521d9e7eadcb41842ff118e039262b9a085076f1872fc73bd0", "doc/README.md" "a04624f331473e42311cf12482144cdd713680602c5ecc57afc4f426b87ccb5c", "test-environments/bundle/webpack.config.js" "2e7bba2f19b03d625f5b6e1de5b517ad0bed81d9288f6f88f1112f0dcdd248f9", "src/reagent/impl/template.cljs" "89f52b7dfa4ef9160d3e4c2587ce11726acc22bc762501c4e609ba6cc99bc92c", "demo/sitetools/core.cljs" "e1115463e085fb527f4a7849b3772304d85cbe84b35f2a264b33ef3300c9963a", "doc/examples/material-ui.md" "65e2c7be91713ad5233e45f37c502493187bd62d61d5e176263dc0d2e3ecf661", "src/reagent/impl/component.cljs" "1154c8282a55b3aef4b7dfd3d570e96fc4db692953bc5b49ac2b6d6d87a934eb", "doc/FAQ/UsingRefs.md" "2e22318ef773f9fa09f895820db67a24d33d695f8fcbd4c7ce4e15ce0cbf6431", "examples/react-context/src/example/core.cljs" "94a0de2ac25a698cf7f182dbef67080078e07bb43a88fd340c5ee0418b3cf8aa", "examples/react-sortable-hoc/src/example/core.cljs" "33f1fcd5ff1da75312bc8db74ec2f9e2161dbd39e524f8471d1b34c65b370087", "examples/react-transition-group/resources/public/fade.css" "10aff7d0649658c887f444d3ad0a741b0b8771b9a82de8c668112dba901e0a29", "test-environments/bundle-adv/test.sh" "4095f6f2018683e25b73b524b7404482057662570aaddd58524c025913b01c38", "demo/reagentdemo/syntax.clj" "f693ded9403a5622769cc3053e0964370f7d7170f782f56d10e49fae67fbbb58", "test-environments/bundle-adv/build.sh" "eace0c9eb1a553ef05be5a734f55d5215a71b90cd758cdfb84e49c8dc1a961f1", "demo/reagentdemo/news/anyargs.cljs" "46de4703c812b58de4338043fb883e9e3efb580925bf8c186c385a17405cc674", "examples/todomvc/src/todomvc/core.cljs" "72a732a964abbae173df086624c90ac0dd4bda0aca27bb3ef0a073f27baad023", "logo/logo-text.svg" "fae32f9920fde34810ecf000b7e4b06451145fcdfb208f676a87f2ecc7f98a21", "examples/react-mde/Readme.md" "cae1d42dcf2123ab167586619b1497c832825fedaa740b02a43c25f2dd80d05c", "demo/reagentdemo/news/news051.cljs" "87f94c7438346a0c406ebddacce0e17d5881a20d0b81a4cb612b06ff363e02ca", "doc/ControlledInputs.md" "aab154971980ff36aa5456b38780526fdec03153baa480fe19656be4207f327b", "demo/reagentdemo/news/async.cljs" "40f44ce44c7dc0e58710762f6524842cdbd573f8e8329d74ca458b39174dacd6", "doc/InteropWithReact.md" "bea23c87025517089048762b4a2622d7e11212242385828e10b05f8617e04427", "doc/examples/smooth-ui.md" "8fafe6899ac96932828c02842bdfc4ac6d75c5a3ed7493d0bb5220989a4777fc", "site/public/css/main.css" "a633b72918c68e2ce026feca6c9144d48cb8e3f52474c606cf281f7803150bae", "demo/reagentdemo/intro.cljs" "26fbb7ddccf824566149400a33bef52616288735e066b8e59e238b1262a9e53c", "test/reagenttest/utils.cljs" "ff086aa74824868f063d2de608739448311790ac72a0ac97c77f1687faebed85", "src/reagent/core.cljs" "d4b61752dccd9aaaaa05323500d970167710476c46afbd9cc3d6cdd4e489238d", "demo/reagentdemo/prod.cljs" "2f23df1156d809c734fa445c5ff6955a865f490727c43b26de6d8f76969a0a30", "demo/reagentdemo/core.cljs" "bc9bbb1308a86b552837aebd7c4ac5c956b1a01de0625a8db19fc243d5c6c9df", "test-environments/bundle-adv/karma.conf.js" "f04d84ed11d63a172360ea215b039c49077c5af21e30b6500cf44427efc021cf", "demo/reagentdemo/news/news060release.cljs" "6745bc9a9ba2cd03c6d153052056b68e8e446c8f58f7be3476890e9d72ee3f9e", "build-docs.sh" "3657222380e534e40dd3264cc4fe3e8d2dd644c3ff9e3fdb267395d65bbb9f12", "demo/reagentdemo/news.cljs" "e0a6da195264fdb245dc12278f1b06b4242cfea7b9a8a2a9992153cc58f6f77b", "examples/geometry/resources/public/index.html" "5f69acbd5d31d9a2262625c7aa02c54ad64be0ff4295002e38c2424c257e46d6", "test/reagenttest/testwrap.cljs" "de42b661ba86d74f062606e2f589da54843af9ffa395eadc9f7f3bc61a9e44e3", "lib/modules.js" "414bb2220c1ca75e3e66a6e3b76a895d95e7d89a2ceb137669fc8d217ce40ee1", "examples/react-sortable-hoc/resources/public/index.html" "3ee2a32bccae6856df5c6343bcb230408f44f783f83403308662586138189a03", "examples/todomvc/resources/public/todos.css" "827d132a7d8ad1e04ae2498e331f2975654b5e5f846266435903d6a8adb5b337", "demo/reagentdemo/common.cljs" "019f30ef7c30baa04a13f2f9a02356453b281facf3cd788c0ec80bfc099ea9e7", "examples/geometry/src/geometry/components.cljs" "ee6b3f833f9236e2d95d347cdeb1e46e520fb98fd57ac0b6612b322e1a160be0", "test-environments/bundle-adv/build.edn" "e367c4187ccefd874a642e7889101730727023bd80ad4c7690edf9d81ff4021d", "examples/material-ui/resources/public/index.html" "3ee2a32bccae6856df5c6343bcb230408f44f783f83403308662586138189a03", "demo/reagentdemo/news/news061.cljs" "540ba5dbab1aafc66dae091844f600f4099b45b83180cd0b274616c300b04561", ".gitignore" "53ca4aa77b02f416612553ec2bd2b7e9e444a8478e57088d6d2014162ea35ea5", "test-environments/bundle-adv/webpack.config.js" "323d6f4fb8e1563e3bbbec5bebd163e99826b585f9835e567fd55ea0bca34817", "package.json" "f941147f99688f05c851b69adff748980ba41c0f79fbb02dbf87980b7d5e032f", "src/reagent/impl/util.cljs" "f04886e1b33bdcbaecd6b39ea97034f66aad16f18fc38511082ca242277300c1", "examples/material-ui/package.json" "9c6643ec6a4da191338eb0b48d229f3e66abbebbe3dd54fc7b67d68702bef3ce", "doc/CreatingReagentComponents.md" "bfa86797cfa7f50ea479d80d5abe83f29321cd3e48137eba73cded48b3e92def", "demo/reagentdemo/dev.cljs" "31a8479fea04e56bf4da7a6758ab62bf5d67e1e09c6e5e4e2ca49e4b9f4879a3", "examples/functional-components-and-hooks/src/example/core.cljs" "5354149cd0dfa8aa3aab47e76f3899b1c8a006291c00584a50fe8a891c813c5f", "examples/todomvc/README.md" "f6d7e11baadfdfcee8f9df24466974390def6e3fe273fa55dfa9ae54876b82d8", "logo/logo-text.png" "e1e068c3c39170b90355198015784613ca32267ab18c634996c0bff0cca330cd", "doc/ReactFeatures.md" "c81f986a21de1dfe765798840d4a8ccf30a9a9dd66fca720e61f994ada1a3980", "test/reagenttest/testreagent.cljs" "aee8ed6df9af5873df44308293b8e498aee6c2312d79bb4a6da1ad1da10ddd8b", "prepare-tests.sh" "8b9b6dec3c9415b662b3c0a5755de6d5e8a48a16d47155b49e450f5d856a1319", "examples/react-context/project.clj" "e2ae146be77411f31a14d67cee6b21ec478c87d0aaad1f30dd2c8d91e550b735", "doc/cljdoc.edn" "db68d3a5b7d682b13df7f877d58388311c707196b8ac83ae4e5f001802c6e429", "examples/react-mde/shadow-cljs.edn" "a28d3dc19d9f739ce402e2274e1e2652a6596e4c567506bbea1f20c8c4cad854", "examples/simple/project.clj" "faa6af051e4ecdda577981691ff72ffd22a171c7dd6d51fc3e9e4ac7d1d095bb", "examples/react-transition-group/resources/public/index.html" "33352a72afa9efc5489363ac1567c2f878e1f9f0088c9020ef482615ee817437", "CHANGELOG.md" "73e5fedc3b629539b29f8db6ce52576c0022bdc0c0f2a3c2a312dc0486b864f6", "doc/FAQ/UsingAnEntity.md" "7b5832a6c2a8f164d9dc626a968513066a944946c607c425cb910ee1780353ab", "src/reagent/ratom.clj" "c6c994faf31d40a92e26d73d51f547cf3f814810e4762135a5940133c36a5b13", "doc/UsingSquareBracketsInsteadOfParens.md" "6e4a1fefeb6af9d99cd8c87328c70a163630da17a25604674c5d49bcd35f951a", "examples/simple/resources/public/example.css" "5d677e179d5a6a714159d775627e8bf95afea0c3cf90b97b19abef7ae3e53546", "doc/BatchingAndTiming.md" "5754cbc64827d2724033cc33b2f2cf21899bf006b904a4e61e5104b6edcce347", "examples/geometry/project.clj" "449c95a6bffd2db3b2063a48a99315e38878cc199bc30675aac94ef2d448b647", "examples/react-mde/src/example/core.cljs" "ab40c70661a91e21f8cf3f53163c0e518b62f7cc43560c74d73769e8baa0b1e8", "test/reagenttest/testratomasync.cljs" "28346108ed56453d811e275a6230ac00d6c8889202be2c48e77529f7ec43d1e2", "src/reagent/debug.cljs" "a98281f34d1e0e3adbf77978c8be62a90fd2d490e270c21cef1635f96393acbd", "doc/ManagingState.md" "4e0d4515f802d9b66e88f1abe9cbd51caa6a5bcb25ebc1a78e31b98208558a22", "project.clj" "69e055ab0afcfeeac029df28ebdb21ea49ab7d2fa2716e44727011e8f62b9c50", "deps.edn" "0cc7123fff7ba112cccd1b2fd9d39fc615782603677ce6f71243a23147f5440d", "examples/simple/README.md" "f6d7e11baadfdfcee8f9df24466974390def6e3fe273fa55dfa9ae54876b82d8", "src/reagent/ratom.cljs" "ff9837a2217c502c4d1dbcaef7ab897513919f743ccd971d15bd84ba16f62869", "test/reagenttest/testtrack.cljs" "46165024cc3407db33f49648de41aa38616819d9d0014c349220f40728bcb797", "doc/0.8-upgrade.md" "172f43d03ec7ee51b5cbd92f985c08d89756410f8ea765bc7100c74476380444", "demo/reagentdemo/news/clockpost.cljs" "71d64e635022fe9de17a2acb5a0253b8bbf5707678c02547732ab59d0571658e", "examples/react-transition-group/src/example/core.cljs" "f2f45e4f611ac62903d6d855c0107e3c6c2361e94620e41e84cb40045264e3a3", "test/reagenttest/runtests.cljs" "e4f0c29ad8e77de6522bb25a66a93fe3ac4d0e2e607385c32cd8d6fd17b03f25", "test-environments/shadow-cljs-prod/test.sh" "30e2a901c438b078219e84387bb3549d0c0f733c9db93c191bf308f177e656a9", "test-environments/browser-npm-prod/test.sh" "cbcb5aaf51e1eca260ca0d5f12bd78808c4edd74fc31f30b3af78d458a26b029", "test/reagenttest/performancetest.cljs" "184aa32433e28f2fd14f6780470f6d1dfe38470a0ef8f609a76ebce3ba6b6d8e", "examples/simple/src/simpleexample/core.cljs" "5f21b6247d3f6dc09537388291b52f1961d0e9d004377eb078e3afc2de41b0f5", "examples/react-transition-group/project.clj" "fd785553f792ad3b2f2bd11333c83f94bc87d02468d1608f2fc55afccdbf5758", "src/reagent/core.clj" "ec4a3176accffcb17deac54a1cd858ef79e3c516c11e0e2bfd022a23680dddae", "examples/material-ui/package-lock.json" "69c7b6aa314c3e08a649f85c5e3132a15548c15aed66b2ab1359015f1ef4cf18", "examples/react-sortable-hoc/project.clj" "3a58d15883969c70936683e9d9c122dd716d124a4e53b3bcdcfd334922c53dd0", "test/reagenttest/testwithlet.cljs" "f245c9899834d97eb0fc4db56bc09a556c0247dc2af015f1ea48d7726700afd9", "examples/geometry/devsrc/geometry/dev.cljs" "3ef548b16b70106bb4cb32000cfd01e8232a42608cf3ae8496411e49f02294bb", "doc/FAQ/MyAttributesAreMissing.md" "c59e55d61f38c7c3107798d0dbea4dfa29b6115e12466397d44d0f58bc57b8d1", ".github/issue_template.md" "2419c2962930982b4347122a84f67a79837c5bfc32a22088c5e84a503dd4bb1a", "package-lock.json" "898cf8cb06c6f518308caf4d6e5f0d80a2fed3b0f57aeec4e1336edb7327fd6c", "test-environments/bundle/test.sh" "23d00b8ab43cca16eb43892c97c5b343c676f29cfcac9b55f58b6b894a69f6eb", "doc/FAQ/CljsjsReactProblems.md" "92570dbfe3b911d95ca6114f8a9bc0ebb54b76985576950cdffd56a5b32c0b26", "src/reagent/debug.clj" "7a2edc111f2bb9b9a62f32cc8066fd91aa842d76125e66068f1b5cd5860fa9b0", "shadow-cljs.edn" "d6c119ee5fd3de9d6b04eae89d8a5d613122347387b6875cb3f6a1039dc79ce9"}, :branch "master", :tag {:name "v1.1.0", :commit "d2ed1a7de43913955ec6cc29fae7e4a65eaca8db", :sha "415b4e327bd6f5b11403d9844c7986c544393810"}, :commit "d2ed1a7de43913955ec6cc29fae7e4a65eaca8db", :url "https://github.com/reagent-project/reagent"}, :doc [{:title "Documentation index", :attrs {:cljdoc.doc/source-file "doc/README.md", :cljdoc/markdown "## Tutorials\n\n1. [Using Hiccup to Describe HTML](UsingHiccupToDescribeHTML.md)\n2. [Creating Reagent Components](CreatingReagentComponents.md)\n3. [Using [square brackets] instead of (parentheses)](UsingSquareBracketsInsteadOfParens.md)\n4. [When do components update?](WhenDoComponentsUpdate.md)\n5. [[WIP] Managing State: atoms, cursors, Reactions, and tracking](ManagingState.md)\n6. [Batching and Timing: How Reagent Renders Changes to Application State](BatchingAndTiming.md)\n7. [Interop with React](InteropWithReact.md)\n8. [React Features](ReactFeatures.md) and how to use them in Reagent\n8. [Reagent Compiler](ReagentCompiler.md)\n8. [Controlled Inputs](ControlledInputs.md)\n\nAlso:\n  * [purelyfunctional.tv ](https://purelyfunctional.tv/guide/reagent/) - an excellent, written tutorial\n  * [Reagent Deep Dive Series by Timothy Pratley](http://timothypratley.blogspot.com.au/p/p.html) - a four part series\n  * [Reagent Mysteries series by Paulus Esterhazy](https://presumably.de/) - a four part series\n  * [Props, Children & Component Lifecycle](https://www.martinklepsch.org/posts/props-children-and-component-lifecycle-in-reagent.html) by Martin Klepsch\n  * [Using Stateful JS Components - like D3](https://github.com/Day8/re-frame/blob/master/docs/Using-Stateful-JS-Components.md)  (external link)\n\n## Commercial Videos Series\n\n  * [Learn Reagent Free](https://www.jacekschae.com/learn-reagent-free/tycit?coupon=REAGENT)\n  * [Learn Reagent Pro](https://www.jacekschae.com/learn-reagent-pro/tycit?coupon=REAGENT) (Affiliate link, $30 discount)\n  * [Learn Re-frame](https://www.jacekschae.com/learn-re-frame-pro?coupon=REAGENT) (Affiliate link, early access)\n  * [purelyfunctional.tv ](https://purelyfunctional.tv/guide/reagent/)\n  * [Lambda Island Videos](https://lambdaisland.com/collections/react-reagent-re-frame)\n\n## Frequently Asked Questions\n\n1. [Why isn't my Component re-rendering?](FAQ/ComponentNotRerendering.md)\n1. [How do I use React's \"refs\"](FAQ/UsingRefs.md)\n2. [How can I use an entity like \"nbsp\"?](FAQ/UsingAnEntity.md)\n3. [Why is my attribute (like autoFocus) missing?](FAQ/MyAttributesAreMissing.md)\n4. [How can I use React's dangerouslySetInnerHTML?](FAQ/dangerouslySetInnerHTML.md)\n5. [Reagent doesn't work after updating dependencies](FAQ/CljsjsReactProblems.md)\n5. [How do I force Component re-creation?](FAQ/ForcingComponentRecreation.md)\n5. [Using HTML entities](FAQ/HtmlEntities.md)\n6. [How do I access \"props\" in lifecycle methods?](http://nils-blum-oeste.net/clojurescripts-reagent-using-props-in-lifecycle-hooks/) (external link)\n\n## Examples\n\n- [MaterialUI v1 with working TextField](examples/material-ui.md), React interop example\n- [React-sortable-hoc](../examples/react-sortable-hoc/src/example/core.cljs), React interop example\n\n\n### Want To Add An FAQ?\n\nMany Thanks!! We'd like that:\n1. As a base, just use the structure from one of the existing FAQs files\n2. Give us a PR which includes your new file AND a change to this README so your entry is listed.\n\n#### Misc Docs\n\n - [0.8-upgrade](0.8-upgrade.md)\n - [development](development.md)\n", :cljdoc.doc/type :cljdoc/markdown, :slug "documentation-index", :cljdoc.doc/contributors ("Juho Teperi" "Björn Tegelund" "alex argunov")}} {:title "Tutorials", :attrs {:slug "tutorials"}, :children [{:title "Using Hiccup to Describe HTML", :attrs {:cljdoc.doc/source-file "doc/UsingHiccupToDescribeHTML.md", :cljdoc/markdown "# Using Hiccup to Describe HTML\n\nReagent uses a datastructure known as Hiccup to describe HTML. Hiccup describes HTML elements and user-defined components as a nested ClojureScript vector:\n\n```clojure\n[:div {:class \"parent\"}\n  [:p {:id \"child-one\"} \"I'm first child element.\"]\n  [:p \"I'm the second child element.\"]]\n```\n\nAs described below, reagent provides a number of extensions and conveniences to Hiccup, but the general rules of Hiccup are as follows:\n\n1. The first element is either a keyword or a symbol\n   * If it is a keyword, the element is an HTML element where `(name keyword)` is the tag of the HTML element.\n   * If it is a symbol, reagent will treat the vector as a component, as described in the next section.\n2. If the second element is a map, it represents the attributes to the element. The attribute map may be omitted.\n3. Any additional elements must either be Hiccup vectors representing child nodes or string literals representing child text nodes.\n\n## Special treatment of `nil` child nodes\n\nReagent and React ignore nil nodes, which allow conditional logic in Hiccup forms:\n\n```clojure\n(defn my-div [child?]\n  [:div\n    \"Parent Element\"\n    (when child? [:div \"Child element\"])])\n```\n\nIn this example `(my-div false)` will evaluate to `[:div \"Parent Element\" nil]`, which reagent will simply treat the same as `[:div \"Parent Element\"]`.\n\n## Special interpretation of `style` attribute\n\nThe `:style` attribute can be written a string or as a map. The following two are equivalent:\n\n```clojure\n[:div {:style \"color: red; font-weight: bold\"} \"Alert\"]\n[:div {:style {:color \"red\"\n               :font-weight \"bold\"}}\n      \"Alert\"]\n```\n\nThe map form is the same as [React's style attribute](https://reactjs.org/docs/dom-elements.html#style), except that when using the map form of the style attribute, the keys should be the same as the CSS attribute as shown in the example above (not in camel case as is required JavaScript).\n\n## Special interpretation of `class` attribute\n\nIn JavaScript, `class` is a reserved keyword, so React uses the `className` to specify class attibutes. Reagent just uses `class`.\n\nAs of reagent 0.8.0, the `class` attribute accepts a collection of classes and will remove any nil value:\n\n```clojure\n[:div {:class [\"a-class\" (when active? \"active\") \"b-class\"]}]\n```\n\n## Special notation for id and class\n\nThe id of an element can be indicated with a hash (`#`) after the name of the element.\n\nThis:\n\n```clojure\n[:div#my-id]\n```\n\nis the same as this:\n\n```clojure\n[:div {:id \"my-id\"}]\n```\n\nOne or more classes can be indicated for an element with a `.` and the class-name like this:\n\n```clojure\n[:div.my-class.my-other-class.etc]\n```\n\nwhich is the same as:\n\n```clojure\n[:div {:class [\"my-class\" \"my-other-class\" \"etc\"]}]\n```\n\nSpecial notations for id and classes can be used together. The id must be listed first:\n\n```clojure\n[:div#my-id.my-class.my-other-class]\n```\n\nwhich is the same as:\n\n```clojure\n[:div {:id \"my-id\" :class [\"my-class\" \"my-other-class\"]}]\n```\n\n## Special notation for nested elements\n\nReagent extends standard Hiccup in one way: it is possible to stack elements together by using a `>` character.\n\nThis:\n\n```clojure\n[:div\n  [:p\n    [:b \"Nested Element\"]]]\n```\n\ncan be written as:\n\n```clojure\n[:div>p>b \"Nested Element\"]\n```\n\n## Rendering Hiccup\n\nThe primary entrypoint to the reagent library is `reagent.dom/render`.\n\n```clojure\n(ns example\n  (:require [reagent.dom :as rdom]))\n\n(defn render-simple []\n  (rdom/render [:div [:p \"Hello world!\"]]\n    (.-body js/document)))\n```\n\nThis `render` function expects one of two things:\n\n1. A React Element, which will just be passed to React as is.\n2. A ClojureScript vector (i.e., a Hiccup form).\n\nIf it encounters a ClojureScript vector, it will interpret it as Hiccup. Reagent expects one of two things in the first position of the vector:\n\n1. A keyword like `:div` or `:span`, which it will create using React.createElement\n2. A symbol like `my-component`.\n\nIf it's a symbol, then reagent will evaluate a function by that name. Reagent expects one of three things from this function:\n\n1. A Hiccup vector. Reagent creates a React component with the function as its render method and uses the Hiccup vector for the initial render.\n2. A ClojureScript function. Reagent will then create a React component with this inner function as the render method and will then call the inner function for the initial render.\n3. A React component. Reagent will render this using React.createElement. Note, this could be a result of calling `reagent.core/create-class` or it could be a React component you have imported from a JavaScript library.\n\n", :cljdoc.doc/type :cljdoc/markdown, :slug "using-hiccup-to-describe-html", :cljdoc.doc/contributors ("Juho Teperi" "Nahuel Greco" "Dominic Freeston" "Iyed Bennour" "Mikkel Gravgaard")}} {:title "Creating Reagent Components", :attrs {:cljdoc.doc/source-file "doc/CreatingReagentComponents.md", :cljdoc/markdown "\nIn reagent, the fundamental building block is a `component`.\n\nYour reagent app will typically have many `components` - say, more than 5, but less than 100 - and the overall UI of a reagent app is the stitched-together-output from all of them, each contributing part of the overall HTML, typically in a hierarchical arrangement.\n\nSo they're important and this document describes how to create them.\n\n##### Not An Absolute Introduction\n\nAlthough I stay as basic as possible, this document isn't an introductory tutorial. You should read it *after* \nyou have already digested [The Official Introduction.](http://reagent-project.github.io/)\n\nThis document is useful because it clarifies the basics. It represents an extra bit of learning which might save you from some annoying paper cuts. \n\n##### Contains Lies And Distortions\n\nI care more about providing a useful mental model than bogging down with the full truth. Some white lies and distortions follow.\n\n## The Core Of A Component\n\nAt the core of any `component` is a `render` function.  \n\nA `render` function is the backbone, mandatory part of a `component`.  In fact, as you'll soon see, `components` will often collapse down to be nothing more than a `render` function.\n\nA `render` function turns data into HTML.  Data is supplied via the function parameters, and HTML is the return value.  \n\nData in, HTML out. \n\nMuch of the time, a `render` function will be a `pure function`. If you pass the same data into a `render function`, then it will return the same HTML, and it won't side effect.\n\n*Note*: ultimately, the surrounding reagent/React framework will cause non-pure side-effects because the returned HTML will be spliced into the DOM (mutating global state!), but here, for the moment, all we care about is the pureness of the `render` function itself)\n\n## The Three Ways\n\nThere are three ways to create a `component`. \n\nOrdered by increasing complexity, they are:\n   1. **via a simple render function** - data in as parameters, and it returns HTML.\n   2. **via a function which returns the render function** - the returned function is the render function.\n   3. **via a map of functions, one of which is the render** the rest of the functions are `React lifecycle` methods which allow for some more advanced interventions.\n\n> In all three cases, a `render` function is provided -- that's the backbone. The three creation methods differ only in terms of what they supply over and above a `renderer`.\n\n## Form-1: A Simple Function\n\nIn the simplest case, a `component` collapses down to *only* be a `render` function.  You supply nothing else. \n\nAlthough a simple approach, in my experience, you'll probably use `Form-1` components about 40% of the time, perhaps more.  Simple and useful.\n\nYou just write a regular clojurescript function which takes data as parameters and produces HTML.\n```cljs\n(defn greet\n   [name]                    ;; data coming in is a string\n   [:div \"Hello \" name])     ;; returns Hiccup (HTML)\n```\n\nUntil now, I've talked about `render functions` returning HTML.  That isn't strictly speaking true, of course, as you've seen in the [The Offical Introduction.](http://reagent-project.github.io/)  Instead, renderers always return clojurescript data structures which specify HTML via `Hiccup` format.\n\n`Hiccup` uses vectors to represent HTML elements, and maps to represent an element's attributes.\n\nSo this clojurescript data structure: \n```cljs\n[:div {:style {:background \"blue\"}} \"hello \" \"there\"]\n```\nis simply a clojurescript vector, containing a keyword, map and two strings. But when processed as `hiccup`, this data structure will produce the HTML: \n```\n<div style=\"background:blue;\">hello there</div>\n```\nTo understand more about Hiccup see [this Wiki.](https://github.com/weavejester/hiccup/wiki)\n\n**Rookie mistake**\n\nAt some point, you'll probably try to return sibling HTML elements in a normal cljs vector:\n\n```cljs\n(defn wrong-component\n   [name]              \n   [[:div \"Hello\"] [:div name]])     ;; a vec of 2 [:div] \n```\nThat isn't valid Hiccup and you'll get a slightly baffling error. You'll have to correct this mistake by wrapping the two siblings in a parent [:div]: \n\n```cljs\n(defn right-component\n   [name]              \n   [:div \n     [:div \"Hello\"] \n     [:div name]])     ;; [:div] containing two nested [:divs]\n```\n\nAlternatively, you could return a [React Fragment](https://reactjs.org/docs/fragments.html). In reagent, a React Fragment is created using the `:<>` Hiccup form.\n\n```cljs\n(defn right-component\n   [name]\n   [:<>\n     [:div \"Hello\"]\n     [:div name]])\n```\n\nReferring to the example in [React's documentation](https://reactjs.org/docs/fragments.html), the `Columns` component could be defined in reagent as:\n\n```cljs\n(defn columns\n  []\n  [:<>\n    [:td \"Hello\"]\n    [:td \"World\"]]\n```\n\n## Form-2:  A Function Returning A Function\n\nNow, let's take one step up in complexity.  Sometimes, a component requires:\n  - some setup; or\n  - some local state; and of course\n  - a renderer\n\nThe first two are optional, the last is not.\n\n`Form-2` components are written as an `outer` function which returns an `inner` render.\n\nThis example is taken from the tutorial:\n```cljs\n(defn timer-component []\n  (let [seconds-elapsed (reagent/atom 0)]     ;; setup, and local state\n    (fn []        ;; inner, render function is returned\n      (js/setTimeout #(swap! seconds-elapsed inc) 1000)\n      [:div \"Seconds Elapsed: \" @seconds-elapsed])))\n```\n\nHere `timer-component` is the outer function, and it returns an inner, anonymous render function which closes over the initialised, local state `seconds-elapsed`.\n\nAs before, the job of the render function is to turn data into HTML. That's the backbone. Its just that `Form-2` allows your renderer to close over some state created and initialised by the outer. \n\nIn my experience, you'll use `Form-2` `components` at least 50% of the time. \n\nLet's be quite clear what is going on here:\n  - `timer-component` is **called once** per component instance (and will create the state for that instance) \n  - the render function it returns will potentially be called **many, many times**. In fact, it will be called each time Reagent detects a possible difference in that `component`'s inputs.\n\n**Rookie mistake**\n\nWhen starting out, everyone makes this mistake with the `Form-2` construct: they forget to repeat the parameters in the inner, anonymous render function. \n\n```cljs\n(defn outer \n  [a b c]            ;; <--- parameters\n  ;;  ....\n  (fn [a b c]        ;; <--- forgetting to repeat them, is a rookie mistake\n    [:div\n      (str a b c)]))\n```\n\nSo the rookie mistake is to forget to put in the `[a b c]` parameters on the inner render function. \n\nRemember, `outer` is called once _per component instance_.  Each time, the parameters to `outer` will hold the initial parameter values.  The renderer on the other hand, will be called by Reagent many times and, each time, potentially with alternative parameter values, but unless you repeat the parameters on the renderer it will close over those initial values in `outer`. As a result, the component renderer will stubbornly only ever render the original parameter values, not the updated ones, which can be baffling for a beginner.\n\n\n## Form-3: A Class With Life Cycle Methods\n\nNow, for the final step in complexity.\n\nIn my experience, you'll probably use `Form-3` `components` less than 1% of the time, perhaps only when you want to use a js library like D3 or introduce some hand-crafted optimisations. Maybe.  While you'll ignore `Form-3` components most of the time, when you do need them, you need them bad. So pay attention, because they'll save your bacon one day. \n\nWhile the critical part of a component is its render function, sometimes we need to perform actions at various critical moments in a component's lifetime, like when it is first created, or when its about to be destroyed (removed from the DOM), or when its about to be updated, etc.\n\nWith `Form-3` components, you can nominate `lifecycle methods`. reagent provides a very thin layer over React's own `lifecycle methods`. So, before going on, [read all about React's lifecycle methods.](http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods).  \n\nBecause React's lifecycle methods are object-oriented, they presume the ability to access `this` to obtain the current state of the component.  Accordingly, the signatures of the corresponding Reagent lifecycle methods all take a reference to the reagent component as the first argument.  This reference can be used with `r/props`, `r/children`, and `r/argv` to obtain the current props/arguments.  There are some unexpected details with these functions described below.  You may also find `r/dom-node` helpful, as a common use of form-3 components is to draw into a `canvas` element, and you will need access to the underlying DOM element to do so.\n\nA `Form-3` component definition looks like this:\n```cljs\n(defn my-component\n  [x y z]  \n  (let [some (local but shared state)      ;; <-- closed over by lifecycle fns\n        can  (go here)]   \n     (reagent/create-class                 ;; <-- expects a map of functions \n       {:display-name  \"my-component\"      ;; for more helpful warnings & errors\n\n        :component-did-mount               ;; the name of a lifecycle function\n        (fn [this] \n          (println \"component-did-mount\")) ;; your implementation\n         \n        :component-did-update              ;; the name of a lifecycle function\n        (fn [this old-argv]                ;; reagent provides you the entire \"argv\", not just the \"props\"\n          (let [new-argv (rest (reagent/argv this))]\n            (do-something new-argv old-argv)))\n      \n        ;; other lifecycle funcs can go in here\n     \n\n        :reagent-render        ;; Note:  is not :render\n         (fn [x y z]           ;; remember to repeat parameters\n            [:div (str x \" \" y \" \" z)])})))\n\n(reagent/render\n    [my-component 1 2 3]         ;; pass in x y z\n    (.-body js/document))\n\n;; or as a child in a larger Reagent component\n\n(defn homepage []\n  [:div\n   [:h1 \"Welcome\"]\n   [my-component 1 2 3]]) ;; Be sure to put the Reagent class in square brackets to force it to render!\n```\n\nNote the `old-argv` above in the signature for `component-did-update`.  Many of these Reagent lifecycle method analogs take `prev-argv` or `old-argv` (see the docstring for `reagent/create-class` for a full listing).  These `argv` arguments include the component constructor as the first argument, which should generally be ignored.  This is the same format returned by `(reagent/argv this)`.\n\nAlternately, you can use `(reagent/props this)` and `(reagent/props children)`, but, conceptually, these don't map as clearly to the `argv` concept.  Specifically, the arguments to your render function are actually passed as children (not props) to the underlying React component, **unless the first argument is a map.**   If the first argument is a map, then that map is passed as props, and the rest of the arguments are passed as children.  Using `props` and `children` may read a bit cleaner, but you do need to pay attention to whether you're passing a props map or not.\n\nFinally, note that some React lifecycle methods take `prevState` and `nextState`.  Because Reagent provides its own state management system, there is no access to these parameters in the lifecycle methods.\n\nIt is possible to create `Form-3` `components` using `with-meta`.  However, `with-meta` is a bit clumsy and has no advantages over the above method, but be aware that an alternative way exists to achieve the same outcome.\n\n**Rookie mistake**\n\nIn the code sample above, notice that the renderer function is identified via an odd keyword in the map given to `reagent/create-class`. It's called `:reagent-render` rather than the shorter, more obvious `:render`. \n\nIts a trap to mistakenly use `:render` because you won't get any errors, **except** the function you supply will only ever be called with one parameter, and it won't be the one you expect. [Some details here](https://github.com/reagent-project/reagent/issues/47#issuecomment-61056999).\n\n**Rookie mistake**\n\nWhile you can override `component-should-update` to achieve some performance improvements, you probably shouldn't unless you really, really know what you are doing. Resist the urge. Your current performance is just fine. :-)\n\n**Rookie mistake**\n\nLeaving out the `:display-name` entry.  If you leave it out, Reagent and React have no way of knowing the name of the component causing a problem. As a result, the warnings and errors they generate won't be as informative. \n\n*****************\n\n## Final Note\n\nAbove I used the terms `Form-1`, `Form-2` and `Form-3`, but there's actually only one kind of component. It is just that there's **3 different ways to create a component**. \n\nAt the end of the day, no matter how it is created, a component will end up with a render function and some life-cycle methods.  A component created via `Form-1` has the same basic structure as one created via `Form-3` because underneath they are all [just React components](https://betweentwoparens.com/what-the-reagent-component).\n\n## Appendix A - Lifting the Lid Slightly\n\nHere's some further notes about Reagent's mechanics: \n  1. When you provide a function as the first element of a hiccup vector `[my-func 1 2 3]`, Reagent will say \"hey I have been given a render function\".  That function might be `Form-1` or `Form-2`, but it doesn't know at that point. It just sees a function. \n  2. A render function by itself is not enough to make a React Component.  So, Reagent takes this render function and \"merges\" it with default lifecycle functions to form a React component.  (`Form-3`, of course, allows you to supply your own lifecycle functions)\n  3. Some time later, when Reagent **first** wants to render this component, it will, unsurprisingly, call the render function which you supplied (`my-func` in the snippet above).  It will pass in the \"props\" (parameters) supplied by the rendering parent (`1 2 3` in the snippet above). \n  4. If this first call to the render function returns hiccup (a vector of stuff):\n     - Reagent will just interpret it. So this is what happens in the case of a `Form-1` function.  \n     - If, however, this render function returns another function - ie. it is a `Form-2` outer function returning the inner function - then Reagent knows to replace the Component's render function with the newly returned inner function forever thereafter. So the outer will have been called once but, from that point forward, the inner function will be used for all further rendering. In fact,  Reagent will instantly call the inner function after the outer returns it, because Reagent wants a first rendering (hiccup) for the component. \n  5. So, in the case of `Form-2`, the outer function is called once and once only (with initial props/parameters), and the inner is called at least once (with initial props/parameters), but probably many, many times thereafter. Both will be called with the same arrangement of props/parameters - although the inner render function will see different values in those props/parameters, over time. \n\n## Appendix B - with-let macro\n\nThe `with-let` macro looks just like `let` – but the bindings **only execute once**, and it takes an optional `finally` clause, that runs when the component is no longer rendered. This can be particularly useful because it can prevent the need for a form-2 component in many instances (like creating a local reagent atom in your component).\n\nFor example: here's a component that sets up an event listener for mouse moves, and stops listening when the component is removed.\n\n```clojure\n(defn mouse-pos-comp []\n  (r/with-let [pointer (r/atom nil)\n               handler #(swap! pointer assoc\n                               :x (.-pageX %)\n                               :y (.-pageY %))\n               _ (.addEventListener js/document \"mousemove\" handler)]\n    [:div\n     \"Pointer moved to: \"\n     (str @pointer)]\n    (finally\n      (.removeEventListener js/document \"mousemove\" handler))))\n```\n\nThe same thing could of course be achieved with React lifecycle methods, but that would be a lot more verbose.\n\n`with-let` can also be combined with `track` (and other Reactive contexts). For example, the component above could be written as:\n\n```clojure\n(defn mouse-pos []\n  (r/with-let [pointer (r/atom nil)\n               handler #(swap! pointer assoc\n                               :x (.-pageX %)\n                               :y (.-pageY %))\n               _ (.addEventListener js/document \"mousemove\" handler)]\n    @pointer\n    (finally\n      (.removeEventListener js/document \"mousemove\" handler))))\n\n(defn tracked-pos []\n  [:div\n   \"Pointer moved to: \"\n   (str @(r/track mouse-pos))])\n```\n\nThe `finally` clause will run when mouse-pos is no longer tracked anywhere, i.e in this case when tracked-pos is unmounted.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "creating-reagent-components", :cljdoc.doc/contributors ("Juho Teperi" "Justin Lee" "Dosbol" "Michael Watkins" "tkjone" "Jason" "Alan Thompson")}} {:title "Using [square brackets] instead of (parentheses)", :attrs {:cljdoc.doc/source-file "doc/UsingSquareBracketsInsteadOfParens.md", :cljdoc/markdown "This is a quick tutorial regarding the use of `()` and  `[]` in Reagent renderers.\n\nReagent is a terrific library.  You get going fast and your intuitions about how things should work seem to largely match how stuff actually does work.  It is all a bit magic and easy. \n\nBut, eventually, you'll want to understand how that magic happens. Otherwise ... one day, \nin the peace of a shower, or on that serene bike ride to work, your eyes will flick to \nthe left and you'll wonder \"wait, how **exactly** has this EVER worked for me all this time?\".\nWhich can be followed by other doubts: \"if I don't understand this, what else don't I know?\",\nwhich can lead to \"do I really understand ANYTHING?\".  And, before you know it, you'll be\nover at your parent's house demanding to know if you were adopted.\n\nBest to nip these slippery slopes in the bud (and, equally, to never use mixed metaphors).  Read on ...\n\n## Components\n\nIn an earlier tutorial [Creating Reagent Components](CreatingReagentComponents.md), we saw that the centerpiece of a Reagent/React component is a **renderer** function. Optionally, a Component might have other lifecycle functions, but a renderer function is central and mandatory.\n\nWe also saw that Reagent render functions turn data into hiccup:   `data -> hiccup`\n\n## Meet greet\n\nHere's an example Component:\n```clj\n(defn greet\n  [name]\n  [:div  \"Hello \" name])\n```\n\nNo, wait, what? That's not a Component, that's a function.\n\nYes, indeed it is. And, right there, we have the nub of the issue. \n\nIt is only when `greet` is **used in a particular way**, that it is \"promoted\" to become the renderer for a Reagent Component. Unless you are paying attention, you might not even realise when that magic is happening, and not happening. \n\nRight. So given **use is king**, let's look at two forms of it ...\n\n## Using Greet Via ()\n\nIf you **use** `greet` in a function call via `()`, it returns a vector with 3 elements: \n```cljs\n(greet \"You\")\n;; => [:div  \"Hello \" \"You\"]   ;; a vector of a keyword and two strings\n\n(first (greet \"You\"))\n;; => :div\n\n(second (greet \"You\"))\n;; => \"Hello\"\n```\n\nSo, simply calling such function certainly doesn't magically create a Reagent Component. It just returns a vector.\n\nHmmm. How about we call `greet` within another function: \n```clj\n(defn greet-family-round       ;; round on the end because using round brackets\n  [member1 member2 member3]\n  [:div\n    (greet member1)    ;; return value put into the vector\n    (greet member2)    ;; and again \n    (greet member3)])  ;; and again\n```\n\n`greet-family-round` returns a 4 element vector. And what's in that vector if we call it like this?\n```cljs\n(greet-family-round \"Mum\" \"Dad\" \"Aunt Edith\")\n```\n\nBecause `(greet \"Mum\")` returns `[:div  \"Hello \" \"Mum\"]`, that's the 2nd element in the vector. And so on.\n```cljs\n [:div\n    [:div  \"Hello \" \"Mum\"]          ;; <-- (greet \"Mum\") \n    [:div  \"Hello \" \"Dad\"]          ;; <-- (greet \"Dad\") \n    [:div  \"Hello \" \"Aunt Edith\"]]  ;; <-- (greet \"Aunt Edith\") \n```\n\n## Using Greet Via []\n\nLet's keep `greet` the same, but change the way it is **used**: \n```clj\n(defn greet-family-square\n  [member1 member2 member3]\n  [:div\n    [greet member1]      ;; not using ()\n    [greet member2]     \n    [greet member3]])  \n```\n\nLet's be crystal clear:  `[greet member1]` is a two element vector, just like `[1 2]`. \n\nAnd, what would this call return?\n```cljs\n(greet-family-square \"Mum\" \"Dad\" \"Aunt Edith\")  \n```\n\nAnswer:\n```cljs\n [:div\n    [greet \"Mum\"]         \n    [greet \"Dad\"]\n    [greet \"Aunt Edith\"]]\n```\n\nSo, `greet` is not called inside of `greet-family-square`. Instead, it is placed into a vector. \n\n## The Difference Between () and []\n\nHere is the hiccup returned by `greet-family-round`.\n```cljs\n [:div\n    [:div  \"Hello \" \"Mum\"]          ;; the return value of greet put in here\n    [:div  \"Hello \" \"Dad\"]          ;; and again \n    [:div  \"Hello \" \"Aunt Edith\"]]  ;; and again\n```\nYou'll notice this hiccup contains no references to `greet`. Only the (hiccup) values returned by calls to `greet`.\n\nOn the other hand, there **are** references to `greet` in the hiccup returned by `greet-family-square`\n```cljs\n [:div\n    [greet \"Mum\"]         \n    [greet \"Dad\"]\n    [greet \"Aunt Edith\"]]\n```\n\n## The Interpretation Of Hiccup\n\nAfter renderers return hiccup, Reagent interprets it. \n\nAs it does this interpretation, if Reagent sees a vector where the first element is a function, for example `[greet \"Mum\"]`, it interprets that function as a renderer **and it builds a React component around that renderer**. \n\nLet's pause and remember that a renderer function is the key, mandatory, central part of a Component. Defaults can be supplied for the other React lifecycle functions, like `component-should-update`, but a renderer **must** be supplied.\n\nSo Reagent recognises `greet` as a candidate renderer function and, if it is found in the right place (1st element of a vector), Reagent will mix it with other default lifecycle functions to form a full React/Reagent Component. It gives `greet` a, er, promotion.\n\nThe other elements of the vector, after `greet`, are interpreted as parameters to the renderer - in React terms, `props`. \n\n## Which and Why?\n\nSo, which variation of `greet-family` (`square` vs `round`) should I choose, and why?\n\nThe answer to \"which?\" is easy: you almost certainly want the `square` version.  \"why?\" takes more explanation ... \n\nFirst off, let's acknowledge that both variations will ultimately produce the same DOM, so in that respect they are the same. \n\nDespite this identical outcome, they differ in one significant way: \n\n  1. the `square` version will create each `greet` child as a distinct React component, each with its own React lifecycle, **allowing them to re-render independently of siblings**. \n  2. The `round` version causes the `greet` hiccup for all children to be incorporated  into the hiccup returned by the parent, forming one large data structure, parent and children all in together. So, each time the parent re-renders, all the `greet` children are effectively re-rendered too. React must then work out what, in this tree, has changed.\n\nAs a result, **the `square` version will be more efficient at \"re-render time\"**.  Only the DOM which needs to be re-rendered will be done. At our toy scale in this tutorial it hardly matters but, if `greet` was a more substantial child component, this gain in efficiency could be significant.\n\nArmed with a bit more knowledge, we'll revisit this subject at the end of the next Tutorial.\n\n## A Further, Significant \"Why\"\n\nIn the examples above, we've explored [Form-1 components](CreatingReagentComponents.md#form-1-a-simple-function)  - the simplest kind - and we've seen we have some choice regarding use of `()` or `[]`. Eventually, I claim that `[]` is much preferred, but you can get away with `()`, up to a point. \n\n**But** ... the moment you start using Form-2 or Form-3 components, you absolutely must be using `[]`.  No choice.  Using `()` just won't work at all. Given the explanations above, I'm hoping you can work out why. Either that or just shrug and use `[]` forever more. \n\n### Appendix #1\n\n`hiccup` can be created like any normal cljs data structure. You don't have to use literals.\n\nOur version of `greet-family-round` from above returns something of a 4 element vector literal:\n```clj\n(defn greet-family-round\n  [member1 member2 member3]\n  [:div\n    (greet member1)    \n    (greet member2)  \n    (greet member3)]) \n```\n\nHere's a rewrite in which the hiccup is less literal and more generated: \n```clj\n(defn greet-family-round-2       ;; a re-write \n  [& members]\n  (into [:div] (map greet members)))\n```\n\nWhen called with 3 parameters, both versions of this function return the same hiccup:\n```clj\n(= (greet-family-round   \"Mum\" \"Dad\" \"Aunt Edith\") \n   (greet-family-round-2 \"Mum\" \"Dad\" \"Aunt Edith\"))\n;; => true\n```\n\n### Appendix #2\n\nWhen interpreting hiccup, Reagent regards vectors as special, and it has some demands about their 1st element.\n\nIn Reagent hiccup, the 1st element of a vector **must always** be something it can use to build a Component. \n\nReagent can use `greet` to build a Component, so that works.  So does `:div` because Reagent knows what Component you mean. And there are a few other options.\n\nSo this is okay:   `[greet ...]`  and so is this  `[:div ...]`\n\n**But** if your hiccup contains a vector like `[1 2 3]`, then you'll get an error because Reagent can't use `1` to build a Component. \n\nSo this code has a problem:\n```clj \n(defn greet-v\n   [v]\n   (into [:div] (map greet v)))\n\n(defn greet-family\n   []\n   [greet-v [\"Mum\" \"Dad\" \"Aunt Edith\"]])  ;; <-- error here\n```\n\nNotice the vector `[\"Mum\" \"Dad\" \"Aunt Edith\"]` in the hiccup.  Reagent will try to build a Component using \"Mum\" (1st element in a vector) and, when that doesn't work, it will report an error.  \n\n## Next Step\n\nWe've now seen how we can use functions and `[]` to create Components. In the [next tutorial](WhenDoComponentsUpdate.md), we'll understand how and when these Components update. \n", :cljdoc.doc/type :cljdoc/markdown, :slug "using-square-brackets-instead-of-parentheses-", :cljdoc.doc/contributors ("Oleg" "Mohit Thatte" "Juho Teperi")}} {:title "When do components update?", :attrs {:cljdoc.doc/source-file "doc/WhenDoComponentsUpdate.md", :cljdoc/markdown "In this, more intermediate, Reagent tutorial, we delve into the question: when do Components re-render and why?  \n\n## Components Are Reactive\n\nReagent Components are \"reactive\" in the following way:\n  - each Component has a render function \n  - this render function turns `input data` into `hiccup`  (HTML)\n  - render functions are **rerun** when their `input data` changes, producing new hiccup\n  - that new hiccup is \"interpreted\" by Reagent and ultimately results in new HTML\n\nIt is this whole **re-running** the renderer function thing that makes a Component reactive. It \"reacts\" to changes in its \"inputs\", producing a new output.\n\nThis page is about understanding how and why these reactions happen. \n\n### Reactive To What?\n\nWe start by looking at the `inputs` to the process.  What things, when they change value, trigger a re-run of a Component's renderer?\n\nShort answer is that there's two kinds of `input data`: \n  - `props`\n  - `ratoms`  \n\nAs we'll soon see, these two kinds of input are not quite equal. There are differences in the way they trigger.\n\n## 1. Props\n\nThe first of these `inputs` is called `props`.\n\nConsider this example Component:\n```clj\n(defn greet\n  [name]          ;; name is a string            \n  [:div \"Hello \" name])\n```\n\n`name` is a `prop` (short for property).  In this example, it is a string value.  In our clojurescript/Reagent world, it takes the form of a parameter to the Component renderer, `greet`. \n\nEach time the value of `name` changes over time, `greet` will rerender. \n\nWait, what? How exactly can the value of `name` change over time - isn't it just a parameter? Don't parameters only ever get one value, when the function is called?\n\nWell, you'll remember from previous tutorials that `greet` is going to be \"promoted\" to be the render function of a Component. As a Component renderer, it will get called at least once, but probably many, many times. So there will be the opportunity for `name` to have a different value each time `greet` is called and, in that sense, it is a value which can change over time.\n\nTo understand further, imagine we had a parent Component, which uses `greet`:\n```clj\n(defn greet-family\n  [] \n  [:div \n    [greet \"Dad\"]\n    [greet (str \"Bro-\" (rand-int 10))]])\n```\n\nWhen Reagent interprets the hiccup returned by `greet-family`, it will create 3 further components:  \n\n  - a `:div` component, with two `greet` children\n  - the 1st `greet` child will always be given the `name` \"Dad\". Always the same prop\n  - the 2nd `greet` child will likely have a different value for `name` each time that `greet-family` renders. Perhaps \"Bro-1\" one time and \"Bro-5\" the next. Only 1 time in 10 will it be the same as last time.\n\nAfter a Component's renderer runs and produces hiccup, Reagent interprets it. When it processes the output of `greet-family`,  it will check to see if these 3 rerendered Components themselves need rerendering.  The test Reagent uses is a simple one: for each Component, are the newly supplied `props` different to those supplied in the last render. Have they \"changed\"? \n\nIf the `props` are different, then that Component's render will be called to create new hiccup.  But if the `props` to that Component are the same as last time, then no need to rerender it. \n\nObviously, the `[greet \"Dad\"]` component is rendered by `greet-family` the same way each time, and will get the same `props` every time and, so, it will not need re-rendering.  It will render once, at the beginning, but never again, no matter how many times its parent `greet-family` is rerendered. \n\nOn the other hand, `[greet (str \"Bro-\" (rand-int 10))]` will often render a different `name` prop. So, if `greet-family` rerenders, then that child component will often re-render too ... although about 1 time in 10 the prop this time will be the same as last time, and Reagent will determine that it doesn't need to be rerendered.\n\nWhich means we can now answer the question posed above - how can the value of `name` change over time for a given `greet` component?  Answer: when the parent Component re-renders, and supplies a new value as the `prop`.  \n\n`props` flow from the parent. **A Component can't get new `props` unless its parent rerenders.** \n\n## 2. Ratoms\n\nLet's now discuss the 2nd form of `input data` to a Component.  \n\nThis example is a bit contrived, but bear with me ...\n```clj\n(def name  (reagent.ratom/atom \"Bear\"))\n\n(defn ask-for-forgiveness\n  []           ;; <--- no props     \n  [:div \"Please \" @name \" with me\"])   ;; notice that @\n```\n\nWe can see that `ask-for-forgiveness` will return the hiccup  `[:div \"Please \" \"Bear\" \" with me\"]`\n\nWell, initially anyway, because initially `name` contains the string value \"Bear\".\n\nData is flowing into the render function via this `name` ratom.  Reagent will detect that this renderer has a ratom input, and it will watch that ratom for changes.\n\nIf I suddenly got all scientific, and did this `(reset! name \"Ursidae\")`, Reagent would detect the change in `name`, and it would re-run any Component renderer which is dependent upon it.  That means `ask-for-forgiveness` is re-run, producing the new hiccup `[:div \"Please \" \"Ursidae\" \" with me\"]`.\n\nJust so we're clear: a \"data input\" changes (the value in a ratom) and, then, the renderer is rerun to produce new hiccup.  The Component is reactive to the ratoms it derefs.\n\n## A Combination\n\nSo that was the basics.  \n\nLet's now look at how these things can combine. We're going to consider a case involving two child components, and a parent. \n\nChild Component 1:\n```clj\n(defn greet-number\n  \"I say hello to an integer\"\n  [num]                             ;; an integer\n  [:div (str \"Hello #\" num)])       ;; [:div \"Hello #1\"]\n```\n\nChild component 2: \n```clj\n(defn more-button\n  \"I'm a button labelled 'More' which increments counter when clicked\"\n  [counter]                                ;; a ratom\n  [:div  {:class \"button-class\"\n          :on-click  #(swap! counter inc)} ;; increment the int value in counter\n   \"More\"])    \n```\n\nAnd, finally, a Form-2 parent Component which uses these two child components:\n```clj\n(defn parent\n  [] \n  (let [counter  (reagent.ratom/atom 1)]    ;; the render closes over this state\n    (fn  parent-renderer \n      []\n      [:div \n        [greet-number @counter]      ;; notice the @. The prop is an int\n        [more-button counter]])))    ;; no @ on counter\n```\n\nWith this setup, answer this question: what rerendering happens each time the `more-button` gets clicked and `counter` gets incremented? \n\nDon't read on. Test yourself. Spend 30 seconds working it out.\n\nAnswer:\n  1. Reagent will notice that `counter` has changed and that is an `input ratom` to `parent-renderer`, and it will rerun that renderer. \n  2. Reagent will interpret the hiccup returned by `parent-renderer`, and it will determine that a new (integer) prop has been supplied in the `[greet-number @counter]` Component, and it will then rerender that component too. \n\nWait. Is that it?  Why doesn't the `[more-button counter]` component rerender too?  After all, its `prop` `counter` has changed???\n\nNo, I promise it won't rerender. But why not?  The answer is a bit subtle.\n\nYou see, `counter` itself hasn't changed. It is still the same ratom it was before. The value **in** `counter` has been incremented, but `counter` itself is still the same ratom.  So from Reagent's point of view `[more-button counter]` involves the same `prop` as \"last time\" and it concludes that there's no need for a rerender of that component. \n\nHad `more-button` dereferenced the `counter` ratom THEN the change in `counter` should have triggered a rerender of `more-button`.  But if you look at `more-button` you'll see no `@counter`. There is no dereference.\n\nIf you truly understand this example, then you've gone a long way to officially getting it. \n\n## Different \n\nAlthough they are both ways to trigger a reactive re-render, the two kinds of `inputs` have different properties: \n  1. the definition of \"changed\" applied\n  2. treatment of lifecycle functions\n\n## Changed?\n\nTill now, I've said a renderer will be re-run when an input value \"changed\".  But I've been carefully avoiding any definition of \"changed\".\n\nYou see, there's at least two definitions: `=` and `identical?`\n\n```\n(def x1  {:a 42  :b 45})    ;; at time 1, x has this value\n(def x2  {:a 42  :b 45})    ;; at time 2, x has this value\n\n(= x1 x2)                   ;; is x the same, or has it changed? \n;; =>  true                 ;; answer: no change\n\n(identical? x1 x2)          ;; is x the same, or has it changed?\n;; => false                 ;; answer: different\n```\n\nSo we can see different answers to the question \"has x changed?\" for the same values, depending on the function we use.\n\nFor `props`,  `=` is used to determine if a new value have changed with regard to an old value. \n\nFor ratoms, `identical?` is used (on the value inside the ratom) to determine if a new value has changed with regard to an old value. \n\nSo, it is only when values are deemed to have \"changed\", that a re-run is triggered, but the inputs use different definitions of \"changed\".  This can be confusing. \n\nThe `identical?` version is very fast. It is just a single reference check.\n\nThe `=` version is more accurate, more intuitive, but potentially more expensive. Although, as I'm writing this I notice that `=` uses `identical?` [when it can](https://github.com/clojure/clojurescript/blob/1b7390450243693d0b24e8d3ad085c6da4eef204/src/main/cljs/cljs/core.cljs#L1108-L1124).\n\n**Update:**\n\n> As of Reagent 0.6.0, ratoms use `=` (instead of `identical?`) is to determine if a new value is different to an old value. So, `ratoms` and `props` now have the same `changed?` semantics. \n\n### Efficient Re-renders\n\nIt's only via rerenders that a UI will change.  So re-rendering is pretty essential.  \n\nOn the other hand, unnecessary re-rendering should be avoided.  In the worst case, it could lead to performance problems.  By unnecessary rendering, I mean rerenders which result in unchanged HTML. That's a whole lot of work for no reason.\n\nSo this notion of \"changed\" is pretty important.  It controls if we are doing unnecessary, performance-sapping re-rendering work. \n\n### Lifecycle Functions\n\nWhen `props` change, the entire underlying React machinery is engaged. Reagent Components can have lifecycle methods like `component-did-update` and these functions will get called, just as they would if you were dealing with a React Component. \n\nBut ... when the re-render occurs because an input ratom changed, **Lifecycle functions are not run**.  So, for example, `component-did-update` will not be called on the Component. \n\nCareful of this one. It trips people up.\n\n\n## Appendix 1\n\nIn the previous Tutorial, we looked at the difference between `()` and `[]`. \n\nTowards the end, I claimed that using `[]` was more efficient at \"re-render time\".  Hopefully, after the tutorial above, our knowledge is a bit deeper and we can now better appreciate the truth in this claim. \n\nRemember this code from the previous tutorial:\n```clj\n(defn greet-family-square\n  [member1 member2 member3]\n  [:div\n    [greet member1]     ;; using [] not ()\n    [greet member2]     \n    [greet member3]])  \n```\n\nNow, imagine it used like this:\n```clj\n ;; the 3rd member of the family to greet\n(def extra (reagent.core/atom \"Aunt Edith\"))  \n\n(defn top-level-component\n    []\n    [greet-family-square  \"Mum\" \"Dad\" @extra])\n\n(reagent.core/render [top-level-component] (.-body js/document)))\n```\n\nThe first time the page is rendered, the DOM created will greet three cherished people.  All good.  At this point, the `round` and `square` versions of `greet-family` would be equally good at getting the initial DOM into our browser.\n\nBut then, out of nowhere, comes information that our rich and eccentric Uncle John is rewriting his Last Will And Testament, and we need a fast, realtime change in our page. Luckily we have a repl handy, and we type `(reset! extra \"Uncle John\")`.  We've changed that `extra` r/atom which holds the 3rd cherished family member - sorry \"Aunt Edith\", you're out. \n\nWhat happens next?\n\n1. Reagent will recognize that a `top-level-component` component relies on `extra` which has changed.  \n2. So it will rerender that component. In the hiccup produced (by the rerender), it will see that `greet-family-square` has a new 3rd prop. And, by that, I mean that the value for the 3rd prop (\"Uncle John\") will not compare `=` to the value last rendered (\"Aunt Edith\"). \n3. So Reagent will trigger a rerender of `greet-family-square` with the new props (\"Mum\" \"Dad\" and \"Uncle John\")\n4. In the hiccup produced by this rerender, Reagent will notice that the first two `greet` components have the same prop as that last rendered (\"Mum\" and \"Dad\") but that the 3rd `greet` component has a new prop value (\"Uncle John\"). \n5. So it will NOT rerender the first two `greet`, but the renderer for the 3rd will be rereun. \n \nAs you can see, only the right parts of the tree are re-rendered.  Nothing unnecessary is done.\n\nIn the alternative `greet-family-round` version we looked at, the one which used `()` instead of `[]`, that efficiency is not possible. \n\nA re-render of `greet-family-round` always triggers three calls to `greet`, no matter what, accumulating a large amount of hiccup for `greet-family-round` to return.  It would then be left to React to diff all this new DOM with existing DOM and for it to work out that, in fact, parts of the tree (the first two greet parts) remain the same, and should be ignored. Which is a whole lot of unnecessary work!\n\nWhen we use `[]`, we get independent React Components which will only be re-rendered if their `props` change (or ratoms change). More efficient, more minimal re-renderings.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "when-do-components-update-", :cljdoc.doc/contributors ("Juho Teperi" "Alan Thompson" "Dosbol")}} {:title "[WIP] Managing State: atoms, cursors, Reactions, and tracking", :attrs {:cljdoc.doc/source-file "doc/ManagingState.md", :cljdoc/markdown "# Managing state: atoms, cursors, Reactions, and tracking\n\nAlthough it is possible to update reagent components by remounting the entire component tree with `reagent.dom/render`, Reagent comes with a sophisticated state management library based on `reagent.core/atom`, which allows components to track application state and update only when needed. Reagent also provides cursors, which are like ratoms but can be constructed from portions of one or more other ratoms to limit or expand which ratoms a component watches. Finally, Reagent provides a set of tracking primitives called reactions and a set of utility functions to build more customized state management.\n\n**TODO is this right?**\n\n## Intro to atoms\n\nReagent provides an implementation of atom that you can create with `reagent/atom` and use just like a normal Clojure atom, which are often referred to as \"ratoms\" to distinguish from normal atoms. Reagent tracks any dereferences to ratoms made during a component's render function.\n\n```clojure\n(ns example\n  (:require [reagent.core :as r]))\n\n(def click-count (r/atom 0))\n\n(defn counting-component []\n  [:div\n   \"The atom \" [:code \"click-count\"] \" has value: \"\n   @click-count \". \"\n   [:input {:type \"button\" :value \"Click me!\"\n            :on-click #(swap! click-count inc)}]])\n```\n\n### Mutating a ratom\n\nYou manipulate using the standard `reset!` and `swap!` functions.\n\n```clojure\n(reset! state-atom {:counter 0})\n```\n\n```clojure\n(swap! state-atom assoc :counter 15)\n```\n\n### Dereferencing a ratom\n\nYou access the atom using `deref` or the shorthand `@`.\n\n```clojure\n(:counter (deref state-atom))\n(:counter @state-atom)\n```\n\n### The effect of dereferencing a ratom\n\n* A dereference to the ratom during its render function will cause that component to re-render whenever any part of that ratom is updated. (See the section below on cursors to get finer control over update behavior.)\n* Dereferencing a ratom in a callback or event handler after the render function has run will not make the component react to any changes to the ratom (though of course any _changes_ to the ratom made in an event handler will make any watching components re-render).\n\n### rswap!\n\n`rswap!` works like standard `swap!` except that it\n\n* always returns `nil`\n* allows recursive applications of `rswap!` on the same atom\n\nThat makes `rswap!` especially suited for event handling.\n\nHere’s an example that uses event handling with `rswap!`:\n\n```clojure\n(defn event-handler [state [event-name id value]]\n  (case event-name\n    :set-name   (assoc-in state [:people id :name] value)\n    :add-person (let [new-key (->> state :people keys (apply max) inc)]\n              (assoc-in state [:people new-key] {:name \"\"}))\n    state))\n\n(defn emit [e]\n  ;; (js/console.log \"Handling event\" (str e))\n  (r/rswap! app-state event-handler e))\n\n(defn name-edit [id]\n  (let [p @(r/track person id)]\n    [:div\n     [:input {:value     (:name p)\n          :on-change #(emit [:set-name id (.. % -target -value)])}]]))\n\n(defn edit-fields []\n  (let [ids @(r/track person-keys)]\n    [:div\n     [name-list]\n     (for [i ids]\n       ^{:key i} [name-edit i])\n     [:input {:type     'button\n              :value    \"Add person\"\n              :on-click #(emit [:add-person])}]]))\n```\n\nAll events are passed through the emit function, consisting of a trivial application of `rswap!` and some optional logging. This is the only place where application state actually changes – the rest is pure functions.\n\nThe actual event handling is done in event-handler, which takes state and event as parameters, and returns a new state (events are represented by vectors here, with an event name in the first position).\n\nAll the UI components have to do is then just to return some markup, and set up routing of events through the emit function.\n\nThis architecture basically divides the application into two logical functions:\n\n* The first takes state and an event as input, and returns the next state.\n\n* The other takes state as input, and returns a UI definition.\n\nThis simple application could probably just as well use the common `swap!` instead of `rswap!`, but using `swap!` in React’s event handlers may trigger warnings due to unexpected return values, and may cause severe headaches if an event handler called by emit itself emits a new event (that would result in lost events, and much confusion).\n\nFor a more structured version of a similar approach, see the excellent re-frame framework.\n\n**TODO: is this the right example for rswap? If this is just re-frame light, maybe this shouldn't be in here. It would be better to have a more concise example.**\n\n## Cursors\n\nAny component that dereferences a state atom will update whenever any part of it is updated. If you are storing all state in a single atom (not uncommon), it will cause every component to update whenever the state is updated. Performance-wise, this may be acceptable, depending on how many elements you have and how often your state updates, because React itself will not manipulate the DOM unless the components actually change.\n\nReagent provides cursors, which behave like atoms but operate like pointers into a larger atom (or into multiple parts of multiple atoms).\n\nCursors are created with `reagent/cursor`, which takes a ratom and a keypath (like `get-in`):\n\n```clojure\n;; First create a ratom\n(def state (reagent/atom {:foo {:bar \"BAR\"}\n                                :baz \"BAZ\"\n                                :quux \"QUUX\"}))\n;; Now create a cursor\n(def bar-cursor (reagent/cursor state [:foo :bar]))\n\n(defn quux-component []\n  (js/console.log \"quux-component is rendering\")\n  [:div (:quux @state)])\n\n(defn bar-component []\n  (js/console.log \"bar-component is rendering\")\n  [:div @bar-cursor])\n\n(defn mount-root []\n  (rdom/render [:div [quux-component] [bar-component]]\n    (.getElementById js/document \"app\"))\n  (js/setTimeout (fn [] (swap! state assoc :baz \"NEW BAZ\")) 1000)\n  (js/setTimeout (fn [] (swap! state assoc-in [:foo :bar] \"NEW BAR\")) 2000))\n\n\n;; Console output:\n;; quux-component is rendering\n;; bar-component is rendering\n;; After 1 second:\n;; quux-component is rendering\n;; After 2 seconds:\n;; quux-component is rendering\n;; bar-component is rendering\n```\n\nBoth `bar-component` and `quux-component` update whenever their respective cursors/atoms update, but because `bar-component`'s cursor is limited only to the relevant portion of the app-state, it only re-renders when `[:foo :bar]` updates, whereas `quux-component` updates each time `app-state` changes, even though `:quux` never changes.\n\n### More general cursors\n\nThe cursor mechanism is more general than described above. You can pass a function that performs arbitrary transformations on one or more atoms.\n**TODO (DO WE NEED TO EXPLAIN THIS?)**\n\nReagent also provides the `reagent/wrap` mechanism, which also derives a new atom but provides more general functionality. Where a cursor will always update the atom from which it was derived, `reagent/wrap` takes an atom and a callback that will be called whenever the derived atom is updated. Replacing `(r/cursor n [:first-name])` with `(r/wrap first-name swap! n assoc :first-name)]` gives essentially the same results.\n**TODO (WHAT UTILITY DOES THIS HAVE?)**\n\n## Reactions\n\nReactions are like cursors called with a function.\n\nWhen reactions produce a new result (as determined by `=`), they cause other dependent reactions and components to update.\n\nThe function `make-reaction`, and its macro `reaction` are used to create a `Reaction`, which is a type that belongs to a number of protocols such as `IWatchable`, `IAtom`, `IReactiveAtom`, `IDeref`, `IReset`, `ISwap`, `IRunnable`, etc. which make it atom-like: ie it can be watched, derefed, reset, swapped on, and additionally, tracks its derefs, behave reactively, and so on.\n\nReactions are what give `r/atom`, `r/cursor`, and `r/wrap` their power.\n\n`make-reaction` takes one argument, `f`, and an optional options map. The options map specifies what happens to `f`:\n\n* `auto-run` (boolean) specifies whether `f` run on change\n* `on-set` and `on-dispose` are run when the reaction is set and unset from the DOM\n* `derefed` **TODO unclear**\n\nReactions are very useful when\n\n* You need a way in which a component only updates based on part of the ratom state. (reagent/cursor can also be used for this scenario)\n* When you want to combine two `ratoms` and produce a result\n* You want the component to use some transformed value of `ratom`\n\nHere's an example:\n```\n (def app-state (reagent/atom {:state-var-1 {:var-a 2\n                                             :var-b 3}\n                               :state-var-2 {:var-a 7\n                                             :var-b 9}}))\n\n (def app-var2a-reaction (reagent.ratom/make-reaction\n                          #(get-in @app-state [:state-var-2 :var-a])))\n\n\n (defn component-using-make-reaction []\n   [:div\n    [:div \"component-using-make-reaction\"]\n    [:div \"state-var-2 - var-a : \" @app-var2a-reaction]])\n\n```\n\nThe below example uses `reagent.ratom/reaction` macro, which provides syntactic sugar compared to \nusing plain `make-reaction`:\n\n```\n(let [username (reagent/atom \"\")\n      password (reagent/atom \"\")\n      fields-populated? (reagent.ratom/reaction (every? not-empty [@username @password]))]\n [:div \"Is username and password populated ?\" @fields-populated?])\n```\nReactions are executed asynchronously, so be sure to call `flush` if you depend on reaction side effects.\n\n## The track function\n\n`reagent.core/track` takes a function, and optional arguments for that function, and gives a derefable (i.e \"atom-like\") value, containing whatever is returned by that function. If the tracked function depends on a Reagent atom, it is called again whenever that atom changes – just like a Reagent component function. If the value returned by `track` is used in a component, the component is re-rendered when the value returned by the function changes.\n\nIn other words, `@(r/track foo x)` gives the same result as `(foo x)` – but in the first case, foo is only called again when the atom(s) it depends on changes.\n\nHere's an example:\n\n```clojure\n(ns example.core\n  (:require [reagent.core :as r]))\n(defonce app-state (r/atom {:people\n                              {1 {:name \"John Smith\"}\n                               2 {:name \"Maggie Johnson\"}}}))\n\n(defn people []\n  (:people @app-state))\n\n(defn person-keys []\n  (-> @(r/track people)\n      keys\n      sort))\n\n(defn person [id]\n  (-> @(r/track people)\n      (get id)))\n\n(defn name-comp [id]\n  (let [p @(r/track person id)]\n    [:li\n     (:name p)]))\n\n(defn name-list []\n  (let [ids @(r/track person-keys)]\n    [:ul\n     (for [i ids]\n       ^{:key i} [name-comp i])]))\n```\n\nHere, the name-list component will only be re-rendered if the keys of the :people map changes. Every name-comp only renders again when needed, etc.\n\nUse of track can improve performance in three ways:\n\n1. It can be used as a cache for an expensive function, that is automatically updated if that function depends on Reagent atoms (or other tracks, cursors, etc).\n2. It can also be used to limit the number of times a component is re-rendered. The user of track is only updated when the function’s result changes. In other words, you can use track as a kind of generalized, read-only cursor.\n3. Every use of track with the same arguments will only result in one execution of the function. E.g the two uses of `@(r/track people)` in the example above will only result in one call to the people function (both initially, and when the state atom changes).\n\n_Note:_ Compared to reactions, `reagent.ratom/reaction` and `track` are similar. The main differences are that track uses named functions and variables, rather than depending on closures, and that you don’t have to manage their creation manually (since tracks are automatically cached and reused).\n\n_Note:_ The first argument to track should be a named function, i.e not an anonymous one. Also, beware of lazy data sequences: don’t use deref (i.e ”@”) with the for macro, unless wrapped in doall (just like in Reagent components).\n\n### The track! function\n\n`track!` works just like track, except that the function passed is invoked immediately, and continues to be invoked whenever any atoms used within it changes.\n\nFor example, given this function:\n\n```clojure\n(defn log-app-state []\n  (prn @app-state))\n```\n\nyou could use `(defonce logger (r/track! log-app-state))` to monitor changes to app-state. `log-app-state` would continue to run until you stop it, using `(r/dispose! logger)`.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "-wip-managing-state-atoms-cursors-reactions-and-tracking", :cljdoc.doc/contributors ("Juho Teperi" "Mike Walker" "Robin Nagpal" "Alan Thompson" "romankrru")}} {:title "Batching and Timing: How Reagent Renders Changes to Application State", :attrs {:cljdoc.doc/source-file "doc/BatchingAndTiming.md", :cljdoc/markdown "# Batching and Timing: How Reagent Renders Changes to Application State\n\nChanges in application state (as represented by Reagent’s `atom`s) are not rendered immediately to the DOM. Instead, Reagent waits until the browser is ready to repaint the window, and then all the changes are rendered in one single go.\n\nThis is good for all sorts of reasons:\n\n* Reagent doesn't have to spend time doing renderings that no one would ever see (because changes to application state happened faster than the browser could repaint).\n* If two or more atoms are changed simultaneously, this now leads to only one re-rendering, and not two.\n* The new code does proper batching of renderings even when changes to atoms are done outside of event handlers (which is great for e.g core.async users).\n* Repaints can be synced by the browser with for example CSS transitions, since Reagent uses requestAnimationFrame to do the batching. That makes for example animations smoother.\n\nIn short, Reagent renders less often, but at the right times. For a much better description of why async rendering is good, see David Nolen’s [excellent explanation here.](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs)\n\n## The bad news\n\nLunches in general tend to be non-free, and this is no exception. The downside to async rendering is that you can no longer depend on changes to atoms being immediately available in the DOM. (Actually, you couldn't have truly relied upon it anyway because React.js itself does batching inside event handlers.)\n\nThe biggest impact is in testing: be sure to call `reagent.core/flush` to force Reagent to synchronize state with the DOM.\n\n## An example\n\nHere is an example to (hopefully) demonstrate the virtues of async rendering. It consists of a simple color chooser (three sliders to set the red, green and blue components of a base color), and shows the base color + a bunch of divs in random matching colors. As soon as the base color is changed, a new set of random colors is shown.\n\nIf you change one of the base color components, the base color should change immediately, and smoothly (on my Macbook Air, rendering takes around 2ms, with 20 colored divs showing).\n\nBut perhaps more interesting is to see what happens when the updates can’t be made smoothly (because the browser simply cannot re-render the colored divs quickly enough). On my machine, this starts to happen if I change the number of divs shown to above 150 or so.\n\nAs you increase the number of divs, you’ll notice that the base color no longer changes quite so smoothly when you move the color sliders.\n\nBut the crucial point is that the sliders **still work**. Without async rendering, you could quickly get into a situation where the browser hangs for a while, doing updates corresponding to an old state.\n\nWith async rendering, the only thing that happens is that the frame rate goes down.\n\nBtw, I find it quite impressive that React manages to change 500 divs (12 full screens worth) in slightly more than 40ms. And even better: when I change the number of divs shown, it only takes around 6ms to re-render the color palette (because the individual divs don’t have to be re-rendered, divs are just added or removed from the DOM as needed).\n\n```clojure\n(ns example\n  (:require [reagent.core :as r]))\n(defn timing-wrapper [f]\n  (let [start-time (r/atom nil)\n        render-time (r/atom nil)\n        now #(.now js/Date)\n        start #(reset! start-time (now))\n        stop #(reset! render-time (- (now) @start-time))\n        timed-f (with-meta f\n                  {:constructor start\n                   :UNSAFE_component-will-update start\n                   :component-did-mount stop\n                   :component-did-update stop})]\n    (fn []\n      [:div\n       [:p [:em \"render time: \" @render-time \"ms\"]]\n       [timed-f]])))\n\n(def base-color (r/atom {:red 130 :green 160 :blue 120}))\n(def ncolors (r/atom 20))\n(def random-colors (r/atom nil))\n\n(defn to-rgb [{:keys [red green blue]}]\n  (let [hex #(str (if (< % 16) \"0\")\n                  (-> % js/Math.round (.toString 16)))]\n    (str \"#\" (hex red) (hex green) (hex blue))))\n\n(defn tweak-color [{:keys [red green blue]}]\n  (let [rnd #(-> (js/Math.random) (* 256))\n        tweak #(-> % (+ (rnd)) (/ 2) js/Math.floor)]\n    {:red (tweak red) :green (tweak green) :blue (tweak blue)}))\n\n(defn reset-random-colors [color]\n  (reset! random-colors\n          (repeatedly #(-> color tweak-color to-rgb))))\n\n(defn color-choose [color-part]\n  [:div.color-slider\n   (name color-part) \" \" (color-part @base-color)\n   [:input {:type \"range\" :min 0 :max 255\n            :value (color-part @base-color)\n            :on-change (fn [e]\n                         (swap! base-color assoc\n                                color-part (-> e .-target .-value int))\n                         (reset-random-colors @base-color))}]])\n\n(defn ncolors-choose []\n  [:div.color-slider\n   \"number of color divs \" @ncolors\n   [:input {:type \"range\" :min 0 :max 500\n            :value @ncolors\n            :on-change #(reset! ncolors (-> % .-target .-value int))}]])\n\n(defn color-plate [color]\n  [:div.color-plate\n   {:style {:background-color color}}])\n\n(defn palette []\n  (let [color @base-color\n        n @ncolors]\n    [:div\n     [:p \"base color: \"]\n     [color-plate (to-rgb color)]\n     [:div.color-samples\n      [:p n \" random matching colors:\"]\n      (map-indexed (fn [k v]\n                     ^{:key k} [color-plate v])\n                   (take n @random-colors))]]))\n\n(defn color-demo []\n  (reset-random-colors @base-color)\n  (fn []\n    [:div\n     [:h2 \"Matching colors\"]\n     [color-choose :red]\n     [color-choose :green]\n     [color-choose :blue]\n     [ncolors-choose]\n     [timing-wrapper palette]]))\n```\n\n## Tapping into the rendering loop\n\nThe `next-tick` function allows you to tap into the rendering loop. The function passed to `next-tick` is invoked immediately before the next rendering (which is in turn triggered using `requestAnimationFrame`).\n\nThe `after-update` is similar: it works just like `next-tick`, except that the function given is invoked immediately after the next rendering.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "batching-and-timing-how-reagent-renders-changes-to-application-state", :cljdoc.doc/contributors ("Juho Teperi" "Tharaka Manawardhana")}} {:title "Interop with React", :attrs {:cljdoc.doc/source-file "doc/InteropWithReact.md", :cljdoc/markdown "# Interop with React\n\nA little understanding of what Reagent is doing really helps when trying to use\nReact libraries and reagent together.\n\n## Creating React Elements directly\n\nThe `reagent.core/create-element` function simply calls React's `createElement`\nfunction (and therefore, it expects either a string representing an HTML\nelement or a React Component).\n\nAs an example, here are four ways to create the same element:\n\n```clojure\n(defn integration []\n  [:div\n   [:div.foo \"Hello \" [:strong \"world\"]]\n\n   (r/create-element \"div\"\n                     #js{:className \"foo\"}\n                     \"Hello \"\n                     (r/create-element \"strong\"\n                                        #js{}\n                                        \"world\"))\n\n   (r/create-element \"div\"\n                     #js{:className \"foo\"}\n                     \"Hello \"\n                     (r/as-element [:strong \"world\"]))\n\n   [:div.foo \"Hello \" (r/create-element \"strong\"\n                                        #js{}\n                                        \"world\")]])\n\n(defn mount-root []\n  (rdom/render [integration]\n    (.getElementById js/document \"app\")))\n```\n\nThis works because `reagent.dom/render` itself expects (1) a React element or (2) a\nHiccup form. If passed an element, it just uses it. If passed a Hiccup, it\ncreats a (cached) React component and then creates an element from that\ncomponent.\n\n## Creating React Elements from Hiccup forms\n\nThe `reagent.core/as-element` function creates a React element from a Hiccup\nform. In the previous section, we discussed how `reagent.dom/render` expects either\n(1) a Hiccup form or (2) a React Element. If it encounters a Hiccup form, it\ncalls `as-element` on it. When you have a React component that wraps children,\nyou can pass Hiccup forms to it wrapped in `as-element`.\n\n## Creating Reagent \"Components\" from React Components\n\nThe function `reagent/adapt-react-class` will turn a React Component into\nsomething that can be placed into the first position of a Hiccup form, as if it\nwere a Reagent function. Take, for example the react-flip-move library and\nassume that it has been properly imported as a React Component called\n`FlipMove`. By wrapping FlipMove with `adapt-react-class`, we can use it in a\nHiccup form:\n\n```clojure\n(defn top-articles [articles]\n  [(reagent/adapt-react-class FlipMove)\n   {:duration 750\n    :easing \"ease-out\"}\n   articles])\n```\n\nThere is also a convenience mechanism `:>` (colon greater-than) that shortens\nthis and avoid some parenthesis:\n\n```clojure\n(defn top-articles [articles]\n  [:> FlipMove\n   {:duration 750\n    :easing \"ease-out\"}\n   articles])\n```\n\nThis is the equivalent JavaScript:\n\n```clojure\nconst TopArticles = ({ articles }) => (\n  <FlipMove duration={750} easing=\"ease-out\">\n    {articles}\n  </FlipMove>\n);\n```\n\n## Creating React Components from Reagent \"Components\"\n\nThe `reagent/reactify-component` will take a Form-1, Form-2, or Form-3 reagent \"component\". For example:\n\n```clojure\n(defn exported [props]\n  [:div \"Hi, \" (:name props)])\n\n(def react-comp (r/reactify-component exported))\n\n(defn could-be-jsx []\n  (r/create-element react-comp #js{:name \"world\"}))\n```\n\nNote:\n\n* `adapt-react-class` and `reactify-component` are not perfectly symmetrical,\nbecause `reactify-component` requires that the reagent component accept\neverything in a single props map, including its children.\n\n## Example: \"Decorator\" Higher-Order Components\n\nSome React libraries use the decorator pattern: a React component which takes a\ncomponent as an argument and returns a new component as its result. One example\nis the React DnD library. We will need to use both `adapt-react-class` and\n`reactify-component` to move back and forth between React and reagent:\n\n```clojure\n(def react-dnd-component\n  (let [decorator (DragDropContext HTML5Backend)]\n    (reagent/adapt-react-class\n      (decorator (reagent/reactify-component top-level-component)))))\n```\n\nThis is the equivalent JavaScript:\n\n```clojure\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport { DragDropContext } from 'react-dnd';\n\nclass TopLevelComponent {\n  /* ... */\n}\n\nexport default DragDropContext(HTML5Backend)(TopLevelComponent);\n```\n\n## Example: Function-as-child Components\n\nSome React components expect a function as their only child. React AutoSizer is one such example.\n\n```clojure\n[(reagent/adapt-react-class AutoSizer)\n {}\n (fn [dims]\n  (let [dims (js->clj dims :keywordize-keys true)]\n   (reagent/as-element [my-component (:height dims)])))]\n```\n\n## Getting props and children of current component\n\nBecause you just pass arguments to reagent functions, you typically don't need\nto think about \"props\" and \"children\" as distinct things. But Reagent does make\na distinction and it is helpful to understand this, particularly when\ninteroperating with native elements and React libraries.\n\nSpecifically, if the first argument to your Reagent function is a map, that is\nassigned to `this.props` of the underlying Reagent component. All other\narguments are assigned as children to `this.props.children`.\n\nWhen interacting with native React components, it may be helpful to access\nprops and children, which you can do with `reagent.core/current-component`.\nThis function returns an object that allows you retrieve the props and children\npassed to the current component.\n\nBeware that `current-component` is only valid in component functions, and must\nbe called outside of e.g. event handlers and `for` expressions, so it's safest\nto always put the call at the top, as in `my-div` here:\n\n```clojure\n(ns example\n  (:require [reagent.core :as r]))\n\n(defn my-div []\n  (let [this (r/current-component)]\n    (into [:div.custom (r/props this)]\n          (r/children this))))\n\n(defn call-my-div []\n  [:div\n    [my-div \"Some text.\"]\n    [my-div {:style {:font-weight 'bold}}\n      [:p \"Some other text in bold.\"]]])\n```\n\n## React Features\n\n- [React Features and how to use them in Reagent](./ReactFeatures.md)\n\n## Examples\n\n- [Material-UI](../examples/material-ui/src/example/core.cljs)\n- [React-sortable-hoc](../examples/react-sortable-hoc/src/example/core.cljs)\n- [React-transition-group](../examples/react-transition-group/src/example/core.cljs)\n", :cljdoc.doc/type :cljdoc/markdown, :slug "interop-with-react", :cljdoc.doc/contributors ("Juho Teperi" "Timo Sutterer" "boxp" "Alan Thompson")}} {:title "React Features", :attrs {:cljdoc.doc/source-file "doc/ReactFeatures.md", :cljdoc/markdown "# React Features\n\nMost React features should be usable from Reagent, even if Reagent doesn't\nprovide functions to use them directly.\n\n## [Fragments](https://reactjs.org/docs/fragments.html)\n\nJSX:\n```js\nfunction example() {\n  return (\n    <React.Fragment>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </React.Fragment>\n  );\n}\n```\n\nReagent:\n```cljs\n(defn example []\n  [:<>\n   [child-a]\n   [child-b]\n   [child-c]])\n```\n\nReagent syntax follows [React Fragment short syntax](https://reactjs.org/docs/fragments.html#short-syntax).\n\n## [Context](https://reactjs.org/docs/context.html)\n\n```cljs\n(defonce my-context (react/createContext \"default\"))\n\n(def Provider (.-Provider my-context))\n(def Consumer (.-Consumer my-context))\n\n(rdom/render\n  [:> Provider {:value \"bar\"}\n   [:> Consumer {}\n    (fn [v]\n      (r/as-element [:div \"Context: \" v]))]]\n  container)\n```\n\n[Context example project](../examples/react-context/src/example/core.cljs)\nbetter explains how\n`:>` or `adapt-react-class` convert the properties to JS objects,\nand shows how to use Cljs values with context.\n\nAlternatively you can use the [static contextType property](https://reactjs.org/docs/context.html#classcontexttype)\n\n```cljs\n(defonce my-context (react/createContext \"default\"))\n\n(def Provider (.-Provider my-context))\n\n(defn show-context []\n  (r/create-class\n   {:context-type my-context\n    :reagent-render (fn []\n                      [:p (.-context (reagent.core/current-component))])}))\n\n;; Alternatively with metadata on a form-1 component:\n;;\n;; (def show-context\n;;   ^{:context-type my-context}\n;;   (fn []\n;;     [:p (.-context (reagent.core/current-component))]))\n\n(rdom/render\n  [:> Provider {:value \"bar\"}\n   [show-context]]\n  container)\n```\n\nContext value can also be retrieved using `useContext` hook:\n\n```cljs\n(defn show-context []\n  (let [v (react/useContext my-context)]\n    [:p v]))\n\n(rdom/render\n  [:> Provider {:value \"bar\"}\n   [:f> show-context]]\n  container)\n```\n\nTests contain example of using old React lifecycle Context API (`context-wrapper` function):\n[tests](https://github.com/reagent-project/reagent/blob/master/test/reagenttest/testreagent.cljs#L1159-L1168)\n\n## [Error boundaries](https://reactjs.org/docs/error-boundaries.html)\n\n[Relevant method docs](https://reactjs.org/docs/react-component.html#static-getderivedstatefromerror)\n\nYou can use `getDerivedStateFromError` (since React 16.6.0 and Reagent 0.9) (and `ComponentDidCatch`) lifecycle method with `create-class`:\n\n```cljs\n(defn error-boundary [comp]\n  (let [error (r/atom nil)]\n    (r/create-class\n      {:component-did-catch (fn [this e info])\n       :get-derived-state-from-error (fn [e]\n                                            (reset! error e)\n                                            #js {})\n       :reagent-render (fn [comp]\n                          (if @error\n                            [:div\n                             \"Something went wrong.\"\n                             [:button {:on-click #(reset! error nil)} \"Try again\"]]\n                            comp))})))\n```\n\nAlternatively, one could use React state instead of RAtom to keep track of error state, which\ncan be more obvious with the new `getDerivedStateFromError` method:\n\n```cljs\n(defn error-boundary [comp]\n  (r/create-class\n    {:constructor (fn [this props]\n                    (set! (.-state this) #js {:error nil}))\n     :component-did-catch (fn [this e info])\n     :get-derived-state-from-error (fn [error] #js {:error error})\n     :render (fn [this]\n               (r/as-element\n                 (if-let [error (.. this -state -error)]\n                   [:div\n                    \"Something went wrong.\"\n                    [:button {:on-click #(.setState this #js {:error nil})} \"Try again\"]]\n                   comp)))}))\n```\n\nAs per React docs, `getDerivedStateFromError` is what should update the state\nafter error, it can be also used to update RAtom as in Reagent the Ratom is available\nin function closure even for static methods. `ComponentDidCatch` can be used\nfor side-effects, like logging the error.\n\n## [Function components](https://reactjs.org/docs/components-and-props.html#function-and-class-components)\n\nJavaScript functions are valid React components, but Reagent implementation\nby default turns the ClojureScript functions referred in Hiccup-vectors to\nClass components.\n\nHowever, some React features, like Hooks, only work with Functional components.\nThere are several ways to use functions as components with Reagent:\n\nCalling `r/create-element` directly with a ClojureScript function doesn't\nwrap the component in any Reagent wrappers, and will create functional components.\nIn this case you need to use `r/as-element` inside the function to convert\nHiccup-style markup to elements, or just return React Elements yourself.\nYou also can't use Ratoms here, as Ratom implementation requires that the component\nis wrapped by Reagent.\n\n`:r>` shortcut can be used to create components similar to `r/create-element`, and the children Hiccup forms\nare converted to React element automatically.\n\nUsing `adapt-react-class` or `:>` is also calls `create-element`, but that\nalso does automatic conversion of ClojureScript parameters to JS objects,\nwhich isn't usually desired if the component is ClojureScript function.\n\nNew way is to configure Reagent Hiccup-compiler to create functional components:\n[Read Compiler documentation](./ReagentCompiler.md)\n\n`:f>` shortcut can be used to create function components from Reagent components (functions),\nwhere both RAtoms and Hooks work.\n\n## [Hooks](https://reactjs.org/docs/hooks-intro.html)\n\n```cljs\n;; This is used with :f> so both Hooks and RAtoms work here\n(defn example []\n  (let [[count set-count] (react/useState 0)]\n    [:div\n     [:p \"You clicked \" count \" times\"]\n     [:button\n      {:on-click #(set-count inc)}\n      \"Click\"]])))\n\n(defn root []\n  [:div\n   [:f> example]])\n```\n\n### Pre 1.0 workaround\n\nNOTE: This section still refers to workaround using Hooks inside\nclass components, read the previous section to create functional components.\n\nHooks can't be used inside class components, and Reagent implementation creates\na class component from every function (i.e. Reagent component).\n\nHowever, you can use React components using Hooks inside Reagent, or use\n[hx](https://github.com/Lokeh/hx) components inside Reagent. Also, it is\npossible to create React components from Reagent quite easily, because React\nfunction component is just a function that happens to return React elements,\nand `r/as-element` does just that:\n\n```cljs\n;; This is React function component. Can't use Ratoms here!\n(defn example []\n  (let [[count set-count] (react/useState 0)]\n    (r/as-element\n      [:div\n       [:p \"You clicked \" count \" times\"]\n       [:button\n        {:on-click #(set-count inc)}\n        \"Click\"]])))\n\n;; Reagent component\n(defn reagent-component []\n  [:div\n   ;; Note :> to use a function as React component\n   [:> example]])\n```\n\nIf you need to pass RAtom state into these components, dereference them in\nthe Reagent components and pass the value (and if needed, function to update them)\nas properties into the React function component.\n\n## [Portals](https://reactjs.org/docs/portals.html)\n\n```cljs\n(defn reagent-component []\n  (let [el (.. js/document (getElementById \"portal-el\"))]\n    (react-dom/createPortal (r/as-element [:div \"foo\"]) el)))\n```\n\n## [Hydrate](https://reactjs.org/docs/react-dom.html#hydrate)\n\n```cljs\n(react-dom/hydrate (r/as-element [main-component]) container)\n```\n\n## Component classes\n\nFor interop with React libraries, you might need to pass Component classes to other components as parameter. If you have a Reagent component (a function) you can use `r/reactify-component` which returns creates a Class from the function.\n\nIf the parent Component awaits classes with some custom methods or properties, you need to be careful and probably should use `r/create-class`. In this case you don't want to use `r/reactify-component` with a function (even if the function returns a class) because `r/reactify-component` wraps the function in another Component class, and parent Component doesn't see the correct class.\n\n```cljs\n;; Correct way\n(def editor\n  (r/create-class\n    {:get-input-node (fn [this] ...)\n     :reagent-render (fn [] [:input ...])})))\n\n[:> SomeComponent\n {:editor-component editor}]\n\n;; Often incorrect way\n(defn editor [parameter]\n  (r/create-class\n    {:get-input-node (fn [this] ...)\n     :reagent-render (fn [] [:input ...])})))\n\n[:> SomeComponent\n {:editor-component (r/reactify-component editor)}]\n```\n\nIn the latter case, `:editor-component` is a Reagent wrapper class component, which doesn't have the `getInputNode` method and is rendered using the Component created by `create-class` and which has the method.\n\n\nIf you need to add static methods or properties, you need to modify `create-class` return value yourself. The function handles the built-in static-methods (`:childContextTypes :contextTypes :contextType :getDerivedStateFromProps :getDerivedStateFromError`), but not others.\n\n```cljs\n(let [klass (r/create-class ...)]\n  (set! (.-static-property klass) \"foobar\")\n  (set! (.-static-method klass) (fn [param] ...))\n  klass)\n```\n", :cljdoc.doc/type :cljdoc/markdown, :slug "react-features", :cljdoc.doc/contributors ("Juho Teperi" "David James Humphreys" "Lucy Wang" "Arne Brasseur")}} {:title "Reagent Compiler", :attrs {:cljdoc.doc/source-file "doc/ReagentCompiler.md", :cljdoc/markdown "# Reagent Compiler\n\nReagent Compiler object is a new way to configure how Reagent\nturns the Hiccup-style markup into React components and elements.\n\nAs a first step, this can be used to turn on option to create\nfunctional components when a function is referred in a Hiccup vector:\n`[component-fn parameters]`.\n\n<a href=\"ReactFeatures.md#hooks\">Read more about Hooks</a>\n\n```cljs\n(def functional-compiler (reagent.core/create-compiler {:function-components true}))\n\n;; Using the option\n(reagent.dom/render [main] div functional-compiler)\n(reagent.core/as-element [main] functional-compiler)\n;; Setting compiler as the default\n(reagent.core/set-default-compiler! functional-compiler)\n```\n\n## Functional components implementation\n\nFeatures:\n\n- Ratoms works.\n- The functions are wrapped in another function, which uses two\nstate hooks to store component identity and \"update count\" - which is used to\nforce re-render when Ratoms the component uses are updated.\n- The functions is wrapped in `react/memo` to implement logic similar to\n`shouldComponentUpdate` (component is rendered only if the properties change).\n- This implementation passes the same test suite as class components.\n\nDifferences to Class component implementation:\n\n- `reagent.dom/render` doesn't return the Component instance, but just `nil`\n- `reagent.core/current-component` returns a mocked object that can be passed to `reagent.core/force-update`,\nbut won't support everything that real Component instance would support.\n- A bit slower compared to Class component implementation\n- `useEffect` cleanup function is called asynchronously some time after\nunmounting the component from DOM (in React 17). This is used to dispose component RAtom,\nwhich will affect e.g. `r/with-let` `finally` function being called. Cleanup\nis still called before the component is mounted again. This probably shouldn't\naffect any real use cases, but required waiting two animation frames on\nReagent tests to assert that the `finally` was ran.\n([More information](https://reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timing))\n- Using `r/wrap` as component parameter seems to in some cases re-render\ncomponents when source atom is changed, even if the value in path didn't\nchange. Could be related to how `react/memo` handles changes properties.\n\n![1.0.0-alpha2 benchmark](benchmark.png)\n\n(Local test run with https://github.com/krausest/js-framework-benchmark, with added function component case)\n\n## Reasoning\n\nNow that this mechanism to control how Reagent compiles Hiccup-style markup\nto React calls is in place, it will be probably used later to control\nsome other things also:\n\nFrom [Clojurist Together announcenment](https://www.clojuriststogether.org/news/q1-2020-funding-announcement/):\n\n> As this [hooks] affects how Reagent turns Hiccup to React elements and components, I\n> have some ideas on allowing users configure the Reagent Hiccup compiler,\n> similar to what [Hicada](https://github.com/rauhs/hicada) does. This would also allow introducing optional\n> features which would break existing Reagent code, by making users opt-in to\n> these. One case would be to make React component interop simpler.\n\nSome ideas:\n\n- Providing options to control how component parameters are converted to JS\nobjects (or even disable automatic conversion)\n- Implement support for custom tags (if you can provide your own function\nto create element from a keyword, this will be easy)\n\nOpen questions:\n\n- Will this cause problems for libraries? Do the libraries have to start\ncalling `as-element` with their own Compiler to ensure compatibility.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "reagent-compiler", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "Controlled Inputs", :attrs {:cljdoc.doc/source-file "doc/ControlledInputs.md", :cljdoc/markdown "# Controlled inputs\n\nReagent uses async rendering which causes problems with controlled inputs. If\nthe input element is created directly by Reagent (i.e. `[:input ...]` in hiccup), [a\nworkaround](https://github.com/reagent-project/reagent/blob/master/src/reagent/impl/template.cljs#L132-L238)\ncan be applied, but if the input is created by JS library (i.e. JSX `<input>`\nor React `create-element`), Reagent doesn't see\nthe element so the workaround can't be applied.\n\nDue to async rendering, the DOM update doesn't occur during the event handler,\nbut some time later. In certain cases, like when the cursor is not at the end\nof the input, updating the DOM input value causes the cursor to move to the\nend of the input. Without async rendering, browsers probably implement logic\nto keep the cursor position if the value is updated during event handler.\n\nReagent workaround works by changing the React input element into\nuncontrolled input (i.e. the DOM value is not updated by React). Instead\nReagent will update DOM itself if the Reagent input value property changes.\nThis enables Reagent to check the cursor position before updating the\nvalue, and if needed, save and restore the cursor position\nafter updating the value.\n\nFor JS libraries, usually the best solution is if the library provides an option to\nuse custom component to create the input element, which enables\nReagent to create the input element:\n\n## React-native\n\nReactNative has it's own `TextInput` component. Similar workaround can't be (at least easily) implemented in ReactNative, as the component doesn't provide similar API as DOM Inputs to control the selection. Currently best option is to use uncontrolled inputs (`default-value` and `on-change`). If you also need to update the input value from your code, you could change to Input component React key to force recreation of the component:\n\n```clj\n[:> TextInput\n {:key @k\n  :default-value @v\n  :on-change ...}]\n  \n (reset! v \"foo\")\n (swap! k inc)\n;; When key changes, old component is unmounted and new one created, and the new component will use the new default-value\n```\n\n(Similar workaround can be also used with DOM inputs)\n\n## Examples\n\n- [Material UI](./examples/material-ui.md)\n- [Smooth UI](./examples/smooth-ui.md)\n", :cljdoc.doc/type :cljdoc/markdown, :slug "controlled-inputs", :cljdoc.doc/contributors ("Juho Teperi")}}]} {:title "Frequently Asked Questions", :attrs {:slug "frequently-asked-questions"}, :children [{:title "Why isn't my Component re-rendering?", :attrs {:cljdoc.doc/source-file "doc/FAQ/ComponentNotRerendering.md", :cljdoc/markdown "### Question\n\nMy component is not re-rendering, what's wrong?\n\n### Answer\n\nAsk yourself this question: why do you think the Component should have re-rendered? There's two possible answers: \n  - a ratom (used by the Component) changed \n  - the props for (arguments to) the Component changed\n\nWe'll deal with these two cases seperately.\n\n### A Ratom Changed\n\nIf a ratom changes but your Component doesn't update, then the gotchas to look out for are: \n1. Make sure you are using a `reagent.core/atom` (i.e. a Reagent ratom) instead of a normal `clojure.core/atom`. Carefully check the `require` at the top of the `ns`.  Components are only reactive with respect to Reagent ratoms. They don't react to changes in a Clojure atom. \n2. Make sure you actually `deref` your ratom (e.g. `@app-state`) during the render function of your component. It is a common mistake for people to forget the leading `@`.  Note that derefs that happen outside of the render function (such as during event handlers) do not make your component reactive to that ratom.\n3. Make sure your ratom will survive a rerender. Either declare it as a global var, or use a form-2 or form-3 component. [Read this](https://github.com/reagent-project/reagent-cookbook/tree/master/basics/component-level-state) if you want to understand why.\n4. If you put your ratom in a form-2 or form-3 component, be sure you are calling that function using `[square brackets]`, not `(parenthesis)`.\nWhen function (component) is called using `( )` Reagent doesn't create new component, but instead just places the function's return value into current component. In this case the function closure which should hold the local state doesn't work.\n5. Make sure to `deref` your ratom outside of a seq or wrap that seq in a `doall`. See this [related issue](https://github.com/reagent-project/reagent/issues/18).\n\n### Props Change\n\nIf the props to a Component change, but it doesn't appear to re-render, then the cause will be this rookie mistake: you forgot to repeat the parameters in the inner, anonymous render function.\n\n```clj\n(defn outer \n  [a b c]            ;; <--- parameters\n  ;;  ....\n  (fn [a b c]        ;; <--- forgetting to repeat parameters here is the mistake\n    [:div\n      (str a b c)]))\n```\n\nIf you forget, the component renderer will stubbornly only ever render the \noriginal parameter values, not the updated ones, which can be baffling for \na beginner.\n\nRemember, `outer` is called once per component instance. The parameters to `outer` \nwill hold the initial parameter values. The inner renderer on the other hand, \nwill be called by Reagent many times and, each time, potentially with alternative \nparameter values, but unless you repeat the parameters on the renderer it will \nclose over those initial values in `outer`. As a result, the component renderer \nwill stubbornly only ever render the original parameter values, not the updated ones. \n\n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "why-isn-t-my-component-re-rendering-", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "How do I use React's \"refs\"", :attrs {:cljdoc.doc/source-file "doc/FAQ/UsingRefs.md", :cljdoc/markdown "### Question\n\nWhen using Reagent, how do I use React's `refs`?\n\n### Answer\n\nCredit: this entry is entirely based on Paulus Esterhazy's [Reagent Mysteries series](https://presumably.de/reagent-mysteries-part-3-manipulating-the-dom.html)\n\nWe'll start with a code fragment, because it is worth a 1000 words:\n\n```cljs\n(defn video-ui []\n  (let [!video (clojure.core/atom nil)]    ;; stores the\n    (fn [{:keys [src]}]\n      [:div\n       [:div\n        [:video {:src src\n                 :style {:width 400}\n                 :ref (fn [el]\n                        (reset! !video el))}]]\n       [:div\n        [:button {:on-click (fn []\n                              (when-let [video @!video] ;; not nil?\n                                (if (.-paused video)\n                                  (.play video)\n                                  (.pause video))))}\n         \"Toogle\"]]])))\n```\n\nNotes:\n   1. This example uses a Form-2 component, which allows us to retain state outside of the renderer `fn`.  The same technique would work with a Form-3 component.\n   2. We capture state in `!video`. In this example, the state we capture is a reference to a [video HTML element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video).\n   3. `!video` is a `clojure.core/atom` and not a `reagent.core/atom`.  We use a normal Clojure `atom` because refs never change during the lifecycle of a component and if we used a reagent atom, it would cause an unnecessary re-render when the ref callback mutates the atom.\n   4. On the `:video` component there's a `:ref` callback function which establishes the state in `!video`.  You can attach a ref callback to any of the Hiccup elements.\n   5. Thereafter, `@!video` is used with the `:button's` `:on-click` to manipulate the `video` DOM methods.\n   6. For full notes [read Paulus' blog post](https://presumably.de/reagent-mysteries-part-3-manipulating-the-dom.html)\n   7. For more background on callback refs, see [React's documentation](https://facebook.github.io/react/docs/more-about-refs.html)\n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "how-do-i-use-react-s-refs-", :cljdoc.doc/contributors ("TristeFigure" "Alan Thompson" "Juho Teperi")}} {:title "How can I use an entity like \"nbsp\"?", :attrs {:cljdoc.doc/source-file "doc/FAQ/UsingAnEntity.md", :cljdoc/markdown "### Question\n\nHow can I use an entity like \"nbsp\"?\n\n### Answer\n\nIf you try to do this:\n```clj\n[:div \"hello\" \"&nbsp;\" \"there\"]     ;; <--- note: attempt to use an entity\n```\nthen you will see the string for the entity. Which is not what you want. \n\nInstead you should do this:\n\n  1. Require in goog's string module...\n\n  ```clj\n  (:require [goog.string :as gstring])\n  ```\n\n  2. Use it like this ... \n\n  ```clj\n   [:div \"hello\" (gstring/unescapeEntities \"&nbsp;\") \"there\"]\n  ```\n\n**Note:** `unescapeEntities` relies on the DOM to produce a string with unescape entities;\nin `nodejs` the DOM is unlikely to be available (unless you try using\n[`jsdom`](https://www.npmjs.com/package/jsdom-global)).\n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "how-can-i-use-an-entity-like-nbsp-", :cljdoc.doc/contributors ("Daniel Compton" "Juho Teperi")}} {:title "Why is my attribute (like autoFocus) missing?", :attrs {:cljdoc.doc/source-file "doc/FAQ/MyAttributesAreMissing.md", :cljdoc/markdown "### Question\n\nWhy isn't my attribute `xyz` showing up on <some-element>?  (where is `xyz` is something like `autoFocus`)\n\n### Answer\n\nYou might be spelling it incorrectly. \n\nReact supports [camelCased HTML attributes](https://reactjs.org/docs/dom-elements.html#all-supported-html-attributes),\nbut the equivalent in Reagent is dashed and lower cased. \n\nFor example, with Reagent, you use `auto-focus`, instead of `autoFocus`. And \nyou use `col-span` instead of React's `colSpan`. \n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "why-is-my-attribute-like-autofocus-missing-", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "How can I use React's dangerouslySetInnerHTML?", :attrs {:cljdoc.doc/source-file "doc/FAQ/dangerouslySetInnerHTML.md", :cljdoc/markdown "### Question\n\nHow can I use React's [dangerouslySetInnerHTML](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml) feature?\n\n### Answer\n\nA minimal (contrived example):\n\n```clj\n[:div\n {:dangerouslySetInnerHTML\n  {:__html \"<image  height=\\\"600\\\" src=\\\"https://static1.squarespace.com/static/58f9c2fbd2b85759c7e4ec2f/5923cbe4be6594d8a0b033a9/5a0154a6ec212d85ddf7941f/1511246183022/mfsprout_20160406_1234-Print.jpg?format=1500w\\\"/>\"}}]\n```\n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "how-can-i-use-react-s-dangerouslysetinnerhtml-", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "Reagent doesn't work after updating dependencies", :attrs {:cljdoc.doc/source-file "doc/FAQ/CljsjsReactProblems.md", :cljdoc/markdown "# Question\n\nReagent doesn't work after updating dependencies.\n\n# Answer\n\nIf you see errors about accessing `React` or `ReactDOM` object or some React method after you have updated your dependencies, the problem is probably conflicting `cljsjs/react` or `cljsjs/react-dom` versions. Other dependencies than Reagent might bring in versions which don't work with Reagent, or a library which only depends on one of the packages might cause React and ReactDOM versions to conflict.\n\nTo fix this you should check `lein deps :tree` or `boot show -d`, and check which version of Cljsjs React packages you have.\n\nThere are three alternative solutions:\n\n1. Update all the packages that require Cljsjs React packages to use same (or compatible) versions as Reagent\n2. Add `:exclusion [cljsjs/react cljsjs/react-dom]` to problematic dependencies, so only Reagent\nwill have transitive dependency on React packages\n3. Add direct `cljsjs/react` and `cljsjs/react-dom` dependencies to your project, which will override any transitive dependencies\n\nNote: `cljsjs/react-dom-server` package is deprecated but Reagent still depends on empty package for compatibility.\n\nNote: For more information on how Leiningen and Boot resolve dependencies using Maven-resolver, read: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html\n", :cljdoc.doc/type :cljdoc/markdown, :slug "reagent-doesn-t-work-after-updating-dependencies", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "How do I force Component re-creation?", :attrs {:cljdoc.doc/source-file "doc/FAQ/ForcingComponentRecreation.md", :cljdoc/markdown "# Forcing Component re-creation?\n\n## React key with a stateful component\n\nReact key can be used to provide identity for components even outside of lists.\nIf the key changes, the component is recreated triggering all the implemented\nstateful methods (did-unmount, did-mount etc.):\n\n```clj\n(defn comp []\n  [:div\n   ^{:key dynamic-id}\n   [stateful-component]])\n```\n", :cljdoc.doc/type :cljdoc/markdown, :slug "how-do-i-force-component-re-creation-", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "Using HTML entities", :attrs {:cljdoc.doc/source-file "doc/FAQ/HtmlEntities.md", :cljdoc/markdown "# Using HTML entities\n\nReact will escape HTML entities (like `&nbsp;`, `&times;`) in the text elements.\n\nYou could just use literal character: `×` or unicode code, which is converted to\nthe character by Cljs compiler: `\\u00D7`.\n\nHTML entities work in React JSX because JSX will unescape the entity code to\nliteral character.\n\nYou can do the same in ClojureScript by using `goog.string/unescapeEntities`:\n\n```cljs\n(ns example\n  (:require [goog.string :as gstr]))\n\n(defn comp []\n  [:h1 \"Foo\" (gstr/unescapeEntities \"&times;\")])\n```\n\nNote: Yes, this can be inconvenient, but Reagent can't do this automatically as\nfinding and replacing entities during runtime would be slow.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "using-html-entities", :cljdoc.doc/contributors ("Juho Teperi")}}]} {:title "Examples", :attrs {:slug "examples"}, :children [{:title "Material-UI v1", :attrs {:cljdoc.doc/source-file "doc/examples/material-ui.md", :cljdoc/markdown "# Material-UI\n\n[Example project](../../examples/material-ui/)\n\nMaterial-UI [TextField](https://material-ui.com/api/text-field/) has for long\ntime caused problems for Reagent users. The problem is that `TextField` wraps the\n`input` element inside a component so that Reagent is not able to enable\ninput cursor fixes, which are required due to [async rendering](http://reagent-project.github.io/news/reagent-is-async.html).\n\nGood news is that Material-UI v1 has a property that can be used to provide\nthe input component to `TextField`:\n\n```cljs\n(ns example.material-ui\n  (:require [\"material-ui\" :as mui]\n            [reagent.core :as r]))\n\n(def text-field (r/adapt-react-class mui/TextField))\n\n(def value (r/atom \"\"))\n\n(def input-component\n  (r/reactify-component\n    (fn [props]\n      [:input (-> props\n                  (assoc :ref (:inputRef props))\n                  (dissoc :inputRef))])))\n\n(def example []\n  [text-field\n   {:value @value\n    :on-change #(reset! value (.. e -target -value))\n    :InputProps {:inputComponent input-component}}])\n```\n\n`reactify-component` can be used to convert Reagent component into React component,\nwhich can then be passed into Material-UI. The component should be created once\n(i.e. on top level) to ensure it is not unnecessarily redefined, causing the\ncomponent to be re-mounted.\nFor some reason Material-UI uses different name for `ref`, so the `inputRef` property\nshould be renamed by the input component.\n\n## Wrapping for easy use\n\nInstead of providing `:InputProps :inputComponent` option to every `TextField`,\nit is useful to wrap the `TextField` component in a way that the option is added always:\n\n```cljs\n(defn text-field [props & children]\n  (let [props (-> props\n                  (assoc-in [:InputProps :inputComponent] input-component)\n                  rtpl/convert-prop-value)]\n    (apply r/create-element mui/TextField props (map r/as-element children))))\n```\n\nHere `r/create-element` and `reagent.impl.template/convert-prop-value` achieve\nthe same as what `adapt-react-class` does, but allows modifying the props.\n\n**Check the example project for complete code.** Some additional logic is\nrequired to ensure option like `:multiline` and `:select` work correctly,\nas they affect how the `inputComponent` should work.\n\nTODO: `:multiline` `TextField` without `:rows` (i.e. automatic height) doesn't\nwork, because that requires Material-UI `Input/Textarea`, which doesn't work\nwith Reagent cursor fix.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "material-ui-v1", :cljdoc.doc/contributors ("Juho Teperi" "Jonathan Chen")}}]} {:title "Other", :attrs {:slug "other"}, :children [{:title "0.8 Upgrade guide", :attrs {:cljdoc.doc/source-file "doc/0.8-upgrade.md", :cljdoc/markdown "# 0.8 Upgrade guide\n\nThe necessary changes depend on what environment you target, and\nhow you want to provide React.\n\n|                | Build       | Browser       | Node |\n|---|---|---|---|\n| Cljsjs         | `:none`     | Supported     | Requires Cljs 1.10.238+ |\n| Cljsjs         | `:advanced` | Supported     | Requires Cljs 1.10.238+ |\n| `node modules` | `:none`     | Requires Cljs 1.10.312 | Supported  |\n| `node modules` | `:advanced` | Requires Cljs 1.10.312 | Supported  |\n\n## Browser - Cljsjs\n\n**This is the recommended setup.**\n\nUsing Reagent with Cljsjs packages doesn't require changes,\nother than making sure you update Cljsjs React dependencies,\nif you have direct dependencies to them.\n\nTo ensure Cljsjs libs are used instead of Node Modules, you can add `:npm-deps false`, which will make sure ClojureScript compiler doesn't look into `node_modules` directory if it exists.\n\n## Browser - node modules\n\nIf `react`, `react-dom` and `create-react-class` are available in `node_modules`\ndirectory, ClojureScript compiler will use these with Reagent.\n\nIf you don't want to call `npm` and manage `package.json`, you can use `:npm-deps` and `:install-deps` compiler options to\nhave ClojureScript install the packages automatically.\n\nYou can use `:process-shim` compiler option to provide `process.env.NODE_ENV`\nconstant which is used by JS code to enable development and production\nbuilds. ClojureScript compiler will automatically set this constant to\n`production` value when using `:advanced` optimizations. This enables\nthe React production build.\n\nWhen using module processing, it should be possible to split output into several\n[modules](https://clojurescript.org/reference/compiler-options#modules).\n\n**Externs are required for use with node modules also!** React created objects\nstatically in several places and then accesses those dynamically. Closure-compiler\nwill in these cases rename the statically object properties, which will break\ndynamically accessing the objects. Externs fix this by defining which properties\nmust not be renamed.\n\n## Browser - Webpack\n\nhttps://clojurescript.org/guides/webpack\n\nIf you want to load React.js yourself from external JS file (CDN) or from custom bundle,\nit should be possible to override the Cljsjs foreign-libs, while still using externs from Cljsjs packages. To override the foreign-libs, you can provide following compiler option:\n\n```clj\n:foreign-libs\n [{:file \"bundje.js\",\n   :provides [\"react\" \"react-dom\" \"create-react-class\" \"react-dom/server\"],\n   :global-exports {react React\n                    react-dom ReactDOM\n                    create-react-class createReactClass\n                    react-dom/server ReactDOMServer}}]\n```\n\n## NodeJS - Cljsjs\n\nRequires https://github.com/clojure/clojurescript/commit/f7d611d87f6ea8a605eae7c0339f30b79a840b49\n\nAvailable in 1.10.238\n\nReagent should use Cljsjs libraries by default even when running on Node.\n\n## NodeJS - node modules\n\nInstall `react`, `react-dom` and `create-react-class` npm packages,\nand ClojureScript should automatically use `require` to\nload React for Reagent.\n\n## Electron\n\n???\n\n## React-native\n\nhttps://github.com/drapanjanas/re-natal/issues/128\n\n## Common Problems\n\n### Mismatch with Cljsjs and npm packages\n\nIf you have one npm package installed, e.g. `react`, you also need\nto provide others (`react-dom` and `create-react-class`), else\nCljsjs packages would be used for these, and packages from different sources\ndon't work together.\n\n### Previous problems\n\nBefore ClojureScript 1.10.312 there were couple of problems with npm support:\n\n1. Closure can't properly handle React 16 CommonJS module pattern: https://github.com/google/closure-compiler/issues/2841\nThis causes the production React code being loaded even for development builds.\nUsing Chrome React Developer Tools with this setup will break Reagent. Fixed by `[com.google.javascript/closure-compiler-unshaded \"v20180610\"]` ([PR](https://github.com/google/closure-compiler/pull/2963)), will be\nthe included in next the ClojureScript release.\n\n2. Closure optimization currently breaks certain statically created objects which are\naccessed dynamically in `ReactDOM/server`: https://github.com/facebook/react/issues/12368\nFixed by using `[com.google.javascript/closure-compiler-unshaded \"v20180319\"]` ([fix commit](https://github.com/google/closure-compiler/commit/c13cf48b98477e44409dba6359246bffa95b1c7b)), will be\nthe default in next ClojureScript release.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "0-8-upgrade-guide", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "Development guide", :attrs {:cljdoc.doc/source-file "doc/development.md", :cljdoc/markdown "# Reagent development\n\n## Running tests\n\nThe tests use [Karma](https://karma-runner.github.io/2.0/index.html) to run tests on browsers. You need to install `karma` command to run the tests:\n\n```bash\nnpm install -g karma-cli\n```\n\nTo prepare different environments for tests run:\n\n```bash\n./prepare-tests.sh\n```\n\nAfter this, you can run the full test set:\n\n```bash\n./run-tests.sh\n```\n\nRunning all the tests can take a while, so while developing Reagent,\nyou might want to focus on one test environment, and use Figwheel to\nrun tests on your browser:\n\n```\nlein figwheel client # For Cljsjs\nlein figwheel client-npm # NPM\n\n# Open http://0.0.0.0:3449 on a browser\n# Check console for test output\n```\n\n## Building package\n\nTo build Reagent and use built version in your applications run `lein install`\nand update the dependency on your app to use the version that was installed.\n\nNote that if `project.clj` uses a version that is released on Clojars, this command\nwill overwrite that version on your local Maven repository. To restore\nreal version, remove directory corresponding to the version from `~/.m2/repository/reagent/reagent/`.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "development-guide", :cljdoc.doc/contributors ("Aleksandr Zhuravlev" "Juho Teperi")}}]}]}}}

{:pom {:description "A simple ClojureScript interface to React", :dependencies ({:group-id "org.clojure", :artifact-id "clojure", :scope nil, :optional nil, :version "1.10.1"} {:group-id "cljsjs", :artifact-id "react", :scope nil, :optional nil, :version "16.13.0-0"} {:group-id "cljsjs", :artifact-id "react-dom", :scope nil, :optional nil, :version "16.13.0-0"} {:group-id "cljsjs", :artifact-id "react-dom-server", :scope nil, :optional nil, :version "16.13.0-0"} {:group-id "org.clojure", :artifact-id "clojurescript", :scope "test", :optional nil, :version "1.10.597"} {:group-id "figwheel", :artifact-id "figwheel", :scope "test", :optional nil, :version "0.5.19"} {:group-id "doo", :artifact-id "doo", :scope "test", :optional nil, :version "0.1.11"} {:group-id "cljsjs", :artifact-id "prop-types", :scope "test", :optional nil, :version "15.7.2-0"})}, :cache-bundle {:namespaces #{{:name "reagent.dom.server", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.dom", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.batching", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.util", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.template", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.impl.component", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.debug", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.interop", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.ratom", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}} {:name "reagent.core", :platform "cljs", :version-entity {:id 4, :version "0.10.0", :group-id "reagent", :artifact-id "reagent"}}}, :latest "1.1.0", :version-entity {:group-id "reagent", :artifact-id "reagent", :version "0.10.0"}, :defs #{{:name "*always-update*", :file "reagent/impl/util.cljs", :line 179, :dynamic true, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "expand-seq-dev", :file "reagent/impl/template.cljs", :line 398, :arglists ([s o]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "flush!", :file "reagent/ratom.cljs", :line 121, :arglists ([]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "track", :file "reagent/ratom.cljs", :line 247, :arglists ([f & args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "make-wrapper", :file "reagent/ratom.cljs", :line 601, :arglists ([value callback-fn args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "valid-tag?", :file "reagent/impl/template.cljs", :line 28, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "enqueue", :file "reagent/impl/batching.cljs", :line 48, :arglists ([queue fs f]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "debug", :file "reagent/ratom.cljs", :line 11, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "is-client", :file "reagent/impl/util.cljs", :line 4, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "expand-seq-check", :file "reagent/impl/template.cljs", :line 406, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "cursor", :file "reagent/core.cljs", :line 311, :arglists ([src path]), :doc "Provide a cursor into a Reagent atom.\n\nBehaves like a Reagent atom but focuses updates and derefs to\nthe specified path within the wrapped Reagent atom. e.g.,\n\n```cljs\n(let [c (cursor ra [:nested :content])]\n  ... @c ;; equivalent to (get-in @ra [:nested :content])\n  ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)\n  ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)\n  )\n```\n\nThe first parameter can also be a function, that should look\nsomething like this:\n\n```cljs\n(defn set-get\n  ([k] (get-in @state k))\n  ([k v] (swap! state assoc-in k v)))\n```\n\nThe function will be called with one argument – the path passed to\ncursor – when the cursor is deref'ed, and two arguments (path and\nnew value) when the cursor is modified.\n\nGiven that set-get function, (and that state is a Reagent atom, or\nanother cursor) these cursors are equivalent:\n`(cursor state [:foo])` and `(cursor set-get [:foo])`.\n\nNote that a cursor is lazy: its value will not change until it is\nused. This may be noticed with add-watch.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "make-track!", :file "reagent/ratom.cljs", :line 240, :arglists ([f args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "with-let-destroy", :file "reagent/ratom.cljs", :line 333, :arglists ([v]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "reagent-class?", :file "reagent/impl/component.cljs", :line 57, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "shallow-obj-to-map", :file "reagent/impl/component.cljs", :line 14, :arglists ([o]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "key-from-vec", :file "reagent/impl/template.cljs", :line 284, :arglists ([v]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "IReactiveAtom", :file "reagent/ratom.cljs", :line 135, :type :protocol, :namespace "reagent.ratom", :platform "cljs"} {:name "reactify-component", :file "reagent/core.cljs", :line 59, :arglists ([c]), :doc "Returns an adapter for a Reagent component, that may be used from\nReact, for example in JSX. A single argument, props, is passed to\nthe component, converted to a map.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "force-update", :file "reagent/impl/util.cljs", :line 181, :arglists ([comp deep]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "assert-js-object", :file "reagent/debug.clj", :line 84, :arglists ([value]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "dom-node", :file "reagent/dom.cljs", :line 48, :arglists ([this]), :doc "Returns the root DOM node of a mounted component.\n", :type :var, :namespace "reagent.dom", :platform "cljs"} {:name "adapt-react-class", :file "reagent/impl/template.cljs", :line 307, :arglists ([c]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "create-element", :file "reagent/core.cljs", :line 17, :arglists ([type] [type props] [type props child] [type props child & children]), :doc "Create a native React element, by calling React.createElement directly.\n\nThat means the second argument must be a javascript object (or nil), and\nthat any Reagent hiccup forms must be processed with as-element. For example\nlike this:\n\n```cljs\n(r/create-element \"div\" #js{:className \"foo\"}\n  \"Hi \" (r/as-element [:strong \"world!\"])\n```\n\nwhich is equivalent to\n\n```cljs\n[:div.foo \"Hi\" [:strong \"world!\"]]\n```", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "track-console", :file "reagent/debug.cljs", :line 10, :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "run-funs", :file "reagent/impl/batching.cljs", :line 44, :arglists ([fs]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "custom-kv-conv", :file "reagent/impl/template.cljs", :line 85, :arglists ([o k v]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "track!", :file "reagent/ratom.cljs", :line 251, :arglists ([f & args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "with-let-values", :file "reagent/ratom.cljs", :line 337, :arglists ([key]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "hiccup-err", :file "reagent/impl/template.cljs", :line 347, :arglists ([v & msg]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "input-node-set-value", :file "reagent/impl/template.cljs", :line 140, :arglists ([node rendered-value dom-value component {:keys [on-write]}]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "Wrapper", :file "reagent/ratom.cljs", :line 554, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "track-warnings", :file "reagent/debug.cljs", :line 20, :arglists ([f]), :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "track", :file "reagent/core.cljs", :line 257, :arglists ([f & args]), :doc "Takes a function and optional arguments, and returns a derefable\ncontaining the output of that function. If the function derefs\nReagent atoms (or track, etc), the value will be updated whenever\nthe atom changes.\n\nIn other words, `@(track foo bar)` will produce the same result\nas `(foo bar)`, but foo will only be called again when the atoms it\ndepends on changes, and will only trigger updates of components when\nits result changes.\n\ntrack is lazy, i.e the function is only evaluated on deref.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "has-selection-api?", :file "reagent/impl/template.cljs", :line 134, :arglists ([input-type]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "running", :file "reagent/ratom.cljs", :line 21, :arglists ([]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "fun-name", :file "reagent/impl/util.cljs", :line 47, :arglists ([f]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "replace-state", :file "reagent/core.cljs", :line 166, :arglists ([this new-state]), :doc "Set state of a component.\nEquivalent to `(reset! (state-atom this) new-state)`", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "*ratom-context*", :file "reagent/ratom.cljs", :line 10, :dynamic true, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "after-render", :file "reagent/core.cljs", :line 379, :arglists ([f]), :doc "Run f using requestAnimationFrame or equivalent.\n\nf will be called just after any queued renders in the next animation\nframe (and even if no renders actually occur).", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "create-class", :file "reagent/impl/component.cljs", :line 320, :arglists ([body]), :doc "Creates JS class based on provided Clojure map.\n\nMap keys should use `React.Component` method names (https://reactjs.org/docs/react-component.html),\nand can be provided in snake-case or camelCase.\nConstructor function is defined using key `:getInitialState`.\n\nReact built-in static methods or properties are automatically defined as statics.", :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "add-obligatory", :file "reagent/impl/component.cljs", :line 274, :arglists ([fun-map]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "static-fns", :file "reagent/impl/component.cljs", :line 155, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "log", :file "reagent/debug.clj", :line 5, :arglists ([& forms]), :doc "Print with console.log, if it exists.\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "current-component", :file "reagent/core.cljs", :line 147, :arglists ([]), :doc "Returns the current React component (a.k.a `this`) in a component\nfunction.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "make-track", :file "reagent/ratom.cljs", :line 237, :arglists ([f args]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "cache-react-class", :file "reagent/impl/component.cljs", :line 71, :arglists ([c constructor]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "find-dom-node", :file "reagent/impl/template.cljs", :line 126, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "compare-mount-order", :file "reagent/impl/batching.cljs", :line 26, :arglists ([c1 c2]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "RCursor", :file "reagent/ratom.cljs", :line 257, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "atom", :file "reagent/ratom.cljs", :line 182, :arglists ([x] [x & {:keys [meta validator]}]), :doc "Like clojure.core/atom, except that it keeps track of derefs.\n", :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "re-tag", :file "reagent/impl/template.cljs", :line 15, :doc "Regular expression that parses a CSS-style id and class\nfrom a tag name.", :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "as-element", :file "reagent/impl/template.cljs", :line 383, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "try-get-key", :file "reagent/impl/template.cljs", :line 274, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "unmount-component-at-node", :file "reagent/core.cljs", :type :var, :line 81, :deprecated "0.10.0", :arglists ([container]), :doc "Remove a component from the given DOM node.\n", :namespace "reagent.core", :platform "cljs"} {:name "next-mount-count", :file "reagent/impl/batching.cljs", :line 10, :arglists ([]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "cursor", :file "reagent/ratom.cljs", :line 319, :arglists ([src path]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "reagent-input", :file "reagent/impl/template.cljs", :line 251, :arglists ([]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "partial", :file "reagent/core.cljs", :line 387, :arglists ([f & args]), :doc "Works just like clojure.core/partial, but the result can be compared with =\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "react-class?", :file "reagent/impl/component.cljs", :line 61, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "merge-props", :file "reagent/core.cljs", :line 230, :arglists ([] [defaults] [defaults props] [defaults props & others]), :doc "Utility function that merges some maps, handling `:class` and `:style`.\n\nThe :class value is always normalized (using `class-names`) even if no\nmerging is done.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "track!", :file "reagent/core.cljs", :line 273, :arglists ([f & args]), :doc "An eager version of track. The function passed is called\nimmediately, and continues to be called when needed, until stopped\nwith dispose!.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "run-queue", :file "reagent/impl/batching.cljs", :line 31, :arglists ([a]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "dom-node", :file "reagent/core.cljs", :type :var, :line 212, :deprecated "0.10.0", :arglists ([this]), :doc "Returns the root DOM node of a mounted component.\n", :namespace "reagent.core", :platform "cljs"} {:name "state", :file "reagent/core.cljs", :line 159, :arglists ([this]), :doc "Returns the state of a component, as set with replace-state or set-state.\nEquivalent to `(deref (r/state-atom this))`", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "force-update-all", :file "reagent/dom.cljs", :line 55, :arglists ([]), :doc "Force re-rendering of all mounted Reagent components. This is\nprobably only useful in a development environment, when you want to\nupdate components in response to some dynamic changes to code.\n\nNote that force-update-all may not update root components. This\nhappens if a component 'foo' is mounted with `(render [foo])` (since\nfunctions are passed by value, and not by reference, in\nClojureScript). To get around this you'll have to introduce a layer\nof indirection, for example by using `(render [#'foo])` instead.", :type :var, :namespace "reagent.dom", :platform "cljs"} {:name "state-atom", :file "reagent/impl/component.cljs", :line 77, :arglists ([this]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "cached-react-class", :file "reagent/impl/component.cljs", :line 68, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "render-queue", :file "reagent/impl/batching.cljs", :line 100, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "create-class", :file "reagent/core.cljs", :line 103, :arglists ([spec]), :doc "Creates JS class based on provided Clojure map, for example:\n\n```cljs\n{;; Constructor\n :constructor (fn [this props])\n :get-initial-state (fn [this])\n ;; Static methods\n :get-derived-state-from-props (fn [props state] partial-state)\n :get-derived-state-from-error (fn [error] partial-state)\n ;; Methods\n :get-snapshot-before-update (fn [this old-argv new-argv] snapshot)\n :should-component-update (fn [this old-argv new-argv])\n :component-did-mount (fn [this])\n :component-did-update (fn [this old-argv old-state snapshot])\n :component-will-unmount (fn [this])\n :component-did-catch (fn [this error info])\n :reagent-render (fn [args....])\n ;; Or alternatively:\n :render (fn [this])\n ;; Deprecated methods:\n :UNSAFE_component-will-receive-props (fn [this new-argv])\n :UNSAFE_component-will-update (fn [this new-argv new-state])\n :UNSAFE_component-will-mount (fn [this])}\n```\n\nEverything is optional, except either :reagent-render or :render.\n\nMap keys should use `React.Component` method names (https://reactjs.org/docs/react-component.html),\nand can be provided in snake-case or camelCase.\n\nState can be initialized using constructor, which matches React.Component class,\nor using getInitialState which matches old React createClass function and is\nnow implemented by Reagent for compatibility.\n\nState can usually be anything, e.g. Cljs object. But if using getDerivedState\nmethods, the state has to be plain JS object as React implementation uses\nObject.assign to merge partial state into the current state.\n\nReact built-in static methods or properties are automatically defined as statics.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "get-props", :file "reagent/impl/component.cljs", :line 43, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "argv", :file "reagent/core.cljs", :line 206, :arglists ([this]), :doc "Returns the entire Hiccup form passed to the component.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "assert-component", :file "reagent/debug.clj", :line 79, :arglists ([value]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "error", :file "reagent/debug.clj", :line 26, :arglists ([& forms]), :doc "Print with console.error.\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "unchecked-aget", :file "reagent/interop.clj", :line 5, :arglists ([array idx] [array idx & idxs]), :type :macro, :namespace "reagent.interop", :platform "cljs"} {:name "with-let", :file "reagent/core.clj", :line 4, :arglists ([bindings & body]), :doc "Bind variables as with let, except that when used in a component\nthe bindings are only evaluated once. Also takes an optional finally\nclause at the end, that is executed when the component is\ndestroyed.", :type :macro, :namespace "reagent.core", :platform "cljs"} {:name "NativeWrapper", :file "reagent/impl/template.cljs", :line 19, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "assert-new-state", :file "reagent/debug.clj", :line 89, :arglists ([value]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "built-in-static-method-names", :file "reagent/impl/component.cljs", :line 316, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "do-after-render", :file "reagent/impl/batching.cljs", :line 119, :arglists ([f]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "mount-count", :file "reagent/impl/batching.cljs", :line 8, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "expand-seq", :file "reagent/impl/template.cljs", :line 395, :arglists ([s]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "as-class", :file "reagent/impl/component.cljs", :line 391, :arglists ([tag]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "class-names", :file "reagent/core.cljs", :line 218, :arglists ([] [class] [class1 class2] [class1 class2 & others]), :doc "Function which normalizes and combines class values to a string\n\nReagent allows classes to be defined as:\n- Strings\n- Named objects (Symbols or Keywords)\n- Collections of previous types", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "rswap!", :file "reagent/core.cljs", :line 350, :arglists ([a f & args]), :doc "Swaps the value of a to be `(apply f current-value-of-atom args)`.\n\nrswap! works like swap!, except that recursive calls to rswap! on\nthe same atom are allowed – and it always returns nil.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "custom-prop-name-cache", :file "reagent/impl/template.cljs", :line 74, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "println", :file "reagent/debug.clj", :line 35, :arglists ([& forms]), :doc "Print string with console.log\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "class-names", :file "reagent/impl/util.cljs", :line 123, :arglists ([] [class] [a b] [a b & rst]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "render", :file "reagent/dom.cljs", :line 27, :arglists ([comp container] [comp container callback]), :doc "Render a Reagent component into the DOM. The first argument may be\neither a vector (using Reagent's Hiccup syntax), or a React element.\nThe second argument should be a DOM node.\n\nOptionally takes a callback that is called when the component is in place.\n\nReturns the mounted component instance.", :type :var, :namespace "reagent.dom", :platform "cljs"} {:name "IDisposable", :file "reagent/ratom.cljs", :line 346, :type :protocol, :members ({:name add-on-dispose!, :arglists ([this f]), :type :var} {:name dispose!, :arglists ([this]), :type :var}), :namespace "reagent.ratom", :platform "cljs"} {:name "extract-children", :file "reagent/impl/component.cljs", :line 29, :arglists ([v]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "make-element", :file "reagent/impl/template.cljs", :line 416, :arglists ([argv component jsprops first-child]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "fake-raf", :file "reagent/impl/batching.cljs", :line 13, :arglists ([f]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "vec-to-elem", :file "reagent/impl/template.cljs", :line 350, :arglists ([v]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "RenderQueue", :file "reagent/impl/batching.cljs", :line 53, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "has-console", :file "reagent/debug.cljs", :line 4, :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "time", :file "reagent/debug.clj", :line 66, :arglists ([& forms]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "cached-custom-prop-name", :file "reagent/impl/template.cljs", :line 76, :arglists ([k]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "prop-name-cache", :file "reagent/impl/template.cljs", :line 36, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "named?", :file "reagent/impl/util.cljs", :line 119, :arglists ([x]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "as-element", :file "reagent/impl/component.cljs", :line 84, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "PartialFn", :file "reagent/impl/util.cljs", :line 61, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "wrap", :file "reagent/core.cljs", :line 286, :arglists ([value reset-fn & args]), :doc "Provide a combination of value and callback, that looks like an atom.\n\nThe first argument can be any value, that will be returned when the\nresult is deref'ed.\n\nThe second argument should be a function, that is called with the\noptional extra arguments provided to wrap, and the new value of the\nresulting 'atom'.\n\nUse for example like this:\n\n```cljs\n(wrap (:foo @state)\n      swap! state assoc :foo)\n```\n\nProbably useful only for passing to child components.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "dev?", :file "reagent/debug.clj", :line 61, :arglists ([]), :doc "True if assertions are enabled.\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "adapt-react-class", :file "reagent/core.cljs", :line 52, :arglists ([c]), :doc "Returns an adapter for a native React class, that may be used\njust like a Reagent component function or class in Hiccup forms.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "props-argv", :file "reagent/impl/component.cljs", :line 35, :arglists ([c p]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "get-argv", :file "reagent/impl/component.cljs", :line 40, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "get-children", :file "reagent/impl/component.cljs", :line 49, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "tag-name-cache", :file "reagent/impl/template.cljs", :line 311, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "reaction", :file "reagent/ratom.clj", :line 6, :arglists ([& body]), :type :macro, :namespace "reagent.ratom", :platform "cljs"} {:name "dash-to-prop-name", :file "reagent/impl/util.cljs", :line 30, :arglists ([dashed]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "unmount-component-at-node", :file "reagent/dom.cljs", :line 43, :arglists ([container]), :doc "Remove a component from the given DOM node.\n", :type :var, :namespace "reagent.dom", :platform "cljs"} {:name "RAtom", :file "reagent/ratom.cljs", :line 137, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "assert-callable", :file "reagent/debug.clj", :line 94, :arglists ([value]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "render", :file "reagent/core.cljs", :type :var, :line 67, :deprecated "0.10.0", :arglists ([comp container] [comp container callback]), :doc "Render a Reagent component into the DOM. The first argument may be\neither a vector (using Reagent's Hiccup syntax), or a React element.\nThe second argument should be a DOM node.\n\nOptionally takes a callback that is called when the component is in place.\n\nReturns the mounted component instance.", :namespace "reagent.core", :platform "cljs"} {:name "reactive?", :file "reagent/ratom.cljs", :line 15, :arglists ([]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "with-let", :file "reagent/ratom.clj", :line 18, :arglists ([bindings & body]), :type :macro, :namespace "reagent.ratom", :platform "cljs"} {:name "reagent-component?", :file "reagent/impl/component.cljs", :line 65, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "component-name", :file "reagent/impl/component.cljs", :line 123, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "input-component-set-value", :file "reagent/impl/template.cljs", :line 189, :arglists ([this]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "fn-to-class", :file "reagent/impl/component.cljs", :line 375, :arglists ([f]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "cached-prop-name", :file "reagent/impl/template.cljs", :line 44, :arglists ([k]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "memoize-1", :file "reagent/impl/util.cljs", :line 13, :arglists ([f]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "camelify-map-keys", :file "reagent/impl/component.cljs", :line 269, :arglists ([fun-map]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "mark-rendered", :file "reagent/impl/batching.cljs", :line 113, :arglists ([c]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "capitalize", :file "reagent/impl/util.cljs", :line 25, :arglists ([s]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "do-before-flush", :file "reagent/impl/batching.cljs", :line 116, :arglists ([f]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "kv-conv", :file "reagent/impl/template.cljs", :line 58, :arglists ([o k v]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "prn", :file "reagent/debug.clj", :line 40, :arglists ([& forms]), :doc "Like standard prn, but prints using console.log (so that we get\nnice clickable links to source in modern browsers).", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "wrap-funs", :file "reagent/impl/component.cljs", :line 277, :arglists ([fmap]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "tracking", :file "reagent/debug.cljs", :line 6, :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "set-state", :file "reagent/core.cljs", :line 174, :arglists ([this new-state]), :doc "Merge component state with new-state.\nEquivalent to `(swap! (state-atom this) merge new-state)`", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "HiccupTag", :file "reagent/impl/template.cljs", :line 260, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "dont-camel-case", :file "reagent/impl/util.cljs", :line 23, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "check-derefs", :file "reagent/ratom.cljs", :line 546, :arglists ([f]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "dash-to-method-name", :file "reagent/impl/util.cljs", :line 39, :arglists ([dashed]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "native-element", :file "reagent/impl/template.cljs", :line 320, :arglists ([parsed argv first]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "fragment-element", :file "reagent/impl/template.cljs", :line 297, :arglists ([argv]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "IRunnable", :file "reagent/ratom.cljs", :line 350, :type :protocol, :members ({:name run, :arglists ([this]), :type :var}), :namespace "reagent.ratom", :platform "cljs"} {:name "force-update", :file "reagent/core.cljs", :line 182, :arglists ([this] [this deep]), :doc "Force a component to re-render immediately.\n\nIf the second argument is true, child components will also be\nre-rendered, even is their arguments have not changed.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "warn", :file "reagent/debug.clj", :line 11, :arglists ([& forms]), :doc "Print with console.warn.\n", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "extract-props", :file "reagent/impl/component.cljs", :line 25, :arglists ([v]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "Reaction", :file "reagent/ratom.cljs", :line 365, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "cache-get", :file "reagent/impl/template.cljs", :line 40, :arglists ([o k]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "dispose!", :file "reagent/core.cljs", :line 281, :arglists ([x]), :doc "Stop the result of track! from updating.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "input-spec", :file "reagent/impl/template.cljs", :line 241, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "convert-prop-value", :file "reagent/impl/template.cljs", :line 62, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "next-tick", :file "reagent/core.cljs", :line 372, :arglists ([f]), :doc "Run f using requestAnimationFrame or equivalent.\n\nf will be called just before components are rendered.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "convert-props", :file "reagent/impl/template.cljs", :line 114, :arglists ([props id-class]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "comp-name", :file "reagent/impl/component.cljs", :line 126, :arglists ([]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "schedule", :file "reagent/impl/batching.cljs", :line 122, :arglists ([]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "get-key", :file "reagent/impl/template.cljs", :line 280, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "cached-parse", :file "reagent/impl/template.cljs", :line 313, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "atom", :file "reagent/core.cljs", :line 250, :arglists ([x] [x & rest]), :doc "Like clojure.core/atom, except that it keeps track of derefs.\nReagent components that derefs one of these are automatically\nre-rendered.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "warnings", :file "reagent/debug.cljs", :line 8, :type :var, :namespace "reagent.debug", :platform "cljs"} {:name "warn-unless", :file "reagent/debug.clj", :line 20, :arglists ([cond & forms]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "reactify-component", :file "reagent/impl/component.cljs", :line 396, :arglists ([comp]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "cljsify", :file "reagent/impl/component.cljs", :line 306, :arglists ([body]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "flush", :file "reagent/core.cljs", :line 240, :arglists ([]), :doc "Render dirty components immediately.\n\nNote that this may not work in event handlers, since React.js does\nbatching of updates there.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "is-client", :file "reagent/core.cljs", :line 15, :type :var, :namespace "reagent.core", :platform "cljs"} {:name "custom-wrapper", :file "reagent/impl/component.cljs", :line 168, :arglists ([key f]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "input-unmount", :file "reagent/impl/template.cljs", :line 229, :arglists ([this]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "wrap-render", :file "reagent/impl/component.cljs", :line 89, :arglists ([c]), :doc "Calls the render function of the component `c`.  If result `res` evaluates to a:\n1) Vector (form-1 component) - Treats the vector as hiccup and returns\n   a react element with a render function based on that hiccup\n2) Function (form-2 component) - updates the render function to `res` i.e. the internal function\n   and calls wrap-render again (`recur`), until the render result doesn't evaluate to a function.\n3) Anything else - Returns the result of evaluating `c`", :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "obligatory", :file "reagent/impl/component.cljs", :line 264, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "make-reaction", :file "reagent/ratom.cljs", :line 515, :arglists ([f & {:keys [auto-run on-set on-dispose]}]), :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "*non-reactive*", :file "reagent/impl/util.cljs", :line 7, :dynamic true, :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "input-component?", :file "reagent/impl/template.cljs", :line 232, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "parse-tag", :file "reagent/impl/template.cljs", :line 262, :arglists ([hiccup-tag]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "assert-some", :file "reagent/debug.clj", :line 76, :arglists ([value tag]), :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "flush", :file "reagent/impl/batching.cljs", :line 102, :arglists ([]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "force-update-all", :file "reagent/core.cljs", :type :var, :line 87, :deprecated "0.10.0", :arglists ([]), :doc "Force re-rendering of all mounted Reagent components. This is\nprobably only useful in a development environment, when you want to\nupdate components in response to some dynamic changes to code.\n\nNote that force-update-all may not update root components. This\nhappens if a component 'foo' is mounted with `(render [foo])` (since\nfunctions are passed by value, and not by reference, in\nClojureScript). To get around this you'll have to introduce a layer\nof indirection, for example by using `(render [#'foo])` instead.", :namespace "reagent.core", :platform "cljs"} {:name "next-tick", :file "reagent/impl/batching.cljs", :line 16, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "render-to-static-markup", :file "reagent/dom/server.cljs", :line 14, :arglists ([component]), :doc "Turns a component into an HTML string, without data-react-id attributes, etc.\n", :type :var, :namespace "reagent.dom.server", :platform "cljs"} {:name "make-partial-fn", :file "reagent/impl/util.cljs", :line 116, :arglists ([f args]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "flush-after-render", :file "reagent/impl/batching.cljs", :line 105, :arglists ([]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "input-render-setup", :file "reagent/impl/template.cljs", :line 208, :arglists ([this jsprops]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "merge-props", :file "reagent/impl/util.cljs", :line 160, :arglists ([] [p] [p1 p2] [p1 p2 & ps]), :type :var, :namespace "reagent.impl.util", :platform "cljs"} {:name "unchecked-aset", :file "reagent/interop.clj", :line 14, :arglists ([array idx val] [array idx idx2 & idxv]), :type :macro, :namespace "reagent.interop", :platform "cljs"} {:name "get-wrapper", :file "reagent/impl/component.cljs", :line 256, :arglists ([key f]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "reagent-input-class", :file "reagent/impl/template.cljs", :line 237, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "Track", :file "reagent/ratom.cljs", :line 216, :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "these-inputs-have-selection-api", :file "reagent/impl/template.cljs", :line 131, :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "*current-component*", :file "reagent/impl/component.cljs", :line 9, :dynamic true, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "convert-custom-prop-value", :file "reagent/impl/template.cljs", :line 89, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "input-handle-change", :file "reagent/impl/template.cljs", :line 199, :arglists ([this on-change e]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "run-in-reaction", :file "reagent/ratom.cljs", :line 527, :arglists ([f obj key run opts]), :doc "Evaluates `f` and returns the result.  If `f` calls `deref` on any ratoms,\ncreates a new Reaction that watches those atoms and calls `run` whenever\nany of those watched ratoms change.  Also, the new reaction is added to\nlist of 'watches' of each of the ratoms. The `run` parameter is a function\nthat should expect one argument.  It is passed `obj` when run.  The `opts`\nare any options accepted by a Reaction and will be set on the newly created\nReaction. Sets the newly created Reaction to the `key` on `obj`.", :type :var, :namespace "reagent.ratom", :platform "cljs"} {:name "set-id-class", :file "reagent/impl/template.cljs", :line 98, :arglists ([props id-class]), :doc "Takes the id and class from tag keyword, and adds them to the\nother props. Parsed tag is JS object with :id and :class properties.", :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "do-render", :file "reagent/impl/component.cljs", :line 135, :arglists ([c]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "dbg", :file "reagent/debug.clj", :line 46, :arglists ([x]), :doc "Useful debugging macro that prints the source and value of x,\nas well as package name and line number. Returns x.", :type :macro, :namespace "reagent.debug", :platform "cljs"} {:name "js-val?", :file "reagent/impl/template.cljs", :line 53, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "run!", :file "reagent/ratom.clj", :line 10, :arglists ([& body]), :doc "Runs body immediately, and runs again whenever atoms deferenced in the body change. Body should side effect.\n", :type :macro, :namespace "reagent.ratom", :platform "cljs"} {:name "ratom-flush", :file "reagent/impl/batching.cljs", :line 42, :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "rat-opts", :file "reagent/impl/component.cljs", :line 153, :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "reag-element", :file "reagent/impl/template.cljs", :line 289, :arglists ([tag v]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "as-element", :file "reagent/core.cljs", :line 46, :arglists ([form]), :doc "Turns a vector of Hiccup syntax into a React element. Returns form\nunchanged if it is not a vector.", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "render-to-string", :file "reagent/dom/server.cljs", :line 7, :arglists ([component]), :doc "Turns a component into an HTML string.\n", :type :var, :namespace "reagent.dom.server", :platform "cljs"} {:name "str-coll", :file "reagent/impl/template.cljs", :line 336, :arglists ([coll]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "state-atom", :file "reagent/core.cljs", :line 153, :arglists ([this]), :doc "Returns an atom containing a components state.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "map-to-js", :file "reagent/impl/component.cljs", :line 300, :arglists ([m]), :type :var, :namespace "reagent.impl.component", :platform "cljs"} {:name "children", :file "reagent/core.cljs", :line 200, :arglists ([this]), :doc "Returns the children passed to a component.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "hiccup-tag?", :file "reagent/impl/template.cljs", :line 24, :arglists ([x]), :type :var, :namespace "reagent.impl.template", :platform "cljs"} {:name "queue-render", :file "reagent/impl/batching.cljs", :line 108, :arglists ([c]), :type :var, :namespace "reagent.impl.batching", :platform "cljs"} {:name "props", :file "reagent/core.cljs", :line 194, :arglists ([this]), :doc "Returns the props passed to a component.\n", :type :var, :namespace "reagent.core", :platform "cljs"} {:name "dash-to-method-name", :file "reagent/impl/component.cljs", :line 267, :type :var, :namespace "reagent.impl.component", :platform "cljs"}}, :version {:jar {}, :config {:cljdoc.api/platforms #{"cljs"}, :cljdoc.doc/tree [["Documentation index" {:file "doc/README.md"}] ["Tutorials" {} ["Using Hiccup to Describe HTML" {:file "doc/UsingHiccupToDescribeHTML.md"}] ["Creating Reagent Components" {:file "doc/CreatingReagentComponents.md"}] ["Using [square brackets] instead of (parentheses)" {:file "doc/UsingSquareBracketsInsteadOfParens.md"}] ["When do components update?" {:file "doc/WhenDoComponentsUpdate.md"}] ["[WIP] Managing State: atoms, cursors, Reactions, and tracking" {:file "doc/ManagingState.md"}] ["Batching and Timing: How Reagent Renders Changes to Application State" {:file "doc/BatchingAndTiming.md"}] ["Interop with React" {:file "doc/InteropWithReact.md"}] ["React Features" {:file "doc/ReactFeatures.md"}] ["Controlled Inputs" {:file "doc/ControlledInputs.md"}]] ["Frequently Asked Questions" {} ["Why isn't my Component re-rendering?" {:file "doc/FAQ/ComponentNotRerendering.md"}] ["How do I use React's \"refs\"" {:file "doc/FAQ/UsingRefs.md"}] ["How can I use an entity like \"nbsp\"?" {:file "doc/FAQ/UsingAnEntity.md"}] ["Why is my attribute (like autoFocus) missing?" {:file "doc/FAQ/MyAttributesAreMissing.md"}] ["How can I use React's dangerouslySetInnerHTML?" {:file "doc/FAQ/dangerouslySetInnerHTML.md"}] ["Reagent doesn't work after updating dependencies" {:file "doc/FAQ/CljsjsReactProblems.md"}]] ["Examples" {} ["Material-UI v1" {:file "doc/examples/material-ui.md"}]] ["Other" {} ["0.8 Upgrade guide" {:file "doc/0.8-upgrade.md"}] ["Development guide" {:file "doc/development.md"}]]]}, :scm {:rev "84692f8633b4acde47f2f44d8c55b2ddffe7da0f", :files {"test/reagent/impl/util_test.cljs" "918cec569e706ff15a6dcdad507302de3461c6b036a68bcf973e42a437fe8435", "CONTRIBUTING.md" "d02c4dca781eb2bbf61de0f30680c44600cfb1151d987c20c3917f6d414316e6", "test/reagent/impl/template_test.cljs" "7f5dbf6188cbd3edb1d8394ddef647400a929940a6716b9eb33b8c34906d0507", "demo/reagentdemo/news/binaryclock.cljs" "b81b254be620c688c0a60d7d736206d7c0ed7084e2dcb11bf0c5a13846304db9", "examples/material-ui/src/example/core.cljs" "fdef13d109fb7b14a887b75712c6ea4f03535e1021eecfc7b1fd26836bd6d3d8", "examples/geometry/src/geometry/geometry.cljs" "bfd23894083859613463253404db72b178f82ed9e9355f92303628b96d69eef5", "site/public/index.html" "86a587ca917f9afcbf3de5e9f125455cbe064f67e9befa5cfe93f69cbc52b0aa", "examples/todomvc/project.clj" "d799d7bb560980718c9778fa7c25584013dd25bb4634c890f286b104a003f1ed", "doc/development.md" "b48803500a1348516493bdc5f7dde1fdd875def50d10f40f55460d5cf0f6b1ac", "test/runners/karma.conf.js" "475ae26b2ac118a58db59b4c72e8b20191102c8e2b817c8f1feb9d5c9bd66256", "prerender/sitetools/prerender.cljs" "d9d498834cc9b7b0c7d40a776c0bd63ab11dc2c76971dd627db25f1540545226", "doc/WhenDoComponentsUpdate.md" "d560324e7fb7a8137bcd58c34968bd4a00e08acc88e0f9ae1d54cf45948f4630", "examples/material-ui/project.clj" "97b388fccc5ee8a3c5f935f4f966dd6d2d8df6f251b3ca4e99ac4c89137bf63b", "doc/FAQ/dangerouslySetInnerHTML.md" "b62052d1174d3cd17b2fbf371691acc6e852d46169a2ad77fdca97a18eaa0bad", "src/reagent/dom/server.cljs" "14b3717d7d86ffe2710b9add054b8495811e500d05a2b37c7a36938e4455f61c", "README.md" "27c58cfdbf36f99b16c7986fa5878b5fd77b4b3f11949bdd93615a97f7b0b624", "test-environments/node-cljsjs/test.sh" "c4427e3d28e9696de138944cb7760ebbf39a3e3858a6c1364e524c620ce794b2", "doc/FAQ/ComponentNotRerendering.md" "9c4db3eb44ba3df102a260cfe0deca7b2698939628b61d9bbc51e455ce1985d7", "src/reagent/interop.cljs" "71b2aa1157bc3955a9e93623601443886e8f489fb4752b73f8d575546481f6d2", "test-environments/shadow-cljs-prod/karma.conf.js" "ed002cce56bdbfa3c43ea236a4bf6e95422190e12e00994263a4b0ab93951449", "test-environments/browser-cljsjs-prod/test.sh" "63a3cb6ad3b16f672d818573adb4a10567a7c9498bd9931360200ddea6ef130c", "src/reagent/dom.cljs" "5d4319a58b5460c6b852cd94335fdd11b55568a0efb3a371569093f7ddee1fee", ".clj-kondo/config.edn" "ed05861570914d4c4562b4b9952cf71255c027563f8f326d541ce2a953856700", "demo/reagentdemo/news/undodemo.cljs" "4ca28d41094d2f362d876b839d61c019c2ccf16b2d8e5b067e371d415292349b", "demo/reagentdemo/syntax.cljs" "b783c314944e6a464c9716f35ae22e25ada98e1323d2ca8590c3a1d092a493b2", "outsite/public/README.md" "4122db21cb1e8fae8a0d0ef7045ef747934ef7765cdd5e40d4ea66165ff05b5f", "run-tests.sh" "ce2da1b483c2487002ae9601dad3061d725da916458f9301c86b9d26b2a9e81a", "test-environments/node-npm/test.sh" "fed7dca98137f68a1b48c48acddd8a65eb00793bcc6b24ebebbeb87346060b21", "examples/geometry/example.html" "92ae3a29f8971f709ccafe982522d6b0c1f4ef9607ba10d27d91d8f78d9d1c21", "demo/reagentdemo/news/news060.cljs" "33d0cec327fb136c4c3586eff9fa455652684e8c7ac3c8181d879e25f98c09f7", "site/public/css/examples.css" "0231aacce850be92254ed2a828596909cd6751f2173c7b58779dbfc10f46f0ef", "src/reagent/interop.clj" "ecc0a30083fff1abdc1589675d7a459e3144d942e2acc5b082213825c915a624", "test/reagenttest/testratom.cljs" "474898fc6393def56660a36f1bef29556129d771fe95cd2e1352a1ab59105d78", "demo/reagentdemo/news/news050.cljs" "1994638a0b3c50162658e3608362881ff52c7a0aa04d681ebbf92476869dcd87", "test-environments/browser-npm/test.sh" "f089bde58d22d811c2b02afcf8c4ea0edad7d9a04cbd2e18641a23a0d10f48b5", "examples/todomvc/example.html" "16a4fac83d06d1ffd21b531351d2e269888a6af3a8df37d8b25aaa5aafa4a9c0", "examples/geometry/README.md" "9caf399b2da4a822d585b876291837c7a22f233c6c0524b13528edcb135f4984", "test/reagenttest/testcursor.cljs" "7cff4abe2cdac51ff2395b5a9197b6d8434549a155f68628bf73476a8743c6f0", "LICENSE" "20b9887a7a6b93a6c336b5f18e51b47a610cd5c335ce7a97604d2ea20ec93692", "doc/UsingHiccupToDescribeHTML.md" "20b86f78c5e30e77f7fa8e6a9a50a36c451215ae8032ac965a5c36f046972e3e", "src/reagent/impl/batching.cljs" "ed5dba32c599fe01e9a566757aa963be81aba6101fc187235751d8f4f359ac52", "test-environments/browser-cljsjs/test.sh" "20eeeec9ce5328f39017764faa2f5c69e4e3fe30756cf8e55d51bc098bdcbfef", "demo/reagentdemo/news/news060rc.cljs" "fe882a58aac3fc951c39c8b111394cc1ed4c6fb4d8bf58a4e0925e76208cddd1", "logo.png" "3558cfa77431c0ec79945b702aabbba332c651502a56a08183b4916a58fab42a", "examples/geometry/src/geometry/core.cljs" "c811c5fcd586d4eaed23ecfca9e848bf193591fc0963a0771f21b2014f9af7a5", "build-example-site.sh" "be0b18c256e06b43a5f6d2dd8cf79683d8a432c0b94d8562f7d9984a188f1d3f", "doc/README.md" "e37e59305c0a1c8383fb5d80f8f72b843bf6cb56daf7a768d60261f052ef2ac4", "src/reagent/impl/template.cljs" "42569fe39a3955f54c98ca2a4f0cb017818e4f42875322f4a8bc25f31c59ef09", "logo.svg" "8d661d0e8bb9753cff4350038bc581fad6463443b3a6588b79cfe983fdcca730", "demo/sitetools/core.cljs" "1e8c21701cfc1d70ba182e5715408f215a4a1f1f7a16d2a6b60efdd6792a4011", "doc/examples/material-ui.md" "65e2c7be91713ad5233e45f37c502493187bd62d61d5e176263dc0d2e3ecf661", "src/reagent/impl/component.cljs" "fafdaa4e376852d947def26f32fe4cd9d2ccc46468804aa6d92f88464e826e24", "examples/simple/example.css" "5d677e179d5a6a714159d775627e8bf95afea0c3cf90b97b19abef7ae3e53546", "doc/FAQ/UsingRefs.md" "2e22318ef773f9fa09f895820db67a24d33d695f8fcbd4c7ce4e15ce0cbf6431", "examples/react-sortable-hoc/src/example/core.cljs" "67f1b84d38f327e80fa1b6e81b9ed4684673b2f5a3ef2c895a78a2f3621e7d93", "demo/reagentdemo/syntax.clj" "f693ded9403a5622769cc3053e0964370f7d7170f782f56d10e49fae67fbbb58", "demo/reagentdemo/news/anyargs.cljs" "46de4703c812b58de4338043fb883e9e3efb580925bf8c186c385a17405cc674", "examples/todomvc/src/todomvc/core.cljs" "72a732a964abbae173df086624c90ac0dd4bda0aca27bb3ef0a073f27baad023", "demo/reagentdemo/news/news051.cljs" "87f94c7438346a0c406ebddacce0e17d5881a20d0b81a4cb612b06ff363e02ca", "doc/ControlledInputs.md" "005d84263951521513113e648c8be090064990ba1618da6927a9f4ce5429a3a5", "demo/reagentdemo/news/async.cljs" "a977489faae6a25bb28592729242e24f4f2e95b85649f03b0f835a1e4ac3577d", "doc/InteropWithReact.md" "0b929f27ca0eb26ec8462c5089206766e1074a1a0860ffbba1087a7e07ca0b21", "doc/examples/smooth-ui.md" "8fafe6899ac96932828c02842bdfc4ac6d75c5a3ed7493d0bb5220989a4777fc", "site/public/css/main.css" "a633b72918c68e2ce026feca6c9144d48cb8e3f52474c606cf281f7803150bae", "demo/reagentdemo/intro.cljs" "2aafe6ea18dac1b5c1207f230cf71c9eb5bc86fade6956b621d97f7cb29de4cb", "test/reagenttest/utils.cljs" "1907e7aeef4e70fabf724376ede503e59d8731549a9e6b4d1140f978e4192b05", "src/reagent/core.cljs" "2c8fc0b9d7bbda8b01fdd77625b70bd211d45d1be86002451388d6b284284e7f", "examples/todomvc/todos.css" "89c78c12ae928c5261007a1edf7434f10140e5856628c64bc2208b4abe9f67f5", "demo/reagentdemo/prod.cljs" "2f23df1156d809c734fa445c5ff6955a865f490727c43b26de6d8f76969a0a30", "demo/reagentdemo/core.cljs" "e9fd2e8f1192bb34b3b64844b7ca238ad143cee72ee05a03769db987bf7dfd7a", "demo/reagentdemo/news/news060release.cljs" "6745bc9a9ba2cd03c6d153052056b68e8e446c8f58f7be3476890e9d72ee3f9e", "build-docs.sh" "e95267d6f58c54cbbcdd51ea1a794169880d42eebe9f97ebd71bfa51d5ca2696", "demo/reagentdemo/news.cljs" "4ea9f4c0f16577741640d325bb01b7f266f668d1719a62ee61212be5d2937adb", "test/reagenttest/testwrap.cljs" "5a63be35d223b5435924408f17a7eb6e8bd06fd5a762f9ade1edb902a1cbc25a", "lib/modules.js" "414bb2220c1ca75e3e66a6e3b76a895d95e7d89a2ceb137669fc8d217ce40ee1", "examples/react-sortable-hoc/resources/public/index.html" "3ee2a32bccae6856df5c6343bcb230408f44f783f83403308662586138189a03", "demo/reagentdemo/common.cljs" "019f30ef7c30baa04a13f2f9a02356453b281facf3cd788c0ec80bfc099ea9e7", "examples/geometry/src/geometry/components.cljs" "ee6b3f833f9236e2d95d347cdeb1e46e520fb98fd57ac0b6612b322e1a160be0", "examples/material-ui/resources/public/index.html" "3ee2a32bccae6856df5c6343bcb230408f44f783f83403308662586138189a03", "demo/reagentdemo/news/news061.cljs" "540ba5dbab1aafc66dae091844f600f4099b45b83180cd0b274616c300b04561", ".gitignore" "c41145a00d92d4c69f8c5f7e3a5c427aa7606a0637251703d9dee329d0713cae", "package.json" "5da40d666bd943281a89fafdf3425360cbc418733b2a443c9176692507aa4a9f", "src/reagent/impl/util.cljs" "9139c9970b0bce520d430ce37866e19d1ab734b92ce253909fdb8877ba3e9131", "doc/CreatingReagentComponents.md" "bfa86797cfa7f50ea479d80d5abe83f29321cd3e48137eba73cded48b3e92def", "demo/reagentdemo/dev.cljs" "685fb36cfd1f50750547268f56322d6e059ef1f37ec17f4e89e3932c29863721", "examples/todomvc/README.md" "9caf399b2da4a822d585b876291837c7a22f233c6c0524b13528edcb135f4984", "doc/ReactFeatures.md" "7307b8a2974f883f966670e1cfcd4ed3c06f375c3c034d80468cb6598da98c0c", "test/reagenttest/testreagent.cljs" "fe9ab66832e0714780f82b5b85074fcc47038c2435750675b5d8c4f8a1d129e4", "prepare-tests.sh" "8b9b6dec3c9415b662b3c0a5755de6d5e8a48a16d47155b49e450f5d856a1319", "src/deps.cljs" "b25252a403850b32a1ba612400df4f6e7e08578295bd8221f03513d4c19fb30a", "doc/cljdoc.edn" "a2fa24e1bac5bbfe97316faf1ca3dc6e0d89f60ff1776137d02c5028b630ea5a", "examples/simple/project.clj" "c23d379c4b5f9cdc6b716d4d8ad382bd792985264163bce35a6220d62eedaa0c", "CHANGELOG.md" "563464dbb15c3a52e1db93c831bdcec78766a190e1fc0e184626124a14660650", "doc/FAQ/UsingAnEntity.md" "7b5832a6c2a8f164d9dc626a968513066a944946c607c425cb910ee1780353ab", "src/reagent/ratom.clj" "4b89d2e9ddb7a9542bbefad60c26910e5ac43aa4ad89adb997a3584dc9ce7c34", "doc/UsingSquareBracketsInsteadOfParens.md" "6e4a1fefeb6af9d99cd8c87328c70a163630da17a25604674c5d49bcd35f951a", "circle.yml" "773e3696044f6cd5fd05f1a2970c27b2ce650a2969e1a52f06725d614e02374c", "doc/BatchingAndTiming.md" "74d32a3b1df0d985f47a8e5d333edd9be1a54c180483e3b0bd08d9185d3343d8", "examples/geometry/project.clj" "7b6c3f0a9c1693438861e9efbcb660370a21241716e53a4130d1f031b627adea", "test/reagenttest/testratomasync.cljs" "7cd7b77907984aa219c68063c9228640b89d9f09fd95909af3fc72eb12fad130", "src/reagent/debug.cljs" "a98281f34d1e0e3adbf77978c8be62a90fd2d490e270c21cef1635f96393acbd", "doc/ManagingState.md" "d72d5ba987e6d4d057ddc0710fa2625aaf6b7db6af2e219ede9a01ce7e983f83", "project.clj" "fb9481039c8f6e32d6641751e7784e20c18156d60f03b10a47695b4e5e76b1e9", "examples/simple/README.md" "9caf399b2da4a822d585b876291837c7a22f233c6c0524b13528edcb135f4984", "examples/simple/example.html" "bab6882fb0734e2c11586aa023c5de0a05e651cbec39ad64fb721373558f9f74", "src/reagent/ratom.cljs" "c8a89a0025887732a884accf4b1a44e7612c5b464b31b2b95da0f93199379a41", "test/reagenttest/testtrack.cljs" "46165024cc3407db33f49648de41aa38616819d9d0014c349220f40728bcb797", "doc/0.8-upgrade.md" "172f43d03ec7ee51b5cbd92f985c08d89756410f8ea765bc7100c74476380444", "demo/reagentdemo/news/clockpost.cljs" "71d64e635022fe9de17a2acb5a0253b8bbf5707678c02547732ab59d0571658e", "test/reagenttest/runtests.cljs" "7b8d271b5053b7e0e0d78d47eb28233578ddf907d52536e285bee13137347717", "test-environments/shadow-cljs-prod/test.sh" "c3476d3672be99ba367eb459bb3ab72c783baff380b960ea7c5a810ea7e162b2", "test-environments/browser-npm-prod/test.sh" "f0485cc0a736235e7e33a4ac3424d258ab79ba3e588c17ad507ee818f477592a", "examples/simple/src/simpleexample/core.cljs" "5f21b6247d3f6dc09537388291b52f1961d0e9d004377eb078e3afc2de41b0f5", "src/reagent/core.clj" "e915e4c9a4e22fe0e39488579816f872d6a1705581af294c791738d5746b00a2", "examples/geometry/example.css" "4aaea212ca279d3bfdfa22f109ca0b802cccd4b1b38d5280ea1a1747ce929142", "examples/react-sortable-hoc/project.clj" "261e8af16fe450e93dd9a8fcc27aecc84ab1426d67807c1b3914bcd640526446", "test/reagenttest/testwithlet.cljs" "3fb76aa4b958c9ee1453794297bf0c2e9e9b3eaf08c8e5d486ca472984e36150", "examples/geometry/devsrc/geometry/dev.cljs" "3ef548b16b70106bb4cb32000cfd01e8232a42608cf3ae8496411e49f02294bb", "doc/FAQ/MyAttributesAreMissing.md" "c59e55d61f38c7c3107798d0dbea4dfa29b6115e12466397d44d0f58bc57b8d1", ".github/issue_template.md" "2419c2962930982b4347122a84f67a79837c5bfc32a22088c5e84a503dd4bb1a", "package-lock.json" "ba0376a03def23615b8c5df1a415fcb423f875384e8aae03db076c2f8073c416", "doc/FAQ/CljsjsReactProblems.md" "92570dbfe3b911d95ca6114f8a9bc0ebb54b76985576950cdffd56a5b32c0b26", "src/reagent/debug.clj" "7a2edc111f2bb9b9a62f32cc8066fd91aa842d76125e66068f1b5cd5860fa9b0", "shadow-cljs.edn" "3e6ebc537e820abed44f8771e38670546856bab391d21b4b676f24335960fa53"}, :branch "master", :tag {:name "v0.10.0", :commit "84692f8633b4acde47f2f44d8c55b2ddffe7da0f", :sha "540a21a6eb672cf6d27a7493cf15bd6e037e5d0a"}, :commit "84692f8633b4acde47f2f44d8c55b2ddffe7da0f", :url "https://github.com/reagent-project/reagent"}, :doc [{:title "Documentation index", :attrs {:cljdoc.doc/source-file "doc/README.md", :cljdoc/markdown "## Tutorials\n\n1. [Using Hiccup to Describe HTML](UsingHiccupToDescribeHTML.md)\n2. [Creating Reagent Components](CreatingReagentComponents.md)\n3. [Using [square brackets] instead of (parentheses)](UsingSquareBracketsInsteadOfParens.md)\n4. [When do components update?](WhenDoComponentsUpdate.md)\n5. [[WIP] Managing State: atoms, cursors, Reactions, and tracking](ManagingState.md)\n6. [Batching and Timing: How Reagent Renders Changes to Application State](BatchingAndTiming.md)\n7. [Interop with React](InteropWithReact.md)\n8. [React Features](ReactFeatures.md) and how to use them in Reagent\n\nAlso:\n  * [purelyfunctional.tv ](https://purelyfunctional.tv/guide/reagent/) - an excellent, written tutorial\n  * [Reagent Deep Dive Series by Timothy Pratley](http://timothypratley.blogspot.com.au/p/p.html) - a four part series\n  * [Reagent Mysteries series by Paulus Esterhazy](https://presumably.de/) - a four part series\n  * [Props, Children & Component Lifecycle](https://www.martinklepsch.org/posts/props-children-and-component-lifecycle-in-reagent.html) by Martin Klepsch\n  * [Using Stateful JS Components - like D3](https://github.com/Day8/re-frame/blob/master/docs/Using-Stateful-JS-Components.md)  (external link)\n\n## Commercial Videos Series\n\n  * [Learn Reagent Free](https://www.jacekschae.com/learn-reagent-free/tycit?coupon=REAGENT)\n  * [Learn Reagent Pro](https://www.jacekschae.com/learn-reagent-pro/tycit?coupon=REAGENT) (Affiliate link, $30 discount)\n  * [Learn Re-frame](https://www.jacekschae.com/learn-re-frame-pro?coupon=REAGENT) (Affiliate link, early access)\n  * [purelyfunctional.tv ](https://purelyfunctional.tv/guide/reagent/)\n  * [Lambda Island Videos](https://lambdaisland.com/collections/react-reagent-re-frame)\n\n## Frequently Asked Questions\n\n1. [Why isn't my Component re-rendering?](FAQ/ComponentNotRerendering.md)\n1. [How do I use React's \"refs\"](FAQ/UsingRefs.md)\n2. [How can I use an entity like \"nbsp\"?](FAQ/UsingAnEntity.md)\n3. [Why is my attribute (like autoFocus) missing?](FAQ/MyAttributesAreMissing.md)\n4. [How can I use React's dangerouslySetInnerHTML?](FAQ/dangerouslySetInnerHTML.md)\n5. [Reagent doesn't work after updating dependencies](FAQ/CljsjsReactProblems.md)\n5. [How do I force Component re-creation?](https://groups.google.com/forum/#!topic/reagent-project/tNY4gzk7TUY) (external link)\n6. [How do I access \"props\" in lifecycle methods?](http://nils-blum-oeste.net/clojurescripts-reagent-using-props-in-lifecycle-hooks/) (external link)\n\n## Examples\n\n- [MaterialUI v1 with working TextField](examples/material-ui.md), React interop example\n- [React-sortable-hoc](../examples/react-sortable-hoc/src/example/core.cljs), React interop example\n\n\n### Want To Add An FAQ?\n\nMany Thanks!! We'd like that:\n1. As a base, just use the structure from one of the existing FAQs files\n2. Give us a PR which includes your new file AND a change to this README so your entry is listed.\n\n#### Misc Docs\n\n - [0.8-upgrade](0.8-upgrade.md)\n - [development](development.md)\n", :cljdoc.doc/type :cljdoc/markdown, :slug "documentation-index", :cljdoc.doc/contributors ("Juho Teperi" "alex argunov")}} {:title "Tutorials", :attrs {:slug "tutorials"}, :children [{:title "Using Hiccup to Describe HTML", :attrs {:cljdoc.doc/source-file "doc/UsingHiccupToDescribeHTML.md", :cljdoc/markdown "# Using Hiccup to Describe HTML\n\nReagent uses a datastructure known as Hiccup to describe HTML. Hiccup describes HTML elements and user-defined components as a nested ClojureScript vector:\n\n```clojure\n[:div {:class \"parent\"}\n  [:p {:id \"child-one\"} \"I'm first child element.\"]\n  [:p \"I'm the second child element.\"]]\n```\n\nAs described below, reagent provides a number of extensions and conveniences to Hiccup, but the general rules of Hiccup are as follows:\n\n1. The first element is either a keyword or a symbol\n   * If it is a keyword, the element is an HTML element where `(name keyword)` is the tag of the HTML element.\n   * If it is a symbol, reagent will treat the vector as a component, as described in the next section.\n2. If the second element is a map, it represents the attributes to the element. The attribute map may be omitted.\n3. Any additional elements must either be Hiccup vectors representing child nodes or string literals representing child text nodes.\n\n## Special treatment of `nil` child nodes\n\nReagent and React ignore nil nodes, which allow conditional logic in Hiccup forms:\n\n```clojure\n(defn my-div [child?]\n  [:div\n    \"Parent Element\"\n    (when child? [:div \"Child element\"])])\n```\n\nIn this example `(my-div false)` will evaluate to `[:div \"Parent Element\" nil]`, which reagent will simply treat the same as `[:div \"Parent Element\"]`.\n\n## Special interpretation of `style` attribute\n\nThe `:style` attribute can be written a string or as a map. The following two are equivalent:\n\n```clojure\n[:div {:style \"color: red; font-weight: bold\"} \"Alert\"]\n[:div {:style {:color \"red\"\n               :font-weight \"bold\"}\n      \"Alert\"]\n```\n\nThe map form is the same as [React's style attribute](https://reactjs.org/docs/dom-elements.html#style), except that when using the map form of the style attribute, the keys should be the same as the CSS attribute as shown in the example above (not in camel case as is required JavaScript).\n\n## Special interpretation of `class` attribute\n\nIn JavaScript, `class` is a reserved keyword, so React uses the `className` to specify class attibutes. Reagent just uses `class`.\n\nAs of reagent 0.8.0, the `class` attribute accepts a collection of classes and will remove any nil value:\n\n```clojure\n[:div {:class [\"a-class\" (when active? \"active\") \"b-class\"]}]\n```\n\n## Special notation for id and class\n\nThe id of an element can be indicated with a hash (`#`) after the name of the element.\n\nThis:\n\n```clojure\n[:div#my-id]\n```\n\nis the same as this:\n\n```clojure\n[:div {:id \"my-id\"}]\n```\n\nOne or more classes can be indicated for an element with a `.` and the class-name like this:\n\n```clojure\n[:div.my-class.my-other-class.etc]\n```\n\nwhich is the same as:\n\n```clojure\n[:div {:class [\"my-class\" \"my-other-class\" \"etc\"]}]\n```\n\nSpecial notations for id and classes can be used together. The id must be listed first:\n\n```clojure\n[:div#my-id.my-class.my-other-class]\n```\n\nwhich is the same as:\n\n```clojure\n[:div {:id \"my-id\" :class [\"my-class\" \"my-other-class\"]}]\n```\n\n## Special notation for nested elements\n\nReagent extends standard Hiccup in one way: it is possible to stack elements together by using a `>` character.\n\nThis:\n\n```clojure\n[:div\n  [:p\n    [:b \"Nested Element\"]]]\n```\n\ncan be written as:\n\n```clojure\n[:div>p>b \"Nested Element\"]\n```\n\n## Rendering Hiccup\n\nThe primary entrypoint to the reagent library is `reagent.core/render`.\n\n```clojure\n(ns example\n  (:require [reagent.dom :as rdom]))\n\n(defn render-simple []\n  (rdom/render [:div [:p \"Hello world!\"]]\n    (.-body js/document)))\n```\n\nThis `render` function expects one of two things:\n\n1. A React Element, which will just be passed to React as is.\n2. A ClojureScript vector (i.e., a Hiccup form).\n\nIf it encounters a ClojureScript vector, it will interpret it as Hiccup. Reagent expects one of two things in the first position of the vector:\n\n1. A keyword like `:div` or `:span`, which it will create using React.createElement\n2. A symbol like `my-component`.\n\nIf it's a symbol, then reagent will evaluate a function by that name. Reagent expects one of three things from this function:\n\n1. A Hiccup vector. Reagent creates a React component with the function as its render method and uses the Hiccup vector for the initial render.\n2. A ClojureScript function. Reagent will then create a React component with this inner function as the render method and will then call the inner function for the initial render.\n3. A React component. Reagent will render this using React.createElement. Note, this could be a result of calling `reagent.core/create-class` or it could be a React component you have imported from a JavaScript library.\n\n", :cljdoc.doc/type :cljdoc/markdown, :slug "using-hiccup-to-describe-html", :cljdoc.doc/contributors ("Juho Teperi" "Iyed Bennour" "Mikkel Gravgaard")}} {:title "Creating Reagent Components", :attrs {:cljdoc.doc/source-file "doc/CreatingReagentComponents.md", :cljdoc/markdown "\nIn reagent, the fundamental building block is a `component`.\n\nYour reagent app will typically have many `components` - say, more than 5, but less than 100 - and the overall UI of a reagent app is the stitched-together-output from all of them, each contributing part of the overall HTML, typically in a hierarchical arrangement.\n\nSo they're important and this document describes how to create them.\n\n##### Not An Absolute Introduction\n\nAlthough I stay as basic as possible, this document isn't an introductory tutorial. You should read it *after* \nyou have already digested [The Official Introduction.](http://reagent-project.github.io/)\n\nThis document is useful because it clarifies the basics. It represents an extra bit of learning which might save you from some annoying paper cuts. \n\n##### Contains Lies And Distortions\n\nI care more about providing a useful mental model than bogging down with the full truth. Some white lies and distortions follow.\n\n## The Core Of A Component\n\nAt the core of any `component` is a `render` function.  \n\nA `render` function is the backbone, mandatory part of a `component`.  In fact, as you'll soon see, `components` will often collapse down to be nothing more than a `render` function.\n\nA `render` function turns data into HTML.  Data is supplied via the function parameters, and HTML is the return value.  \n\nData in, HTML out. \n\nMuch of the time, a `render` function will be a `pure function`. If you pass the same data into a `render function`, then it will return the same HTML, and it won't side effect.\n\n*Note*: ultimately, the surrounding reagent/React framework will cause non-pure side-effects because the returned HTML will be spliced into the DOM (mutating global state!), but here, for the moment, all we care about is the pureness of the `render` function itself)\n\n## The Three Ways\n\nThere are three ways to create a `component`. \n\nOrdered by increasing complexity, they are:\n   1. **via a simple render function** - data in as parameters, and it returns HTML.\n   2. **via a function which returns the render function** - the returned function is the render function.\n   3. **via a map of functions, one of which is the render** the rest of the functions are `React lifecycle` methods which allow for some more advanced interventions.\n\n> In all three cases, a `render` function is provided -- that's the backbone. The three creation methods differ only in terms of what they supply over and above a `renderer`.\n\n## Form-1: A Simple Function\n\nIn the simplest case, a `component` collapses down to *only* be a `render` function.  You supply nothing else. \n\nAlthough a simple approach, in my experience, you'll probably use `Form-1` components about 40% of the time, perhaps more.  Simple and useful.\n\nYou just write a regular clojurescript function which takes data as parameters and produces HTML.\n```cljs\n(defn greet\n   [name]                    ;; data coming in is a string\n   [:div \"Hello \" name])     ;; returns Hiccup (HTML)\n```\n\nUntil now, I've talked about `render functions` returning HTML.  That isn't strictly speaking true, of course, as you've seen in the [The Offical Introduction.](http://reagent-project.github.io/)  Instead, renderers always return clojurescript data structures which specify HTML via `Hiccup` format.\n\n`Hiccup` uses vectors to represent HTML elements, and maps to represent an element's attributes.\n\nSo this clojurescript data structure: \n```cljs\n[:div {:style {:background \"blue\"}} \"hello \" \"there\"]\n```\nis simply a clojurescript vector, containing a keyword, map and two strings. But when processed as `hiccup`, this data structure will produce the HTML: \n```\n<div style=\"background:blue;\">hello there</div>\n```\nTo understand more about Hiccup see [this Wiki.](https://github.com/weavejester/hiccup/wiki)\n\n**Rookie mistake**\n\nAt some point, you'll probably try to return sibling HTML elements in a normal cljs vector:\n\n```cljs\n(defn wrong-component\n   [name]              \n   [[:div \"Hello\"] [:div name]])     ;; a vec of 2 [:div] \n```\nThat isn't valid Hiccup and you'll get a slightly baffling error. You'll have to correct this mistake by wrapping the two siblings in a parent [:div]: \n\n```cljs\n(defn right-component\n   [name]              \n   [:div \n     [:div \"Hello\"] \n     [:div name]])     ;; [:div] containing two nested [:divs]\n```\n\nAlternatively, you could return a [React Fragment](https://reactjs.org/docs/fragments.html). In reagent, a React Fragment is created using the `:<>` Hiccup form.\n\n```cljs\n(defn right-component\n   [name]\n   [:<>\n     [:div \"Hello\"]\n     [:div name]])\n```\n\nReferring to the example in [React's documentation](https://reactjs.org/docs/fragments.html), the `Columns` component could be defined in reagent as:\n\n```cljs\n(defn columns\n  []\n  [:<>\n    [:td \"Hello\"]\n    [:td \"World\"]]\n```\n\n## Form-2:  A Function Returning A Function\n\nNow, let's take one step up in complexity.  Sometimes, a component requires:\n  - some setup; or\n  - some local state; and of course\n  - a renderer\n\nThe first two are optional, the last is not.\n\n`Form-2` components are written as an `outer` function which returns an `inner` render.\n\nThis example is taken from the tutorial:\n```cljs\n(defn timer-component []\n  (let [seconds-elapsed (reagent/atom 0)]     ;; setup, and local state\n    (fn []        ;; inner, render function is returned\n      (js/setTimeout #(swap! seconds-elapsed inc) 1000)\n      [:div \"Seconds Elapsed: \" @seconds-elapsed])))\n```\n\nHere `timer-component` is the outer function, and it returns an inner, anonymous render function which closes over the initialised, local state `seconds-elapsed`.\n\nAs before, the job of the render function is to turn data into HTML. That's the backbone. Its just that `Form-2` allows your renderer to close over some state created and initialised by the outer. \n\nIn my experience, you'll use `Form-2` `components` at least 50% of the time. \n\nLet's be quite clear what is going on here:\n  - `timer-component` is **called once** per component instance (and will create the state for that instance) \n  - the render function it returns will potentially be called **many, many times**. In fact, it will be called each time Reagent detects a possible difference in that `component`'s inputs.\n\n**Rookie mistake**\n\nWhen starting out, everyone makes this mistake with the `Form-2` construct: they forget to repeat the parameters in the inner, anonymous render function. \n\n```cljs\n(defn outer \n  [a b c]            ;; <--- parameters\n  ;;  ....\n  (fn [a b c]        ;; <--- forgetting to repeat them, is a rookie mistake\n    [:div\n      (str a b c)]))\n```\n\nSo the rookie mistake is to forget to put in the `[a b c]` parameters on the inner render function. \n\nRemember, `outer` is called once _per component instance_.  Each time, the parameters to `outer` will hold the initial parameter values.  The renderer on the other hand, will be called by Reagent many times and, each time, potentially with alternative parameter values, but unless you repeat the parameters on the renderer it will close over those initial values in `outer`. As a result, the component renderer will stubbornly only ever render the original parameter values, not the updated ones, which can be baffling for a beginner.\n\n\n## Form-3: A Class With Life Cycle Methods\n\nNow, for the final step in complexity.\n\nIn my experience, you'll probably use `Form-3` `components` less than 1% of the time, perhaps only when you want to use a js library like D3 or introduce some hand-crafted optimisations. Maybe.  While you'll ignore `Form-3` components most of the time, when you do need them, you need them bad. So pay attention, because they'll save your bacon one day. \n\nWhile the critical part of a component is its render function, sometimes we need to perform actions at various critical moments in a component's lifetime, like when it is first created, or when its about to be destroyed (removed from the DOM), or when its about to be updated, etc.\n\nWith `Form-3` components, you can nominate `lifecycle methods`. reagent provides a very thin layer over React's own `lifecycle methods`. So, before going on, [read all about React's lifecycle methods.](http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods).  \n\nBecause React's lifecycle methods are object-oriented, they presume the ability to access `this` to obtain the current state of the component.  Accordingly, the signatures of the corresponding Reagent lifecycle methods all take a reference to the reagent component as the first argument.  This reference can be used with `r/props`, `r/children`, and `r/argv` to obtain the current props/arguments.  There are some unexpected details with these functions described below.  You may also find `r/dom-node` helpful, as a common use of form-3 components is to draw into a `canvas` element, and you will need access to the underlying DOM element to do so.\n\nA `Form-3` component definition looks like this:\n```cljs\n(defn my-component\n  [x y z]  \n  (let [some (local but shared state)      ;; <-- closed over by lifecycle fns\n        can  (go here)]   \n     (reagent/create-class                 ;; <-- expects a map of functions \n       {:display-name  \"my-component\"      ;; for more helpful warnings & errors\n\n        :component-did-mount               ;; the name of a lifecycle function\n        (fn [this] \n          (println \"component-did-mount\")) ;; your implementation\n         \n        :component-did-update              ;; the name of a lifecycle function\n        (fn [this old-argv]                ;; reagent provides you the entire \"argv\", not just the \"props\"\n          (let [new-argv (rest (reagent/argv this))]\n            (do-something new-argv old-argv)))\n      \n        ;; other lifecycle funcs can go in here\n     \n\n        :reagent-render        ;; Note:  is not :render\n         (fn [x y z]           ;; remember to repeat parameters\n            [:div (str x \" \" y \" \" z)])})))\n\n(reagent/render\n    [my-component 1 2 3]         ;; pass in x y z\n    (.-body js/document))\n\n;; or as a child in a larger Reagent component\n\n(defn homepage []\n  [:div\n   [:h1 \"Welcome\"]\n   [my-component 1 2 3]]) ;; Be sure to put the Reagent class in square brackets to force it to render!\n```\n\nNote the `old-argv` above in the signature for `component-did-update`.  Many of these Reagent lifecycle method analogs take `prev-argv` or `old-argv` (see the docstring for `reagent/create-class` for a full listing).  These `argv` arguments include the component constructor as the first argument, which should generally be ignored.  This is the same format returned by `(reagent/argv this)`.\n\nAlternately, you can use `(reagent/props this)` and `(reagent/props children)`, but, conceptually, these don't map as clearly to the `argv` concept.  Specifically, the arguments to your render function are actually passed as children (not props) to the underlying React component, **unless the first argument is a map.**   If the first argument is a map, then that map is passed as props, and the rest of the arguments are passed as children.  Using `props` and `children` may read a bit cleaner, but you do need to pay attention to whether you're passing a props map or not.\n\nFinally, note that some React lifecycle methods take `prevState` and `nextState`.  Because Reagent provides its own state management system, there is no access to these parameters in the lifecycle methods.\n\nIt is possible to create `Form-3` `components` using `with-meta`.  However, `with-meta` is a bit clumsy and has no advantages over the above method, but be aware that an alternative way exists to achieve the same outcome.\n\n**Rookie mistake**\n\nIn the code sample above, notice that the renderer function is identified via an odd keyword in the map given to `reagent/create-class`. It's called `:reagent-render` rather than the shorter, more obvious `:render`. \n\nIts a trap to mistakenly use `:render` because you won't get any errors, **except** the function you supply will only ever be called with one parameter, and it won't be the one you expect. [Some details here](https://github.com/reagent-project/reagent/issues/47#issuecomment-61056999).\n\n**Rookie mistake**\n\nWhile you can override `component-should-update` to achieve some performance improvements, you probably shouldn't unless you really, really know what you are doing. Resist the urge. Your current performance is just fine. :-)\n\n**Rookie mistake**\n\nLeaving out the `:display-name` entry.  If you leave it out, Reagent and React have no way of knowing the name of the component causing a problem. As a result, the warnings and errors they generate won't be as informative. \n\n*****************\n\n## Final Note\n\nAbove I used the terms `Form-1`, `Form-2` and `Form-3`, but there's actually only one kind of component. It is just that there's **3 different ways to create a component**. \n\nAt the end of the day, no matter how it is created, a component will end up with a render function and some life-cycle methods.  A component created via `Form-1` has the same basic structure as one created via `Form-3` because underneath they are all [just React components](https://betweentwoparens.com/what-the-reagent-component).\n\n## Appendix A - Lifting the Lid Slightly\n\nHere's some further notes about Reagent's mechanics: \n  1. When you provide a function as the first element of a hiccup vector `[my-func 1 2 3]`, Reagent will say \"hey I have been given a render function\".  That function might be `Form-1` or `Form-2`, but it doesn't know at that point. It just sees a function. \n  2. A render function by itself is not enough to make a React Component.  So, Reagent takes this render function and \"merges\" it with default lifecycle functions to form a React component.  (`Form-3`, of course, allows you to supply your own lifecycle functions)\n  3. Some time later, when Reagent **first** wants to render this component, it will, unsurprisingly, call the render function which you supplied (`my-func` in the snippet above).  It will pass in the \"props\" (parameters) supplied by the rendering parent (`1 2 3` in the snippet above). \n  4. If this first call to the render function returns hiccup (a vector of stuff):\n     - Reagent will just interpret it. So this is what happens in the case of a `Form-1` function.  \n     - If, however, this render function returns another function - ie. it is a `Form-2` outer function returning the inner function - then Reagent knows to replace the Component's render function with the newly returned inner function forever thereafter. So the outer will have been called once but, from that point forward, the inner function will be used for all further rendering. In fact,  Reagent will instantly call the inner function after the outer returns it, because Reagent wants a first rendering (hiccup) for the component. \n  5. So, in the case of `Form-2`, the outer function is called once and once only (with initial props/parameters), and the inner is called at least once (with initial props/parameters), but probably many, many times thereafter. Both will be called with the same arrangement of props/parameters - although the inner render function will see different values in those props/parameters, over time. \n\n## Appendix B - with-let macro\n\nThe `with-let` macro looks just like `let` – but the bindings **only execute once**, and it takes an optional `finally` clause, that runs when the component is no longer rendered. This can be particularly useful because it can prevent the need for a form-2 component in many instances (like creating a local reagent atom in your component).\n\nFor example: here's a component that sets up an event listener for mouse moves, and stops listening when the component is removed.\n\n```clojure\n(defn mouse-pos-comp []\n  (r/with-let [pointer (r/atom nil)\n               handler #(swap! pointer assoc\n                               :x (.-pageX %)\n                               :y (.-pageY %))\n               _ (.addEventListener js/document \"mousemove\" handler)]\n    [:div\n     \"Pointer moved to: \"\n     (str @pointer)]\n    (finally\n      (.removeEventListener js/document \"mousemove\" handler))))\n```\n\nThe same thing could of course be achieved with React lifecycle methods, but that would be a lot more verbose.\n\n`with-let` can also be combined with `track` (and other Reactive contexts). For example, the component above could be written as:\n\n```clojure\n(defn mouse-pos []\n  (r/with-let [pointer (r/atom nil)\n               handler #(swap! pointer assoc\n                               :x (.-pageX %)\n                               :y (.-pageY %))\n               _ (.addEventListener js/document \"mousemove\" handler)]\n    @pointer\n    (finally\n      (.removeEventListener js/document \"mousemove\" handler))))\n\n(defn tracked-pos []\n  [:div\n   \"Pointer moved to: \"\n   (str @(r/track mouse-pos))])\n```\n\nThe `finally` clause will run when mouse-pos is no longer tracked anywhere, i.e in this case when tracked-pos is unmounted.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "creating-reagent-components", :cljdoc.doc/contributors ("Juho Teperi" "Justin Lee" "Dosbol" "Michael Watkins" "tkjone" "Jason" "Alan Thompson")}} {:title "Using [square brackets] instead of (parentheses)", :attrs {:cljdoc.doc/source-file "doc/UsingSquareBracketsInsteadOfParens.md", :cljdoc/markdown "This is a quick tutorial regarding the use of `()` and  `[]` in Reagent renderers.\n\nReagent is a terrific library.  You get going fast and your intuitions about how things should work seem to largely match how stuff actually does work.  It is all a bit magic and easy. \n\nBut, eventually, you'll want to understand how that magic happens. Otherwise ... one day, \nin the peace of a shower, or on that serene bike ride to work, your eyes will flick to \nthe left and you'll wonder \"wait, how **exactly** has this EVER worked for me all this time?\".\nWhich can be followed by other doubts: \"if I don't understand this, what else don't I know?\",\nwhich can lead to \"do I really understand ANYTHING?\".  And, before you know it, you'll be\nover at your parent's house demanding to know if you were adopted.\n\nBest to nip these slippery slopes in the bud (and, equally, to never use mixed metaphors).  Read on ...\n\n## Components\n\nIn an earlier tutorial [Creating Reagent Components](CreatingReagentComponents.md), we saw that the centerpiece of a Reagent/React component is a **renderer** function. Optionally, a Component might have other lifecycle functions, but a renderer function is central and mandatory.\n\nWe also saw that Reagent render functions turn data into hiccup:   `data -> hiccup`\n\n## Meet greet\n\nHere's an example Component:\n```clj\n(defn greet\n  [name]\n  [:div  \"Hello \" name])\n```\n\nNo, wait, what? That's not a Component, that's a function.\n\nYes, indeed it is. And, right there, we have the nub of the issue. \n\nIt is only when `greet` is **used in a particular way**, that it is \"promoted\" to become the renderer for a Reagent Component. Unless you are paying attention, you might not even realise when that magic is happening, and not happening. \n\nRight. So given **use is king**, let's look at two forms of it ...\n\n## Using Greet Via ()\n\nIf you **use** `greet` in a function call via `()`, it returns a vector with 3 elements: \n```cljs\n(greet \"You\")\n;; => [:div  \"Hello \" \"You\"]   ;; a vector of a keyword and two strings\n\n(first (greet \"You\"))\n;; => :div\n\n(second (greet \"You\"))\n;; => \"Hello\"\n```\n\nSo, simply calling such function certainly doesn't magically create a Reagent Component. It just returns a vector.\n\nHmmm. How about we call `greet` within another function: \n```clj\n(defn greet-family-round       ;; round on the end because using round brackets\n  [member1 member2 member3]\n  [:div\n    (greet member1)    ;; return value put into the vector\n    (greet member2)    ;; and again \n    (greet member3)])  ;; and again\n```\n\n`greet-family-round` returns a 4 element vector. And what's in that vector if we call it like this?\n```cljs\n(greet-family-round \"Mum\" \"Dad\" \"Aunt Edith\")\n```\n\nBecause `(greet \"Mum\")` returns `[:div  \"Hello \" \"Mum\"]`, that's the 2nd element in the vector. And so on.\n```cljs\n [:div\n    [:div  \"Hello \" \"Mum\"]          ;; <-- (greet \"Mum\") \n    [:div  \"Hello \" \"Dad\"]          ;; <-- (greet \"Dad\") \n    [:div  \"Hello \" \"Aunt Edith\"]]  ;; <-- (greet \"Aunt Edith\") \n```\n\n## Using Greet Via []\n\nLet's keep `greet` the same, but change the way it is **used**: \n```clj\n(defn greet-family-square\n  [member1 member2 member3]\n  [:div\n    [greet member1]      ;; not using ()\n    [greet member2]     \n    [greet member3]])  \n```\n\nLet's be crystal clear:  `[greet member1]` is a two element vector, just like `[1 2]`. \n\nAnd, what would this call return?\n```cljs\n(greet-family-square \"Mum\" \"Dad\" \"Aunt Edith\")  \n```\n\nAnswer:\n```cljs\n [:div\n    [greet \"Mum\"]         \n    [greet \"Dad\"]\n    [greet \"Aunt Edith\"]]\n```\n\nSo, `greet` is not called inside of `greet-family-square`. Instead, it is placed into a vector. \n\n## The Difference Between () and []\n\nHere is the hiccup returned by `greet-family-round`.\n```cljs\n [:div\n    [:div  \"Hello \" \"Mum\"]          ;; the return value of greet put in here\n    [:div  \"Hello \" \"Dad\"]          ;; and again \n    [:div  \"Hello \" \"Aunt Edith\"]]  ;; and again\n```\nYou'll notice this hiccup contains no references to `greet`. Only the (hiccup) values returned by calls to `greet`.\n\nOn the other hand, there **are** references to `greet` in the hiccup returned by `greet-family-square`\n```cljs\n [:div\n    [greet \"Mum\"]         \n    [greet \"Dad\"]\n    [greet \"Aunt Edith\"]]\n```\n\n## The Interpretation Of Hiccup\n\nAfter renderers return hiccup, Reagent interprets it. \n\nAs it does this interpretation, if Reagent sees a vector where the first element is a function, for example `[greet \"Mum\"]`, it interprets that function as a renderer **and it builds a React component around that renderer**. \n\nLet's pause and remember that a renderer function is the key, mandatory, central part of a Component. Defaults can be supplied for the other React lifecycle functions, like `component-should-update`, but a renderer **must** be supplied.\n\nSo Reagent recognises `greet` as a candidate renderer function and, if it is found in the right place (1st element of a vector), Reagent will mix it with other default lifecycle functions to form a full React/Reagent Component. It gives `greet` a, er, promotion.\n\nThe other elements of the vector, after `greet`, are interpreted as parameters to the renderer - in React terms, `props`. \n\n## Which and Why?\n\nSo, which variation of `greet-family` (`square` vs `round`) should I choose, and why?\n\nThe answer to \"which?\" is easy: you almost certainly want the `square` version.  \"why?\" takes more explanation ... \n\nFirst off, let's acknowledge that both variations will ultimately produce the same DOM, so in that respect they are the same. \n\nDespite this identical outcome, they differ in one significant way: \n\n  1. the `square` version will create each `greet` child as a distinct React component, each with its own React lifecycle, **allowing them to re-render independently of siblings**. \n  2. The `round` version causes the `greet` hiccup for all children to be incorporated  into the hiccup returned by the parent, forming one large data structure, parent and children all in together. So, each time the parent re-renders, all the `greet` children are effectively re-rendered too. React must then work out what, in this tree, has changed.\n\nAs a result, **the `square` version will be more efficient at \"re-render time\"**.  Only the DOM which needs to be re-rendered will be done. At our toy scale in this tutorial it hardly matters but, if `greet` was a more substantial child component, this gain in efficiency could be significant.\n\nArmed with a bit more knowledge, we'll revisit this subject at the end of the next Tutorial.\n\n## A Further, Significant \"Why\"\n\nIn the examples above, we've explored [Form-1 components](CreatingReagentComponents.md#form-1-a-simple-function)  - the simplest kind - and we've seen we have some choice regarding use of `()` or `[]`. Eventually, I claim that `[]` is much preferred, but you can get away with `()`, up to a point. \n\n**But** ... the moment you start using Form-2 or Form-3 components, you absolutely must be using `[]`.  No choice.  Using `()` just won't work at all. Given the explanations above, I'm hoping you can work out why. Either that or just shrug and use `[]` forever more. \n\n### Appendix #1\n\n`hiccup` can be created like any normal cljs data structure. You don't have to use literals.\n\nOur version of `greet-family-round` from above returns something of a 4 element vector literal:\n```clj\n(defn greet-family-round\n  [member1 member2 member3]\n  [:div\n    (greet member1)    \n    (greet member2)  \n    (greet member3)]) \n```\n\nHere's a rewrite in which the hiccup is less literal and more generated: \n```clj\n(defn greet-family-round-2       ;; a re-write \n  [& members]\n  (into [:div] (map greet members)))\n```\n\nWhen called with 3 parameters, both versions of this function return the same hiccup:\n```clj\n(= (greet-family-round   \"Mum\" \"Dad\" \"Aunt Edith\") \n   (greet-family-round-2 \"Mum\" \"Dad\" \"Aunt Edith\"))\n;; => true\n```\n\n### Appendix #2\n\nWhen interpreting hiccup, Reagent regards vectors as special, and it has some demands about their 1st element.\n\nIn Reagent hiccup, the 1st element of a vector **must always** be something it can use to build a Component. \n\nReagent can use `greet` to build a Component, so that works.  So does `:div` because Reagent knows what Component you mean. And there are a few other options.\n\nSo this is okay:   `[greet ...]`  and so is this  `[:div ...]`\n\n**But** if your hiccup contains a vector like `[1 2 3]`, then you'll get an error because Reagent can't use `1` to build a Component. \n\nSo this code has a problem:\n```clj \n(defn greet-v\n   [v]\n   (into [:div] (map greet v)))\n\n(defn greet-family\n   []\n   [greet-v [\"Mum\" \"Dad\" \"Aunt Edith\"]])  ;; <-- error here\n```\n\nNotice the vector `[\"Mum\" \"Dad\" \"Aunt Edith\"]` in the hiccup.  Reagent will try to build a Component using \"Mum\" (1st element in a vector) and, when that doesn't work, it will report an error.  \n\n## Next Step\n\nWe've now seen how we can use functions and `[]` to create Components. In the [next tutorial](WhenDoComponentsUpdate.md), we'll understand how and when these Components update. \n", :cljdoc.doc/type :cljdoc/markdown, :slug "using-square-brackets-instead-of-parentheses-", :cljdoc.doc/contributors ("Oleg" "Mohit Thatte" "Juho Teperi")}} {:title "When do components update?", :attrs {:cljdoc.doc/source-file "doc/WhenDoComponentsUpdate.md", :cljdoc/markdown "In this, more intermediate, Reagent tutorial, we delve into the question: when do Components re-render and why?  \n\n## Components Are Reactive\n\nReagent Components are \"reactive\" in the following way:\n  - each Component has a render function \n  - this render function turns `input data` into `hiccup`  (HTML)\n  - render functions are **rerun** when their `input data` changes, producing new hiccup\n  - that new hiccup is \"interpreted\" by Reagent and ultimately results in new HTML\n\nIt is this whole **re-running** the renderer function thing that makes a Component reactive. It \"reacts\" to changes in its \"inputs\", producing a new output.\n\nThis page is about understanding how and why these reactions happen. \n\n### Reactive To What?\n\nWe start by looking at the `inputs` to the process.  What things, when they change value, trigger a re-run of a Component's renderer?\n\nShort answer is that there's two kinds of `input data`: \n  - `props`\n  - `ratoms`  \n\nAs we'll soon see, these two kinds of input are not quite equal. There are differences in the way they trigger.\n\n## 1. Props\n\nThe first of these `inputs` is called `props`.\n\nConsider this example Component:\n```clj\n(defn greet\n  [name]          ;; name is a string            \n  [:div \"Hello \" name])\n```\n\n`name` is a `prop` (short for property).  In this example, it is a string value.  In our clojurescript/Reagent world, it takes the form of a parameter to the Component renderer, `greet`. \n\nEach time the value of `name` changes over time, `greet` will rerender. \n\nWait, what? How exactly can the value of `name` change over time - isn't it just a parameter? Don't parameters only ever get one value, when the function is called?\n\nWell, you'll remember from previous tutorials that `greet` is going to be \"promoted\" to be the render function of a Component. As a Component renderer, it will get called at least once, but probably many, many times. So there will be the opportunity for `name` to have a different value each time `greet` is called and, in that sense, it is a value which can change over time.\n\nTo understand further, imagine we had a parent Component, which uses `greet`:\n```clj\n(defn greet-family\n  [] \n  [:div \n    [greet \"Dad\"]\n    [greet (str \"Bro-\" (rand-int 10))]])\n```\n\nWhen Reagent interprets the hiccup returned by `greet-family`, it will create 3 further components:  \n\n  - a `:div` component, with two `greet` children\n  - the 1st `greet` child will always be given the `name` \"Dad\". Always the same prop\n  - the 2nd `greet` child will likely have a different value for `name` each time that `greet-family` renders. Perhaps \"Bro-1\" one time and \"Bro-5\" the next. Only 1 time in 10 will it be the same as last time.\n\nAfter a Component's renderer runs and produces hiccup, Reagent interprets it. When it processes the output of `greet-family`,  it will check to see if these 3 rerendered Components themselves need rerendering.  The test Reagent uses is a simple one: for each Component, are the newly supplied `props` different to those supplied in the last render. Have they \"changed\"? \n\nIf the `props` are different, then that Component's render will be called to create new hiccup.  But if the `props` to that Component are the same as last time, then no need to rerender it. \n\nObviously, the `[greet \"Dad\"]` component is rendered by `greet-family` the same way each time, and will get the same `props` every time and, so, it will not need re-rendering.  It will render once, at the beginning, but never again, no matter how many times its parent `greet-family` is rerendered. \n\nOn the other hand, `[greet (str \"Bro-\" (rand-int 10))]` will often render a different `name` prop. So, if `greet-family` rerenders, then that child component will often re-render too ... although about 1 time in 10 the prop this time will be the same as last time, and Reagent will determine that it doesn't need to be rerendered.\n\nWhich means we can now answer the question posed above - how can the value of `name` change over time for a given `greet` component?  Answer: when the parent Component re-renders, and supplies a new value as the `prop`.  \n\n`props` flow from the parent. **A Component can't get new `props` unless its parent rerenders.** \n\n## 2. Ratoms\n\nLet's now discuss the 2nd form of `input data` to a Component.  \n\nThis example is a bit contrived, but bear with me ...\n```clj\n(def name  (reagent.ratom/atom \"Bear\"))\n\n(defn ask-for-forgiveness\n  []           ;; <--- no props     \n  [:div \"Please \" @name \" with me\"])   ;; notice that @\n```\n\nWe can see that `ask-for-forgiveness` will return the hiccup  `[:div \"Please \" \"Bear\" \" with me\"]`\n\nWell, initially anyway, because initially `name` contains the string value \"Bear\".\n\nData is flowing into the render function via this `name` ratom.  Reagent will detect that this renderer has a ratom input, and it will watch that ratom for changes.\n\nIf I suddenly got all scientific, and did this `(reset! name \"Ursidae\")`, Reagent would detect the change in `name`, and it would re-run any Component renderer which is dependent upon it.  That means `ask-for-forgiveness` is re-run, producing the new hiccup `[:div \"Please \" \"Ursidae\" \" with me\"]`.\n\nJust so we're clear: a \"data input\" changes (the value in a ratom) and, then, the renderer is rerun to produce new hiccup.  The Component is reactive to the ratoms it derefs.\n\n## A Combination\n\nSo that was the basics.  \n\nLet's now look at how these things can combine. We're going to consider a case involving two child components, and a parent. \n\nChild Component 1:\n```clj\n(defn greet-number\n  \"I say hello to an integer\"\n  [num]                             ;; an integer\n  [:div (str \"Hello #\" num)])       ;; [:div \"Hello #1\"]\n```\n\nChild component 2: \n```clj\n(defn more-button\n  \"I'm a button labelled 'More' which increments counter when clicked\"\n  [counter]                                ;; a ratom\n  [:div  {:class \"button-class\"\n          :on-click  #(swap! counter inc)} ;; increment the int value in counter\n   \"More\"])    \n```\n\nAnd, finally, a Form-2 parent Component which uses these two child components:\n```clj\n(defn parent\n  [] \n  (let [counter  (reagent.ratom/atom 1)]    ;; the render closes over this state\n    (fn  parent-renderer \n      []\n      [:div \n        [greet-number @counter]      ;; notice the @. The prop is an int\n        [more-button counter]])))    ;; no @ on counter\n\t\n```\n\nWith this setup, answer this question: what rerendering happens each time the `more-button` gets clicked and `counter` gets incremented? \n\nDon't read on. Test yourself. Spend 30 seconds working it out.\n\nAnswer:\n  1. Reagent will notice that `counter` has changed and that is an `input ratom` to `parent-renderer`, and it will rerun that renderer. \n  2. Reagent will interpret the hiccup returned by `parent-renderer`, and it will determine that a new (integer) prop has been supplied in the `[greet-number @counter]` Component, and it will then rerender that component too. \n\nWait. Is that it?  Why doesn't the `[more-button counter]` component rerender too?  After all, its `prop` `counter` has changed???\n\nNo, I promise it won't rerender. But why not?  The answer is a bit subtle.\n\nYou see, `counter` itself hasn't changed. It is still the same ratom it was before. The value **in** `counter` has been incremented, but `counter` itself is still the same ratom.  So from Reagent's point of view `[more-button counter]` involves the same `prop` as \"last time\" and it concludes that there's no need for a rerender of that component. \n\nHad `more-button` dereferenced the `counter` ratom THEN the change in `counter` should have triggered a rerender of `more-button`.  But if you look at `more-button` you'll see no `@counter`. There is no dereference.\n\nIf you truly understand this example, then you've gone a long way to officially getting it. \n\n## Different \n\nAlthough they are both ways to trigger a reactive re-render, the two kinds of `inputs` have different properties: \n  1. the definition of \"changed\" applied\n  2. treatment of lifecycle functions\n\n## Changed?\n\nTill now, I've said a renderer will be re-run when an input value \"changed\".  But I've been carefully avoiding any definition of \"changed\".\n\nYou see, there's at least two definitions: `=` and `identical?`\n\n```\n(def x1  {:a 42  :b 45})    ;; at time 1, x has this value\n(def x2  {:a 42  :b 45})    ;; at time 2, x has this value\n\n(= x1 x2)                   ;; is x the same, or has it changed? \n;; =>  true                 ;; answer: no change\n\n(identical? x1 x2)          ;; is x the same, or has it changed?\n;; => false                 ;; answer: different\n```\n\nSo we can see different answers to the question \"has x changed?\" for the same values, depending on the function we use.\n\nFor `props`,  `=` is used to determine if a new value have changed with regard to an old value. \n\nFor ratoms, `identical?` is used (on the value inside the ratom) to determine if a new value has changed with regard to an old value. \n\nSo, it is only when values are deemed to have \"changed\", that a re-run is triggered, but the inputs use different definitions of \"changed\".  This can be confusing. \n\nThe `identical?` version is very fast. It is just a single reference check.\n\nThe `=` version is more accurate, more intuitive, but potentially more expensive. Although, as I'm writing this I notice that `=` uses `identical?` [when it can](https://github.com/clojure/clojurescript/blob/1b7390450243693d0b24e8d3ad085c6da4eef204/src/main/cljs/cljs/core.cljs#L1108-L1124).\n\n**Update:**\n\n> As of Reagent 0.6.0, ratoms use `=` (instead of `identical?`) is to determine if a new value is different to an old value. So, `ratoms` and `props` now have the same `changed?` semantics. \n\n### Efficient Re-renders\n\nIt's only via rerenders that a UI will change.  So re-rendering is pretty essential.  \n\nOn the other hand, unnecessary re-rendering should be avoided.  In the worst case, it could lead to performance problems.  By unnecessary rendering, I mean rerenders which result in unchanged HTML. That's a whole lot of work for no reason.\n\nSo this notion of \"changed\" is pretty important.  It controls if we are doing unnecessary, performance-sapping re-rendering work. \n\n### Lifecycle Functions\n\nWhen `props` change, the entire underlying React machinery is engaged. Reagent Components can have lifecycle methods like `component-did-update` and these functions will get called, just as they would if you were dealing with a React Component. \n\nBut ... when the re-render occurs because an input ratom changed, **Lifecycle functions are not run**.  So, for example, `component-did-update` will not be called on the Component. \n\nCareful of this one. It trips people up.\n\n\n## Appendix 1\n\nIn the previous Tutorial, we looked at the difference between `()` and `[]`. \n\nTowards the end, I claimed that using `[]` was more efficient at \"re-render time\".  Hopefully, after the tutorial above, our knowledge is a bit deeper and we can now better appreciate the truth in this claim. \n\nRemember this code from the previous tutorial:\n```clj\n(defn greet-family-square\n  [member1 member2 member3]\n  [:div\n    [greet member1]     ;; using [] not ()\n    [greet member2]     \n    [greet member3]])  \n```\n\nNow, imagine it used like this:\n```clj\n ;; the 3rd member of the family to greet\n(def extra (reagent.core/atom \"Aunt Edith\"))  \n\n(defn top-level-component\n    []\n    [greet-family-square  \"Mum\" \"Dad\" @extra])\n\n(reagent.core/render [top-level-component] (.-body js/document)))\n```\n\nThe first time the page is rendered, the DOM created will greet three cherished people.  All good.  At this point, the `round` and `square` versions of `greet-family` would be equally good at getting the initial DOM into our browser.\n\nBut then, out of nowhere, comes information that our rich and eccentric Uncle John is rewriting his Last Will And Testament, and we need a fast, realtime change in our page. Luckily we have a repl handy, and we type `(reset! extra \"Uncle John\")`.  We've changed that `extra` r/atom which holds the 3rd cherished family member - sorry \"Aunt Edith\", you're out. \n\nWhat happens next?\n\n1. Reagent will recognize that a `top-level-component` component relies on `extra` which has changed.  \n2. So it will rerender that component. In the hiccup produced (by the rerender), it will see that `greet-family-square` has a new 3rd prop. And, by that, I mean that the value for the 3rd prop (\"Uncle John\") will not compare `=` to the value last rendered (\"Aunt Edith\"). \n3. So Reagent will trigger a rerender of `greet-family-square` with the new props (\"Mum\" \"Dad\" and \"Uncle John\")\n4. In the hiccup produced by this rerender, Reagent will notice that the first two `greet` components have the same prop as that last rendered (\"Mum\" and \"Dad\") but that the 3rd `greet` component has a new prop value (\"Uncle John\"). \n5. So it will NOT rerender the first two `greet`, but the renderer for the 3rd will be rereun. \n \nAs you can see, only the right parts of the tree are re-rendered.  Nothing unnecessary is done.\n\nIn the alternative `greet-family-round` version we looked at, the one which used `()` instead of `[]`, that efficiency is not possible. \n\nA re-render of `greet-family-round` always triggers three calls to `greet`, no matter what, accumulating a large amount of hiccup for `greet-family-round` to return.  It would then be left to React to diff all this new DOM with existing DOM and for it to work out that, in fact, parts of the tree (the first two greet parts) remain the same, and should be ignored. Which is a whole lot of unnecessary work!\n\nWhen we use `[]`, we get independent React Components which will only be re-rendered if their `props` change (or ratoms change). More efficient, more minimal re-renderings.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "when-do-components-update-", :cljdoc.doc/contributors ("Juho Teperi" "Alan Thompson" "Dosbol")}} {:title "[WIP] Managing State: atoms, cursors, Reactions, and tracking", :attrs {:cljdoc.doc/source-file "doc/ManagingState.md", :cljdoc/markdown "# Managing state: atoms, cursors, Reactions, and tracking\n\nAlthough it is possible to update reagent components by remounting the entire component tree with `reagent.dom/render`, Reagent comes with a sophisticated state management library based on `reagent.core/atom`, which allows components to track application state and update only when needed. Reagent also provides cursors, which are like ratoms but can be constructed from portions of one or more other ratoms to limit or expand which ratoms a component watches. Finally, Reagent provides a set of tracking primitives called reactions and a set of utility functions to build more customized state management.\n\n**TODO is this right?**\n\n## Intro to atoms\n\nReagent provides an implementation of atom that you can create with `reagent/atom` and use just like a normal Clojure atom, which are often referred to as \"ratoms\" to distinguish from normal atoms. Reagent tracks any dereferences to ratoms made during a component's render function.\n\n```clojure\n(ns example\n  (:require [reagent.core :as r]))\n\n(def click-count (r/atom 0))\n\n(defn counting-component []\n  [:div\n   \"The atom \" [:code \"click-count\"] \" has value: \"\n   @click-count \". \"\n   [:input {:type \"button\" :value \"Click me!\"\n\t\t\t:on-click #(swap! click-count inc)}]])\n```\n\n### Mutating a ratom\n\nYou manipulate using the standard `reset!` and `swap!` functions.\n\n```clojure\n(reset! state-atom {:counter 0})\n```\n\n```clojure\n(swap! state-atom assoc :counter 15)\n```\n\n### Dereferencing a ratom\n\nYou access the atom using `deref` or the shorthand `@`.\n\n```clojure\n(:counter (deref state-atom))\n(:counter @state-atom)\n```\n\n### The effect of dereferencing a ratom\n\n* A dereference to the ratom during its render function will cause that component to re-render whenever any part of that ratom is updated. (See the section below on cursors to get finer control over update behavior.)\n* Dereferencing a ratom in a callback or event handler after the render function has run will not make the component react to any changes to the ratom (though of course any _changes_ to the ratom made in an event handler will make any watching components re-render).\n\n### rswap!\n\n`rswap!` works like standard `swap!` except that it\n\n* always returns `nil`\n* allows recursive applications of `rswap!` on the same atom\n\nThat makes `rswap!` especially suited for event handling.\n\nHere’s an example that uses event handling with `rswap!`:\n\n```clojure\n(defn event-handler [state [event-name id value]]\n  (case event-name\n\t:set-name   (assoc-in state [:people id :name]\n\t\t\t\t\t\t  value)\n\t:add-person (let [new-key (->> state :people keys (apply max) inc)]\n\t\t\t\t  (assoc-in state [:people new-key]\n\t\t\t\t\t\t\t{:name \"\"}))\n\tstate))\n\n(defn emit [e]\n  ;; (js/console.log \"Handling event\" (str e))\n  (r/rswap! app-state event-handler e))\n\n(defn name-edit [id]\n  (let [p @(r/track person id)]\n\t[:div\n\t [:input {:value (:name p)\n\t\t\t  :on-change #(emit [:set-name id (.-target.value %)])}]]))\n\n(defn edit-fields []\n  (let [ids @(r/track person-keys)]\n\t[:div\n\t [name-list]\n\t (for [i ids]\n\t   ^{:key i} [name-edit i])\n\t [:input {:type 'button\n\t\t\t  :value \"Add person\"\n\t\t\t  :on-click #(emit [:add-person])}]]))\n```\n\nAll events are passed through the emit function, consisting of a trivial application of `rswap!` and some optional logging. This is the only place where application state actually changes – the rest is pure functions.\n\nThe actual event handling is done in event-handler, which takes state and event as parameters, and returns a new state (events are represented by vectors here, with an event name in the first position).\n\nAll the UI components have to do is then just to return some markup, and set up routing of events through the emit function.\n\nThis architecture basically divides the application into two logical functions:\n\n* The first takes state and an event as input, and returns the next state.\n\n* The other takes state as input, and returns a UI definition.\n\nThis simple application could probably just as well use the common `swap!` instead of `rswap!`, but using `swap!` in React’s event handlers may trigger warnings due to unexpected return values, and may cause severe headaches if an event handler called by emit itself emits a new event (that would result in lost events, and much confusion).\n\nFor a more structured version of a similar approach, see the excellent re-frame framework.\n\n**TODO: is this the right example for rswap? If this is just re-frame light, maybe this shouldn't be in here. It would be better to have a more concise example.**\n\n## Cursors\n\nAny component that dereferences a state atom will update whenever any part of it is updated. If you are storing all state in a single atom (not uncommon), it will cause every component to update whenever the state is updated. Performance-wise, this may be acceptable, depending on how many elements you have and how often your state updates, because React itself will not manipulate the DOM unless the components actually change.\n\nReagent provides cursors, which behave like atoms but operate like pointers into a larger atom (or into multiple parts of multiple atoms).\n\nCursors are created with `reagent/cursor`, which takes a ratom and a keypath (like `get-in`):\n\n```clojure\n;; First create a ratom\n(def state (reagent/atom {:foo {:bar \"BAR\"}\n                                :baz \"BAZ\"\n                                :quux \"QUUX\"}))\n;; Now create a cursor\n(def bar-cursor (reagent/cursor state [:foo :bar]))\n\n(defn quux-component []\n  (js/console.log \"quux-component is rendering\")\n  [:div (:quux @state)])\n\n(defn bar-component []\n  (js/console.log \"bar-component is rendering\")\n  [:div @bar-cursor])\n\n(defn mount-root []\n  (rdom/render [:div [quux-component] [bar-component]]\n    (.getElementById js/document \"app\"))\n  (js/setTimeout (fn [] (swap! state assoc :baz \"NEW BAZ\")) 1000)\n  (js/setTimeout (fn [] (swap! state assoc-in [:foo :bar] \"NEW BAR\")) 2000))\n\n\n;; Console output:\n;; quux-component is rendering\n;; bar-component is rendering\n;; After 1 second:\n;; quux-component is rendering\n;; After 2 seconds:\n;; quux-component is rendering\n;; bar-component is rendering\n```\n\nBoth `bar-component` and `quux-component` update whenever their respective cursors/atoms update, but because `bar-component`'s cursor is limited only to the relevant portion of the app-state, it only re-renders when `[:foo :bar]` updates, whereas `quux-component` updates each time `app-state` changes, even though `:quux` never changes.\n\n### More general cursors\n\nThe cursor mechanism is more general than described above. You can pass a function that performs arbitrary transformations on one or more atoms.\n**TODO (DO WE NEED TO EXPLAIN THIS?)**\n\nReagent also provides the `reagent/wrap` mechanism, which also derives a new atom but provides more general functionality. Where a cursor will always update the atom from which it was derived, `reagent/wrap` takes an atom and a callback that will be called whenever the derived atom is updated. Replacing `(r/cursor n [:first-name])` with `(r/wrap first-name swap! n assoc :first-name)]` gives essentially the same results.\n**TODO (WHAT UTILITY DOES THIS HAVE?)**\n\n## Reactions\n\nReactions are like cursors called with a function.\n\nWhen reactions produce a new result (as determined by `=`), they cause other dependent reactions and components to update.\n\nThe function `make-reaction`, and its macro `reaction` are used to create a `Reaction`, which is a type that belongs to a number of protocols such as `IWatchable`, `IAtom`, `IReactiveAtom`, `IDeref`, `IReset`, `ISwap`, `IRunnable`, etc. which make it atom-like: ie it can be watched, derefed, reset, swapped on, and additionally, tracks its derefs, behave reactively, and so on.\n\nReactions are what give `r/atom`, `r/cursor`, and `r/wrap` their power.\n\n`make-reaction` takes one argument, `f`, and an optional options map. The options map specifies what happens to `f`:\n\n* `auto-run` (boolean) specifies whether `f` run on change\n* `on-set` and `on-dispose` are run when the reaction is set and unset from the DOM\n* `derefed` **TODO unclear**\n\nReactions are very useful when\n\n* You need a way in which a component only updates based on part of the ratom state. (reagent/cursor can also be used for this scenario)\n* When you want to combine two `ratoms` and produce a result\n* You want the component to use some transformed value of `ratom`\n\nHere's an example:\n```\n (def app-state (reagent/atom {:state-var-1 {:var-a 2\n                                             :var-b 3}\n                               :state-var-2 {:var-a 7\n                                             :var-b 9}}))\n\n (def app-var2a-reaction (reagent.ratom/make-reaction\n                          #(get-in @app-state [:state-var-2 :var-a])))\n\n\n (defn component-using-make-reaction []\n   [:div\n    [:div \"component-using-make-reaction\"]\n    [:div \"state-var-2 - var-a : \" @app-var2a-reaction]])\n\n```\n\nThe below example uses `reagent.ratom/reaction` macro, which provides syntactic sugar compared to \nusing plain `make-reaction`:\n\n```\n(let [username (reagent/atom \"\")\n      password (reagent/atom \"\")\n      fields-populated? (reagent.ratom/reaction (every? not-empty [@username @password]))]\n [:div \"Is username and password populated ?\" @fields-populated?])\n```\nReactions are executed asynchronously, so be sure to call `flush` if you depend on reaction side effects.\n\n## The track function\n\n`reagent.core/track` takes a function, and optional arguments for that function, and gives a derefable (i.e \"atom-like\") value, containing whatever is returned by that function. If the tracked function depends on a Reagent atom, it is called again whenever that atom changes – just like a Reagent component function. If the value returned by `track` is used in a component, the component is re-rendered when the value returned by the function changes.\n\nIn other words, `@(r/track foo x)` gives the same result as `(foo x)` – but in the first case, foo is only called again when the atom(s) it depends on changes.\n\nHere's an example:\n\n```clojure\n(ns example.core\n  (:require [reagent.core :as r]))\n(defonce app-state (r/atom {:people\n                              {1 {:name \"John Smith\"}\n                               2 {:name \"Maggie Johnson\"}}}))\n\n(defn people []\n  (:people @app-state))\n\n(defn person-keys []\n  (-> @(r/track people)\n\t  keys\n\t  sort))\n\n(defn person [id]\n  (-> @(r/track people)\n\t  (get id)))\n\n(defn name-comp [id]\n  (let [p @(r/track person id)]\n\t[:li\n\t (:name p)]))\n\n(defn name-list []\n  (let [ids @(r/track person-keys)]\n\t[:ul\n\t (for [i ids]\n\t   ^{:key i} [name-comp i])]))\n```\n\nHere, the name-list component will only be re-rendered if the keys of the :people map changes. Every name-comp only renders again when needed, etc.\n\nUse of track can improve performance in three ways:\n\n1. It can be used as a cache for an expensive function, that is automatically updated if that function depends on Reagent atoms (or other tracks, cursors, etc).\n2. It can also be used to limit the number of times a component is re-rendered. The user of track is only updated when the function’s result changes. In other words, you can use track as a kind of generalized, read-only cursor.\n3. Every use of track with the same arguments will only result in one execution of the function. E.g the two uses of `@(r/track people)` in the example above will only result in one call to the people function (both initially, and when the state atom changes).\n\n_Note:_ Compared to reactions, `reagent.ratom/reaction` and `track` are similar. The main differences are that track uses named functions and variables, rather than depending on closures, and that you don’t have to manage their creation manually (since tracks are automatically cached and reused).\n\n_Note:_ The first argument to track should be a named function, i.e not an anonymous one. Also, beware of lazy data sequences: don’t use deref (i.e ”@”) with the for macro, unless wrapped in doall (just like in Reagent components).\n\n### The track! function\n\n`track!` works just like track, except that the function passed is invoked immediately, and continues to be invoked whenever any atoms used within it changes.\n\nFor example, given this function:\n\n```clojure\n(defn log-app-state []\n  (prn @app-state))\n```\n\nyou could use `(defonce logger (r/track! log-app-state))` to monitor changes to app-state. `log-app-state` would continue to run until you stop it, using `(r/dispose! logger)`.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "-wip-managing-state-atoms-cursors-reactions-and-tracking", :cljdoc.doc/contributors ("Juho Teperi" "Robin Nagpal" "Alan Thompson" "romankrru")}} {:title "Batching and Timing: How Reagent Renders Changes to Application State", :attrs {:cljdoc.doc/source-file "doc/BatchingAndTiming.md", :cljdoc/markdown "# Batching and Timing: How Reagent Renders Changes to Application State\n\nChanges in application state (as represented by Reagent’s `atom`s) are not rendered immediately to the DOM. Instead, Reagent waits until the browser is ready to repaint the window, and then all the changes are rendered in one single go.\n\nThis is good for all sorts of reasons:\n\n* Reagent doesn't have to spend time doing renderings that no one would ever see (because changes to application state happened faster than the browser could repaint).\n* If two or more atoms are changed simultaneously, this now leads to only one re-rendering, and not two.\n* The new code does proper batching of renderings even when changes to atoms are done outside of event handlers (which is great for e.g core.async users).\n* Repaints can be synced by the browser with for example CSS transitions, since Reagent uses requestAnimationFrame to do the batching. That makes for example animations smoother.\n\nIn short, Reagent renders less often, but at the right times. For a much better description of why async rendering is good, see David Nolen’s [excellent explanation here.](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs)\n\n## The bad news\n\nLunches in general tend to be non-free, and this is no exception. The downside to async rendering is that you can no longer depend on changes to atoms being immediately available in the DOM. (Actually, you couldn't have truly relied upon it anyway because React.js itself does batching inside event handlers.)\n\nThe biggest impact is in testing: be sure to call `reagent.core/flush` to force Reagent to synchronize state with the DOM.\n\n## An example\n\nHere is an example to (hopefully) demonstrate the virtues of async rendering. It consists of a simple color chooser (three sliders to set the red, green and blue components of a base color), and shows the base color + a bunch of divs in random matching colors. As soon as the base color is changed, a new set of random colors is shown.\n\nIf you change one of the base color components, the base color should change immediately, and smoothly (on my Macbook Air, rendering takes around 2ms, with 20 colored divs showing).\n\nBut perhaps more interesting is to see what happens when the updates can’t be made smoothly (because the browser simply cannot re-render the colored divs quickly enough). On my machine, this starts to happen if I change the number of divs shown to above 150 or so.\n\nAs you increase the number of divs, you’ll notice that the base color no longer changes quite so smoothly when you move the color sliders.\n\nBut the crucial point is that the sliders **still work**. Without async rendering, you could quickly get into a situation where the browser hangs for a while, doing updates corresponding to an old state.\n\nWith async rendering, the only thing that happens is that the frame rate goes down.\n\nBtw, I find it quite impressive that React manages to change 500 divs (12 full screens worth) in slightly more than 40ms. And even better: when I change the number of divs shown, it only takes around 6ms to re-render the color palette (because the individual divs don’t have to be re-rendered, divs are just added or removed from the DOM as needed).\n\n```clojure\n(ns example\n  (:require [reagent.core :as r]))\n(defn timing-wrapper [f]\n  (let [start-time (r/atom nil)\n        render-time (r/atom nil)\n        now #(.now js/Date)\n        start #(reset! start-time (now))\n        stop #(reset! render-time (- (now) @start-time))\n        timed-f (with-meta f\n                  {:component-will-mount start\n                   :component-will-update start\n                   :component-did-mount stop\n                   :component-did-update stop})]\n    (fn []\n      [:div\n       [:p [:em \"render time: \" @render-time \"ms\"]]\n       [timed-f]])))\n\n(def base-color (r/atom {:red 130 :green 160 :blue 120}))\n(def ncolors (r/atom 20))\n(def random-colors (r/atom nil))\n\n(defn to-rgb [{:keys [red green blue]}]\n  (let [hex #(str (if (< % 16) \"0\")\n                  (-> % js/Math.round (.toString 16)))]\n    (str \"#\" (hex red) (hex green) (hex blue))))\n\n(defn tweak-color [{:keys [red green blue]}]\n  (let [rnd #(-> (js/Math.random) (* 256))\n        tweak #(-> % (+ (rnd)) (/ 2) js/Math.floor)]\n    {:red (tweak red) :green (tweak green) :blue (tweak blue)}))\n\n(defn reset-random-colors [color]\n  (reset! random-colors\n          (repeatedly #(-> color tweak-color to-rgb))))\n\n(defn color-choose [color-part]\n  [:div.color-slider\n   (name color-part) \" \" (color-part @base-color)\n   [:input {:type \"range\" :min 0 :max 255\n            :value (color-part @base-color)\n            :on-change (fn [e]\n                         (swap! base-color assoc\n                                color-part (-> e .-target .-value int))\n                         (reset-random-colors @base-color))}]])\n\n(defn ncolors-choose []\n  [:div.color-slider\n   \"number of color divs \" @ncolors\n   [:input {:type \"range\" :min 0 :max 500\n            :value @ncolors\n            :on-change #(reset! ncolors (-> % .-target .-value int))}]])\n\n(defn color-plate [color]\n  [:div.color-plate\n   {:style {:background-color color}}])\n\n(defn palette []\n  (let [color @base-color\n        n @ncolors]\n    [:div\n     [:p \"base color: \"]\n     [color-plate (to-rgb color)]\n     [:div.color-samples\n      [:p n \" random matching colors:\"]\n      (map-indexed (fn [k v]\n                     ^{:key k} [color-plate v])\n                   (take n @random-colors))]]))\n\n(defn color-demo []\n  (reset-random-colors @base-color)\n  (fn []\n    [:div\n     [:h2 \"Matching colors\"]\n     [color-choose :red]\n     [color-choose :green]\n     [color-choose :blue]\n     [ncolors-choose]\n     [timing-wrapper palette]]))\n```\n\n## Tapping into the rendering loop\n\nThe `next-tick` function allows you to tap into the rendering loop. The function passed to `next-tick` is invoked immediately before the next rendering (which is in turn triggered using `requestAnimationFrame`).\n\nThe `after-update` is similar: it works just like `next-tick`, except that the function given is invoked immediately after the next rendering.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "batching-and-timing-how-reagent-renders-changes-to-application-state", :cljdoc.doc/contributors ("Tharaka Manawardhana" "Juho Teperi")}} {:title "Interop with React", :attrs {:cljdoc.doc/source-file "doc/InteropWithReact.md", :cljdoc/markdown "# Interop with React\n\nA little understanding of what Reagent is doing really helps when trying to use\nReact libraries and reagent together.\n\n## Creating React Elements directly\n\nThe `reagent.core/create-element` function simply calls React's `createElement`\nfunction (and therefore, it expects either a string representing an HTML\nelement or a React Component).\n\nAs an example, here are four ways to create the same element:\n\n```clojure\n(defn integration []\n  [:div\n   [:div.foo \"Hello \" [:strong \"world\"]]\n\n   (r/create-element \"div\"\n                     #js{:className \"foo\"}\n                     \"Hello \"\n                     (r/create-element \"strong\"\n                                        #js{}\n                                        \"world\"))\n\n   (r/create-element \"div\"\n                     #js{:className \"foo\"}\n                     \"Hello \"\n                     (r/as-element [:strong \"world\"]))\n\n   [:div.foo \"Hello \" (r/create-element \"strong\"\n                                        #js{}\n                                        \"world\")]])\n\n(defn mount-root []\n  (rdom/render [integration]\n    (.getElementById js/document \"app\")))\n```\n\nThis works because `reagent.dom/render` itself expects (1) a React element or (2) a\nHiccup form. If passed an element, it just uses it. If passed a Hiccup, it\ncreats a (cached) React component and then creates an element from that\ncomponent.\n\n## Creating React Elements from Hiccup forms\n\nThe `reagent.core/as-element` function creates a React element from a Hiccup\nform. In the previous section, we discussed how `reagent.dom/render` expects either\n(1) a Hiccup form or (2) a React Element. If it encounters a Hiccup form, it\ncalls `as-element` on it. When you have a React component that wraps children,\nyou can pass Hiccup forms to it wrapped in `as-element`.\n\n## Creating Reagent \"Components\" from React Components\n\nThe function `reagent/adapt-react-class` will turn a React Component into\nsomething that can be placed into the first position of a Hiccup form, as if it\nwere a Reagent function. Take, for example the react-flip-move library and\nassume that it has been properly imported as a React Component called\n`FlipMove`. By wrapping FlipMove with `adapt-react-class`, we can use it in a\nHiccup form:\n\n```clojure\n(defn top-articles [articles]\n  [(reagent/adapt-react-class FlipMove)\n   {:duration 750\n    :easing \"ease-out\"}\n   articles]\n```\n\nThere is also a convenience mechanism `:>` (colon greater-than) that shortens\nthis and avoid some parenthesis:\n\n```clojure\n(defn top-articles [articles]\n  [:> FlipMove\n   {:duration 750\n    :easing \"ease-out\"}\n   articles]\n```\n\nThis is the equivalent JavaScript:\n\n```clojure\nconst TopArticles = ({ articles }) => (\n  <FlipMove duration={750} easing=\"ease-out\">\n    {articles}\n  </FlipMove>\n);\n```\n\n## Creating React Components from Reagent \"Components\"\n\nThe `reagent/reactify-component` will take a Form-1, Form-2, or Form-3 reagent \"component\". For example:\n\n```clojure\n(defn exported [props]\n  [:div \"Hi, \" (:name props)])\n\n(def react-comp (r/reactify-component exported))\n\n(defn could-be-jsx []\n  (r/create-element react-comp #js{:name \"world\"}))\n```\n\nNote:\n\n* `adapt-react-class` and `reactify-component` are not perfectly symmetrical,\nbecause `reactify-component` requires that the reagent component accept\neverything in a single props map, including its children.\n\n## Example: \"Decorator\" Higher-Order Components\n\nSome React libraries use the decorator pattern: a React component which takes a\ncomponent as an argument and returns a new component as its result. One example\nis the React DnD library. We will need to use both `adapt-react-class` and\n`reactify-component` to move back and forth between React and reagent:\n\n```clojure\n(def react-dnd-component\n  (let [decorator (DragDropContext HTML5Backend)]\n    (reagent/adapt-react-class\n      (decorator (reagent/reactify-component top-level-component)))))\n```\n\nThis is the equivalent JavaScript:\n\n```clojure\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport { DragDropContext } from 'react-dnd';\n\nclass TopLevelComponent {\n  /* ... */\n}\n\nexport default DragDropContext(HTML5Backend)(TopLevelComponent);\n```\n\n## Example: Function-as-child Components\n\nSome React components expect a function as their only child. React AutoSizer is one such example.\n\n```clojure\n[(reagent/adapt-react-class AutoSizer)\n {}\n (fn [dims]\n  (let [dims (js->clj dims :keywordize-keys true)]\n   (reagent/as-element [my-component (:height dims)])))]\n```\n\n## Getting props and children of current component\n\nBecause you just pass arguments to reagent functions, you typically don't need\nto think about \"props\" and \"children\" as distinct things. But Reagent does make\na distinction and it is helpful to understand this, particularly when\ninteroperating with native elements and React libraries.\n\nSpecifically, if the first argument to your Reagent function is a map, that is\nassigned to `this.props` of the underlying Reagent component. All other\narguments are assigned as children to `this.props.children`.\n\nWhen interacting with native React components, it may be helpful to access\nprops and children, which you can do with `reagent.core/current-component`.\nThis function returns an object that allows you retrieve the props and children\npassed to the current component.\n\nBeware that `current-component` is only valid in component functions, and must\nbe called outside of e.g. event handlers and `for` expressions, so it's safest\nto always put the call at the top, as in `my-div` here:\n\n```clojure\n(ns example\n  (:require [reagent.core :as r]))\n\n(defn my-div []\n  (let [this (r/current-component)]\n    (into [:div.custom (r/props this)]\n          (r/children this))))\n\n(defn call-my-div []\n  [:div\n    [my-div \"Some text.\"]\n    [my-div {:style {:font-weight 'bold}}\n      [:p \"Some other text in bold.\"]]])\n```\n\n## React Features\n\n- [React Features and how to use them in Reagent](./ReactFeatures.md)\n\n## Examples\n\n- [Material-UI](../examples/material-ui/src/example/core.cljs)\n- [React-sortable-hoc](../examples/react-sortable-hoc/src/example/core.cljs)\n", :cljdoc.doc/type :cljdoc/markdown, :slug "interop-with-react", :cljdoc.doc/contributors ("Juho Teperi" "boxp" "Alan Thompson")}} {:title "React Features", :attrs {:cljdoc.doc/source-file "doc/ReactFeatures.md", :cljdoc/markdown "# React Features\n\nMost React features should be usable from Reagent, even if Reagent doesn't\nprovide functions to use them directly.\n\n## [Fragments](https://reactjs.org/docs/fragments.html)\n\nJSX:\n```js\nfunction example() {\n  return (\n    <React.Fragment>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </React.Fragment>\n  );\n}\n```\n\nReagent:\n```cljs\n(defn example []\n  [:<>\n   [child-a]\n   [child-b]\n   [child-c]])\n```\n\nReagent syntax follows [React Fragment short syntax](https://reactjs.org/docs/fragments.html#short-syntax).\n\n## [Context](https://reactjs.org/docs/context.html)\n\n```cljs\n(defonce my-context (react/createContext \"default\"))\n\n(def Provider (.-Provider my-context))\n(def Consumer (.-Consumer my-context))\n\n(rdom/render\n  [:> Provider {:value \"bar\"}\n   [:> Consumer {}\n    (fn [v]\n      (r/as-element [:div \"Context: \" v]))]]\n  container)\n```\n\nAlternatively you can use the [static contextType property](https://reactjs.org/docs/context.html#classcontexttype)\n\n```cljs\n(defonce my-context (react/createContext \"default\"))\n\n(def Provider (.-Provider my-context))\n\n(defn show-context []\n  (r/create-class\n   {:context-type my-context\n    :reagent-render (fn []\n                      [:p (.-context (reagent.core/current-component))])}))\n\n;; Alternatively with metadata on a form-1 component:\n;;\n;; (def show-context\n;;   ^{:context-type my-context}\n;;   (fn []\n;;     [:p (.-context (reagent.core/current-component))]))\n\n(rdom/render\n  [:> Provider {:value \"bar\"}\n   [show-context]]\n  container)\n```\n\nTests contain example of using old React lifecycle Context API (`context-wrapper` function):\n[tests](https://github.com/reagent-project/reagent/blob/master/test/reagenttest/testreagent.cljs#L1159-L1168)\n\n## [Error boundaries](https://reactjs.org/docs/error-boundaries.html)\n\n[Relevant method docs](https://reactjs.org/docs/react-component.html#static-getderivedstatefromerror)\n\nYou can use `getDerivedStateFromError` (since React 16.6.0 and Reagent 0.9) (and `ComponentDidCatch`) lifecycle method with `create-class`:\n\n```cljs\n(defn error-boundary [comp]\n  (let [error (r/atom nil)]\n    (r/create-class\n      {:component-did-catch (fn [this e info])\n       :get-derived-state-from-error (fn [e]\n                                            (reset! error e)\n                                            #js {})\n       :reagent-render (fn [comp]\n                          (if @error\n                            [:div\n                             \"Something went wrong.\"\n                             [:button {:on-click #(reset! error nil)} \"Try again\"]]\n                            comp))})))\n```\n\nAlternatively, one could use React state instead of RAtom to keep track of error state, which\ncan be more obvious with the new `getDerivedStateFromError` method:\n\n```cljs\n(defn error-boundary [comp]\n  (r/create-class\n    {:constructor (fn [this props]\n                    (set! (.-state this) #js {:error nil}))\n     :component-did-catch (fn [this e info])\n     :get-derived-state-from-error (fn [error] #js {:error error})\n     :render (fn [this]\n               (r/as-element\n                 (if @error\n                   [:div\n                    \"Something went wrong.\"\n                    [:button {:on-click #(.setState this #js {:error nil})} \"Try again\"]]\n                   (into [:<>] (r/children this)))})))\n```\n\nAs per React docs, `getDerivedStateFromError` is what should update the state\nafter error, it can be also used to update RAtom as in Reagent the Ratom is available\nin function closure even for static methods. `ComponentDidCatch` can be used\nfor side-effects, like logging the error.\n\n## [Hooks](https://reactjs.org/docs/hooks-intro.html)\n\nHooks can't be used inside class components, and Reagent implementation creates\na class component from every function (i.e. Reagent component).\n\nHowever, you can use React components using Hooks inside Reagent, or use\n[hx](https://github.com/Lokeh/hx) components inside Reagent. Also, it is\npossible to create React components from Reagent quite easily, because React\nfunction component is just a function that happens to return React elements,\nand `r/as-element` does just that:\n\n```cljs\n;; This is React function component. Can't use Ratoms here!\n(defn example []\n  (let [[count set-count] (react/useState 0)]\n    (r/as-element\n      [:div\n       [:p \"You clicked \" count \" times\"]\n       [:button\n        {:on-click #(set-count inc)}\n        \"Click\"]])))\n\n;; Reagent component\n(defn reagent-component []\n  [:div\n   ;; Note :> to use a function as React component\n   [:> example]])\n```\n\nIf you need to pass RAtom state into these components, dereference them in\nthe Reagent components and pass the value (and if needed, function to update them)\nas properties into the React function component.\n\n## [Portals](https://reactjs.org/docs/portals.html)\n\n```cljs\n(defn reagent-component []\n  (r/create-class\n    {:render (fn [this]\n               (let [el (.. js/document (getElementById \"portal-el\"))]\n                 (react-dom/createPortal (r/as-element [:div \"foo\"]) el)))}))\n\n```\n\nTODO: Can this be done without create-class and `:render`.\nTODO: This might have problems handling Ratoms, test.\n\n## [Hydrate](https://reactjs.org/docs/react-dom.html#hydrate)\n\n```cljs\n(react-dom/hydrate (r/as-element [main-component]) container)\n```\n", :cljdoc.doc/type :cljdoc/markdown, :slug "react-features", :cljdoc.doc/contributors ("Juho Teperi" "Arne Brasseur")}} {:title "Controlled Inputs", :attrs {:cljdoc.doc/source-file "doc/ControlledInputs.md", :cljdoc/markdown "# Controlled inputs\n\nReagent uses async rendering which cause problems with controlled inputs. If\nthe input element is created directly by Reagent (i.e. `[:input ...]` in hiccup), [a\nworkaround](https://github.com/reagent-project/reagent/blob/master/src/reagent/impl/template.cljs#L132-L238)\ncan be applied, but if the input is created by JS library (i.e. JSX `<input>`\nor React `create-element`), Reagent doesn't see\nthe element so the workaround can't be applied.\n\nDue to async rendering, the DOM update doesn't occur during the event handler,\nbut some time later. In certain cases, like when the cursor is not at the end\nof the input, updating the DOM input value causes the cursor to move to the\nend of the input. Without async rendering, browsers probably implement logic\nto keep the cursor position if the value is updated during event handler.\n\nReagent workaround works by changing the React input element into\nuncontrolled input (i.e. the DOM value is not updated by React). Instead\nReagent will update DOM itself if the Reagent input value property changes.\nThis enables Reagent to check the cursor position before updating the\nvalue, and if needed, save and restore the cursor position\nafter updating the value.\n\nFor JS libraries, usually the best solution is if the library provides an option to\nuse custom component to create the input element, which enables\nReagent to create the input element:\n\n## Examples\n\n- [Material UI](./examples/material-ui.md)\n- [Smooth UI](./examples/smooth-ui.md)\n", :cljdoc.doc/type :cljdoc/markdown, :slug "controlled-inputs", :cljdoc.doc/contributors ("Juho Teperi")}}]} {:title "Frequently Asked Questions", :attrs {:slug "frequently-asked-questions"}, :children [{:title "Why isn't my Component re-rendering?", :attrs {:cljdoc.doc/source-file "doc/FAQ/ComponentNotRerendering.md", :cljdoc/markdown "### Question\n\nMy component is not re-rendering, what's wrong?\n\n### Answer\n\nAsk yourself this question: why do you think the Component should have re-rendered? There's two possible answers: \n  - a ratom (used by the Component) changed \n  - the props for (arguments to) the Component changed\n\nWe'll deal with these two cases seperately.\n\n### A Ratom Changed\n\nIf a ratom changes but your Component doesn't update, then the gotchas to look out for are: \n1. Make sure you are using a `reagent.core/atom` (i.e. a Reagent ratom) instead of a normal `clojure.core/atom`. Carefully check the `require` at the top of the `ns`.  Components are only reactive with respect to Reagent ratoms. They don't react to changes in a Clojure atom. \n2. Make sure you actually `deref` your ratom (e.g. `@app-state`) during the render function of your component. It is a common mistake for people to forget the leading `@`.  Note that derefs that happen outside of the render function (such as during event handlers) do not make your component reactive to that ratom.\n3. Make sure your ratom will survive a rerender. Either declare it as a global var, or use a form-2 or form-3 component. [Read this](https://github.com/reagent-project/reagent-cookbook/tree/master/basics/component-level-state) if you want to understand why.\n4. If you put your ratom in a form-2 or form-3 component, be sure you are calling that function using `[square brackets]`, not `(parenthesis)`.\nWhen function (component) is called using `( )` Reagent doesn't create new component, but instead just places the function's return value into current component. In this case the function closure which should hold the local state doesn't work.\n5. Make sure to `deref` your ratom outside of a seq or wrap that seq in a `doall`. See this [related issue](https://github.com/reagent-project/reagent/issues/18).\n\n### Props Change\n\nIf the props to a Component change, but it doesn't appear to re-render, then the cause will be this rookie mistake: you forgot to repeat the parameters in the inner, anonymous render function.\n\n```clj\n(defn outer \n  [a b c]            ;; <--- parameters\n  ;;  ....\n  (fn [a b c]        ;; <--- forgetting to repeat parameters here is the mistake\n    [:div\n      (str a b c)]))\n```\n\nIf you forget, the component renderer will stubbornly only ever render the \noriginal parameter values, not the updated ones, which can be baffling for \na beginner.\n\nRemember, `outer` is called once per component instance. The parameters to `outer` \nwill hold the initial parameter values. The inner renderer on the other hand, \nwill be called by Reagent many times and, each time, potentially with alternative \nparameter values, but unless you repeat the parameters on the renderer it will \nclose over those initial values in `outer`. As a result, the component renderer \nwill stubbornly only ever render the original parameter values, not the updated ones. \n\n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "why-isn-t-my-component-re-rendering-", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "How do I use React's \"refs\"", :attrs {:cljdoc.doc/source-file "doc/FAQ/UsingRefs.md", :cljdoc/markdown "### Question\n\nWhen using Reagent, how do I use React's `refs`?\n\n### Answer\n\nCredit: this entry is entirely based on Paulus Esterhazy's [Reagent Mysteries series](https://presumably.de/reagent-mysteries-part-3-manipulating-the-dom.html)\n\nWe'll start with a code fragment, because it is worth a 1000 words:\n\n```cljs\n(defn video-ui []\n  (let [!video (clojure.core/atom nil)]    ;; stores the\n    (fn [{:keys [src]}]\n      [:div\n       [:div\n        [:video {:src src\n                 :style {:width 400}\n                 :ref (fn [el]\n                        (reset! !video el))}]]\n       [:div\n        [:button {:on-click (fn []\n                              (when-let [video @!video] ;; not nil?\n                                (if (.-paused video)\n                                  (.play video)\n                                  (.pause video))))}\n         \"Toogle\"]]])))\n```\n\nNotes:\n   1. This example uses a Form-2 component, which allows us to retain state outside of the renderer `fn`.  The same technique would work with a Form-3 component.\n   2. We capture state in `!video`. In this example, the state we capture is a reference to a [video HTML element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video).\n   3. `!video` is a `clojure.core/atom` and not a `reagent.core/atom`.  We use a normal Clojure `atom` because refs never change during the lifecycle of a component and if we used a reagent atom, it would cause an unnecessary re-render when the ref callback mutates the atom.\n   4. On the `:video` component there's a `:ref` callback function which establishes the state in `!video`.  You can attach a ref callback to any of the Hiccup elements.\n   5. Thereafter, `@!video` is used with the `:button's` `:on-click` to manipulate the `video` DOM methods.\n   6. For full notes [read Paulus' blog post](https://presumably.de/reagent-mysteries-part-3-manipulating-the-dom.html)\n   7. For more background on callback refs, see [React's documentation](https://facebook.github.io/react/docs/more-about-refs.html)\n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "how-do-i-use-react-s-refs-", :cljdoc.doc/contributors ("TristeFigure" "Alan Thompson" "Juho Teperi")}} {:title "How can I use an entity like \"nbsp\"?", :attrs {:cljdoc.doc/source-file "doc/FAQ/UsingAnEntity.md", :cljdoc/markdown "### Question\n\nHow can I use an entity like \"nbsp\"?\n\n### Answer\n\nIf you try to do this:\n```clj\n[:div \"hello\" \"&nbsp;\" \"there\"]     ;; <--- note: attempt to use an entity\n```\nthen you will see the string for the entity. Which is not what you want. \n\nInstead you should do this:\n\n  1. Require in goog's string module...\n\n  ```clj\n  (:require [goog.string :as gstring])\n  ```\n\n  2. Use it like this ... \n\n  ```clj\n   [:div \"hello\" (gstring/unescapeEntities \"&nbsp;\") \"there\"]\n  ```\n\n**Note:** `unescapeEntities` relies on the DOM to produce a string with unescape entities;\nin `nodejs` the DOM is unlikely to be available (unless you try using\n[`jsdom`](https://www.npmjs.com/package/jsdom-global)).\n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "how-can-i-use-an-entity-like-nbsp-", :cljdoc.doc/contributors ("Daniel Compton" "Juho Teperi")}} {:title "Why is my attribute (like autoFocus) missing?", :attrs {:cljdoc.doc/source-file "doc/FAQ/MyAttributesAreMissing.md", :cljdoc/markdown "### Question\n\nWhy isn't my attribute `xyz` showing up on <some-element>?  (where is `xyz` is something like `autoFocus`)\n\n### Answer\n\nYou might be spelling it incorrectly. \n\nReact supports [camelCased HTML attributes](https://reactjs.org/docs/dom-elements.html#all-supported-html-attributes),\nbut the equivalent in Reagent is dashed and lower cased. \n\nFor example, with Reagent, you use `auto-focus`, instead of `autoFocus`. And \nyou use `col-span` instead of React's `colSpan`. \n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "why-is-my-attribute-like-autofocus-missing-", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "How can I use React's dangerouslySetInnerHTML?", :attrs {:cljdoc.doc/source-file "doc/FAQ/dangerouslySetInnerHTML.md", :cljdoc/markdown "### Question\n\nHow can I use React's [dangerouslySetInnerHTML](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml) feature?\n\n### Answer\n\nA minimal (contrived example):\n\n```clj\n[:div\n {:dangerouslySetInnerHTML\n  {:__html \"<image  height=\\\"600\\\" src=\\\"https://static1.squarespace.com/static/58f9c2fbd2b85759c7e4ec2f/5923cbe4be6594d8a0b033a9/5a0154a6ec212d85ddf7941f/1511246183022/mfsprout_20160406_1234-Print.jpg?format=1500w\\\"/>\"}}]\n```\n\n***\n\nUp:  [FAQ Index](../README.md)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n", :cljdoc.doc/type :cljdoc/markdown, :slug "how-can-i-use-react-s-dangerouslysetinnerhtml-", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "Reagent doesn't work after updating dependencies", :attrs {:cljdoc.doc/source-file "doc/FAQ/CljsjsReactProblems.md", :cljdoc/markdown "# Question\n\nReagent doesn't work after updating dependencies.\n\n# Answer\n\nIf you see errors about accessing `React` or `ReactDOM` object or some React method after you have updated your dependencies, the problem is probably conflicting `cljsjs/react` or `cljsjs/react-dom` versions. Other dependencies than Reagent might bring in versions which don't work with Reagent, or a library which only depends on one of the packages might cause React and ReactDOM versions to conflict.\n\nTo fix this you should check `lein deps :tree` or `boot show -d`, and check which version of Cljsjs React packages you have.\n\nThere are three alternative solutions:\n\n1. Update all the packages that require Cljsjs React packages to use same (or compatible) versions as Reagent\n2. Add `:exclusion [cljsjs/react cljsjs/react-dom]` to problematic dependencies, so only Reagent\nwill have transitive dependency on React packages\n3. Add direct `cljsjs/react` and `cljsjs/react-dom` dependencies to your project, which will override any transitive dependencies\n\nNote: `cljsjs/react-dom-server` package is deprecated but Reagent still depends on empty package for compatibility.\n\nNote: For more information on how Leiningen and Boot resolve dependencies using Maven-resolver, read: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html\n", :cljdoc.doc/type :cljdoc/markdown, :slug "reagent-doesn-t-work-after-updating-dependencies", :cljdoc.doc/contributors ("Juho Teperi")}}]} {:title "Examples", :attrs {:slug "examples"}, :children [{:title "Material-UI v1", :attrs {:cljdoc.doc/source-file "doc/examples/material-ui.md", :cljdoc/markdown "# Material-UI\n\n[Example project](../../examples/material-ui/)\n\nMaterial-UI [TextField](https://material-ui.com/api/text-field/) has for long\ntime caused problems for Reagent users. The problem is that `TextField` wraps the\n`input` element inside a component so that Reagent is not able to enable\ninput cursor fixes, which are required due to [async rendering](http://reagent-project.github.io/news/reagent-is-async.html).\n\nGood news is that Material-UI v1 has a property that can be used to provide\nthe input component to `TextField`:\n\n```cljs\n(ns example.material-ui\n  (:require [\"material-ui\" :as mui]\n            [reagent.core :as r]))\n\n(def text-field (r/adapt-react-class mui/TextField))\n\n(def value (r/atom \"\"))\n\n(def input-component\n  (r/reactify-component\n    (fn [props]\n      [:input (-> props\n                  (assoc :ref (:inputRef props))\n                  (dissoc :inputRef))])))\n\n(def example []\n  [text-field\n   {:value @value\n    :on-change #(reset! value (.. e -target -value))\n    :InputProps {:inputComponent input-component}}])\n```\n\n`reactify-component` can be used to convert Reagent component into React component,\nwhich can then be passed into Material-UI. The component should be created once\n(i.e. on top level) to ensure it is not unnecessarily redefined, causing the\ncomponent to be re-mounted.\nFor some reason Material-UI uses different name for `ref`, so the `inputRef` property\nshould be renamed by the input component.\n\n## Wrapping for easy use\n\nInstead of providing `:InputProps :inputComponent` option to every `TextField`,\nit is useful to wrap the `TextField` component in a way that the option is added always:\n\n```cljs\n(defn text-field [props & children]\n  (let [props (-> props\n                  (assoc-in [:InputProps :inputComponent] input-component)\n                  rtpl/convert-prop-value)]\n    (apply r/create-element mui/TextField props (map r/as-element children))))\n```\n\nHere `r/create-element` and `reagent.impl.template/convert-prop-value` achieve\nthe same as what `adapt-react-class` does, but allows modifying the props.\n\n**Check the example project for complete code.** Some additional logic is\nrequired to ensure option like `:multiline` and `:select` work correctly,\nas they affect how the `inputComponent` should work.\n\nTODO: `:multiline` `TextField` without `:rows` (i.e. automatic height) doesn't\nwork, because that requires Material-UI `Input/Textarea`, which doesn't work\nwith Reagent cursor fix.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "material-ui-v1", :cljdoc.doc/contributors ("Juho Teperi" "Jonathan Chen")}}]} {:title "Other", :attrs {:slug "other"}, :children [{:title "0.8 Upgrade guide", :attrs {:cljdoc.doc/source-file "doc/0.8-upgrade.md", :cljdoc/markdown "# 0.8 Upgrade guide\n\nThe necessary changes depend on what environment you target, and\nhow you want to provide React.\n\n|                | Build       | Browser       | Node |\n|---|---|---|---|\n| Cljsjs         | `:none`     | Supported     | Requires Cljs 1.10.238+ |\n| Cljsjs         | `:advanced` | Supported     | Requires Cljs 1.10.238+ |\n| `node modules` | `:none`     | Requires Cljs 1.10.312 | Supported  |\n| `node modules` | `:advanced` | Requires Cljs 1.10.312 | Supported  |\n\n## Browser - Cljsjs\n\n**This is the recommended setup.**\n\nUsing Reagent with Cljsjs packages doesn't require changes,\nother than making sure you update Cljsjs React dependencies,\nif you have direct dependencies to them.\n\nTo ensure Cljsjs libs are used instead of Node Modules, you can add `:npm-deps false`, which will make sure ClojureScript compiler doesn't look into `node_modules` directory if it exists.\n\n## Browser - node modules\n\nIf `react`, `react-dom` and `create-react-class` are available in `node_modules`\ndirectory, ClojureScript compiler will use these with Reagent.\n\nIf you don't want to call `npm` and manage `package.json`, you can use `:npm-deps` and `:install-deps` compiler options to\nhave ClojureScript install the packages automatically.\n\nYou can use `:process-shim` compiler option to provide `process.env.NODE_ENV`\nconstant which is used by JS code to enable development and production\nbuilds. ClojureScript compiler will automatically set this constant to\n`production` value when using `:advanced` optimizations. This enables\nthe React production build.\n\nWhen using module processing, it should be possible to split output into several\n[modules](https://clojurescript.org/reference/compiler-options#modules).\n\n**Externs are required for use with node modules also!** React created objects\nstatically in several places and then accesses those dynamically. Closure-compiler\nwill in these cases rename the statically object properties, which will break\ndynamically accessing the objects. Externs fix this by defining which properties\nmust not be renamed.\n\n## Browser - Webpack\n\nhttps://clojurescript.org/guides/webpack\n\nIf you want to load React.js yourself from external JS file (CDN) or from custom bundle,\nit should be possible to override the Cljsjs foreign-libs, while still using externs from Cljsjs packages. To override the foreign-libs, you can provide following compiler option:\n\n```clj\n:foreign-libs\n [{:file \"bundje.js\",\n   :provides [\"react\" \"react-dom\" \"create-react-class\" \"react-dom/server\"],\n   :global-exports {react React\n                    react-dom ReactDOM\n                    create-react-class createReactClass\n                    react-dom/server ReactDOMServer}}]\n```\n\n## NodeJS - Cljsjs\n\nRequires https://github.com/clojure/clojurescript/commit/f7d611d87f6ea8a605eae7c0339f30b79a840b49\n\nAvailable in 1.10.238\n\nReagent should use Cljsjs libraries by default even when running on Node.\n\n## NodeJS - node modules\n\nInstall `react`, `react-dom` and `create-react-class` npm packages,\nand ClojureScript should automatically use `require` to\nload React for Reagent.\n\n## Electron\n\n???\n\n## React-native\n\nhttps://github.com/drapanjanas/re-natal/issues/128\n\n## Common Problems\n\n### Mismatch with Cljsjs and npm packages\n\nIf you have one npm package installed, e.g. `react`, you also need\nto provide others (`react-dom` and `create-react-class`), else\nCljsjs packages would be used for these, and packages from different sources\ndon't work together.\n\n### Previous problems\n\nBefore ClojureScript 1.10.312 there were couple of problems with npm support:\n\n1. Closure can't properly handle React 16 CommonJS module pattern: https://github.com/google/closure-compiler/issues/2841\nThis causes the production React code being loaded even for development builds.\nUsing Chrome React Developer Tools with this setup will break Reagent. Fixed by `[com.google.javascript/closure-compiler-unshaded \"v20180610\"]` ([PR](https://github.com/google/closure-compiler/pull/2963)), will be\nthe included in next the ClojureScript release.\n\n2. Closure optimization currently breaks certain statically created objects which are\naccessed dynamically in `ReactDOM/server`: https://github.com/facebook/react/issues/12368\nFixed by using `[com.google.javascript/closure-compiler-unshaded \"v20180319\"]` ([fix commit](https://github.com/google/closure-compiler/commit/c13cf48b98477e44409dba6359246bffa95b1c7b)), will be\nthe default in next ClojureScript release.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "0-8-upgrade-guide", :cljdoc.doc/contributors ("Juho Teperi")}} {:title "Development guide", :attrs {:cljdoc.doc/source-file "doc/development.md", :cljdoc/markdown "# Reagent development\n\n## Running tests\n\nThe tests use [Karma](https://karma-runner.github.io/2.0/index.html) to run tests on browsers. You need to install `karma` command to run the tests:\n\n```bash\nnpm install -g karma-cli\n```\n\nTo prepare different environments for tests run:\n\n```bash\n./prepare-test.sh\n```\n\nAfter this, you can run the full test set:\n\n```bash\n./run-tests.sh\n```\n\nRunning all the tests can take a while, so while developing Reagent,\nyou might want to focus on one test environment, and use Figwheel to\nrun tests on your browser:\n\n```\nlein figwheel client # For Cljsjs\nlein figwheel client-npm # NPM\n\n# Open http://0.0.0.0:3449 on a browser\n# Check console for test output\n```\n\n## Building package\n\nTo build Reagent and use built version in your applications run `lein install`\nand update the dependency on your app to use the version that was installed.\n\nNote that if `project.clj` uses a version that is released on Clojars, this command\nwill overwrite that version on your local Maven repository. To restore\nreal version, remove directory corresponding to the version from `~/.m2/repository/reagent/reagent/`.\n", :cljdoc.doc/type :cljdoc/markdown, :slug "development-guide", :cljdoc.doc/contributors ("Juho Teperi")}}]}]}}}
